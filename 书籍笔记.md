

# Web安全深度剖析

## 第五章 SQL注入漏洞

### 5.1 SQL注入原理

造成SQL注入漏洞的主要原因还是因为后端没有对用户的输入做任何或者说有效的过滤，导致拼接出了一条非预期的SQL语句并成功执行

### 5.2 注入漏洞分类

常见的SQL注入类型包括：数字型和字符型。也有人吧类型分的更多、更细。但不管注入类型如何，攻击者的目的只有一点，那就是绕过程序限制，使用户输入的数据带入数据库执行，利用数据库的特殊性获取更多的信息或者更大的权限

#### 5.2.1 数字型注入

数字型注入的最简单的一种型如下：`http://www.baidu.com?id=8`

要确定目标是否是数字型的注入，可以直接输入payload：`-1`拼接为`http://www.baidu.com?id=8-1`，此时如果页面发生了变化，则证明SQL端确实对`8-1`做了运算，以此便可确定是数字型注入

#### 5.2.2 字符型注入

当输入参数为字符串时，称为字符型；数字型和字符型最大的区别在于：数字型不需要单引号闭合，而字符串类型一般需要使用单引号来闭合

字符型例句：`select * from users where username='admin'`

最常见的注入方法是用`'`闭合前面的单引号并注释掉后面的单引号，中间则为可控部分，形如：`' or 1=1#`

### 5.3 常见的数据库注入

滴哦大数数据库而言，SQL注入的原理基本相似，因为每个数据库斗遵循一个SQL语法标准。但他们之间也存在许多细微的差异，包括语法、函数的不同。所以，在针对不同的数据库注入时，思路、方法也不可能完全一样

攻击者对数据库注入，无非是利用数据库获取更多的数据或者更大的权限，那么利用方式可以归为以下几大类：

+ 查询数据
+ 读写文件
+ 执行命令

#### 5.3.1 SQL Server

由于Docker Hub上没有找到现成环境且SQL Server就没遇到过，这里就偷懒了。需要的时候可以回去查......

#### 5.3.2 MySQL

##### 1. MySQL中的注释

MySQL支持以下3种注释风格

+ `#`：注释从`#`字符到行尾
+ `--`：注释从`--`序列到行尾。需要注意的是，使用此注释时，**后面需要跟上一个或多个空格**；注：空格、tag都可以
+ `/**/`：注释从`/*序列到后面*/`序列中间的字符

其中，`/**/`注释存在一个特点，观察以下SQL语句：

```sql
mysql> select username/*!50000,password*/ from users;
+----------+------------+
| username | password   |
+----------+------------+
| Dumb     | Dumb       |
| Angelina | I-kill-you |
| Dummy    | p@ssword   |
| secure   | crappy     |
| stupid   | stupidity  |
| superman | genious    |
| batman   | mob!le     |
| admin    | admin      |
+----------+------------+
```

这时因为`/*!*/`感叹号是有特殊意义的，比如`/*!50000,password*/`的意思是；若Mysql版本号高于或等于`5.0.00`，语句将会被执行

##### 2. 获取元数据

Mysql 5.0 及其以上版本提供了`information_schema.schema`，`information_schema.schema`是信息数据库，它提供了访问数据库元数据的方式

**1. 查询用户数据库名称**

```sql
mysql> select schema_name from information_schema.schemata;
+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| challenges         |
| ctfsu              |
| ewshop             |
| ggbond             |
| intruder           |
| lmonkey            |
| mysql              |
| nodejs             |
| performance_schema |
| pyspider           |
| pyuser             |
| security           |
| sys                |
| tp_access          |
+--------------------+
15 rows in set (0.00 sec)
```

**2. 查询当前数据库表**

```sql
mysql> select table_name from information_schema.tables where table_schema=database();
+------------+
| table_name |
+------------+
| emails     |
| gg_flag    |
| gg_users   |
| referers   |
| uagents    |
| users      |
+------------+
6 rows in set (0.00 sec)
```

**3. 查询指定表的所有字段**

```sql
mysql> select column_name from information_schema.columns where table_schema=database() and table_name='users';
+-------------+
| column_name |
+-------------+
| id          |
| username    |
| password    |
+-------------+
3 rows in set (0.02 sec)
```





# Python 黑帽子-黑客与渗透测试编程之道

## 1. 基础的网络编程工具

### 1.1 TCP 客户端

```py
import socket

target_host = 'www.httpbin.org'
target_port = 80

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((target_host, target_port))
# 由于本身是TCP协议，且发送的数据是标准的HTTP协议数据，所以会以HTTP协议来打包发送出去
client.send(b'GET /get HTTP/1.1\r\nHost: baidu.com\r\n\r\n')
response = client.recv(4096)
print(response.decode())
client.close()
```

+ `socket.AF_INET`：表示我们将使用标准的IPv4地址或主机名
+ `socket.SOCK_STREAM`：表示这是一个TCP客户端

HTTP GET 请求必须包含以下字段，每个字段以一个回车分割，结尾以两个回车结束：

```
GET /get HTTP/1.1
Host: baidu.com


```

### 1.2 UDP 客户端

```py
import socket

target_host = 'www.httpbin.org'
target_port = 80

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client.connect((target_host, target_port))
client.sendto(b'AAABBBCC', (target_host, target_port))
response = client.recvfrom(4096)

client.close()
```

+ `socket.SOCK_DGRAM`：表示这是一个UDP客户端
+ `recvfrom` ：会返回 消息字符串 还有` (IP address, Port)`

### 1.3 TCP 服务器

```py
import socket
import threading

IP = '0.0.0.0'
PORT = 9998


def main():
    # 创建 Server; socket.AF_INET: 使用AF_INET协议簇，形如：(host, port); socket.SOCK_STREAM: TCP协议
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((IP, PORT))
    # 最多允许5个客户端
    server.listen(5)
    print(f"[*] Listening or {IP}:{PORT}")

    while True:
        # 将接受到的客户端socket对象保存到client变量中，将远程链接的详细信息保存到address变量中
        client, address = server.accept()
        # print(address)        ('127.0.0.1', 55627)
        # print(client)         返回 socket 对象
        print(f"[*] Accepted connection from {address[0]}:{address[1]}")
        # 创建线程
        client_handler = threading.Thread(target=handler_client, args=(client,))
        client_handler.start()


def handler_client(client_socket):
    # 使用上下文管理器，由于这里本身传入的就是Socket对象，所以其实就省略了一句 sock.close()
    with client_socket as sock:
        request = sock.recv(1024)
        print(f"[*] Received: {request.decode('utf-8')}")
        sock.send(b'ACK')


if __name__ == '__main__':
    main()

```

