

# Linux各个目录的作用

```bash
/：根目录，位于目录结构的最顶层，包含 Fedora 操作系统中所有的目录和文件。
/bin：又称为二进制目录，包含了那些供系统管理员和普通用户使用的重要 linux 命令的二进制映像。
/boot：存放启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。
/dev：存放与设备 (包括外设) 有关的文件。
/etc：存放所有系统管理所需要的配置文件和子目录。
/home：存放用户的主目录，每个用户都有自己的用户目录，位置为：/home/用户名。
/lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。 几乎所有的应用程序都需要用到这些共享库。
/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。
/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。
/opt：这是给主机额外安装软件所摆放的目录。 比如你安装一个ORACLE数据库则就可以放到这个目录下。 默认是空的。
/proc：这是一个虚拟文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件。 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
/root：该目录为系统管理员，也称作超级权限者的用户主目录。
/sbin：只有系统管理员能使用的程序和指令。
/tmp：这个目录是用来存放一些临时文件的。
/usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。
```



# 软件包类型

## 软件包安装方法

| 系统平台                  | 包类型 | 工具          | 在线安装 |
| ------------------------- | ------ | ------------- | -------- |
| RedHat/Centos/Fedora/SUSE | rpm    | rpm、rpmbuild | yum      |
| Ubantu/Debian             | deb    | dpkg          | apt      |



## 二进制包的选择

+ 找不到合适的，就安装更高一级版本的
+ el6兼容el5，el5无法安装el6

### 选择合适的CPU的架构

+ x8664包，只能安装在64位的系统上
+ i386,i586,i686的软件包可以安装在32和64位系统上
+ noarch表示这个软件包与硬件构架无关，可以通用
+ 32位系统不能安装64位包

## 认识源码包

+ 优点：
  + 可以在任意平台上预编译，编译出来的软件包非常适合所在机器
  + 可以在编译的时候，通过配置，对某些功能进行定义，开启或关闭相应的功能

+ 缺点
  + 安装麻烦
  + 卸载麻烦
  + 升级麻烦

### 源码包安装三部曲

```
-prefix=.. Directories to put files in/usr/local 软件家目录
-bindir=.. $prefix/bin 命令的目录
--etcdir=..$prefix/etc 配置文件的目录
--mandir=..$prefix/share/man man 文档路径
--locale=...$prefix/share/locale 语言编码
```

编译：

```
make （使用gcc编辑器进行编译）
```

安装：

```
make install 类似 rpm -ivh
```

# 网络配置

## 网卡配置文件

```bash
[root@samba ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens160
TYPE=Ethernet	# 设备类型
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp	# DHCP 自动获取IP地址; static 则是静态获取IP地址
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens160
UUID=2e64b198-d0fd-4c6d-925c-209b526df159
DEVICE=ens160
ONBOOT=yes	# yes 代表在开机后自动激活网卡：no 代表需要手动激活	
```

# yum源的配置和使用

## yum 源的介绍

yum源：软件包管理器，类似于360软件管家

在互联网上，有着许多的yum仓库原，如：阿里源、华为原等。我们要做的只需要配置好yum源文件，让yum自动寻找

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230517195635400.png" alt="image-20230517195635400" style="zoom:50%;" />

## 本地yum源配置

1. 挂载镜像文件

   **注意：勾选已连接**

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230517204710854.png" alt="image-20230517204710854" style="zoom: 67%;" />

```bash
[root@samba media]# df -h
'文件系统        容量  已用  可用 已用% 挂载点
devtmpfs        1.9G     0  1.9G    0% /dev
tmpfs           1.9G     0  1.9G    0% /dev/shm
tmpfs           1.9G   10M  1.9G    1% /run
tmpfs           1.9G     0  1.9G    0% /sys/fs/cgroup
/dev/nvme0n1p2  9.3G  139M  9.2G    2% /
/dev/nvme0n1p9  7.5G  3.6G  3.9G   49% /usr
/dev/nvme0n1p7  947M   40M  908M    5% /tmp
/dev/nvme0n1p5  7.5G  251M  7.2G    4% /var
/dev/nvme0n1p3  7.5G   86M  7.4G    2% /home
/dev/nvme0n1p1  495M  155M  341M   32% /boot
/dev/nvme0n1p8  500M   16K  500M    1% /boot/efi
tmpfs           376M   16K  376M    1% /run/user/42
tmpfs           376M  3.5M  373M    1% /run/user/0
/dev/sr0        6.7G  6.7G     0  100% /media	# 这里可以看到光盘已成功挂载到了 /media 目录
```



2. 通过挂在的方式将镜像文件挂载到本地一个空目录里

   ```bash
   [root@samba /]# mount /dev/cdrom /media/
   mount: /media: WARNING: device write-protected, mounted read-only.
   ```

   

3. 告诉yum工具去哪个仓库里找相应的软件包（配置yum文件）

   1）清空并备份环境：

   ```shell
   [root@samba yum.repos.d]# pwd
   /etc/yum.repos.d
   [root@samba yum.repos.d]# ls
   redhat.repo
   [root@samba yum.repos.d]# mkdir /backup
   [root@samba yum.repos.d]# mv *.repo /backup/
   ```

​		2）查看软件仓库名和软件仓库路径

```bash
# 由于光盘是挂载到了 /media 这个目录下面，所以我们需要在这里寻找光盘的软件仓库
[root@samba yum.repos.d]# ll /media/
总用量 48
dr-xr-xr-x. 4 root root  2048 4月   4 2019 AppStream	# 软件仓库1
dr-xr-xr-x. 4 root root  2048 4月   4 2019 BaseOS	# 软件仓库2
dr-xr-xr-x. 3 root root  2048 4月   4 2019 EFI
-r--r--r--. 1 root root  8266 3月   1 2019 EULA
-r--r--r--. 1 root root  1455 4月   4 2019 extra_files.json
-r--r--r--. 1 root root 18092 3月   1 2019 GPL
dr-xr-xr-x. 3 root root  2048 4月   4 2019 images
dr-xr-xr-x. 2 root root  2048 4月   4 2019 isolinux
-r--r--r--. 1 root root   103 4月   4 2019 media.repo
-r--r--r--. 1 root root  1669 3月   1 2019 RPM-GPG-KEY-redhat-beta
-r--r--r--. 1 root root  5134 3月   1 2019 RPM-GPG-KEY-redhat-release
-r--r--r--. 1 root root  1796 4月   4 2019 TRANS.TBL
```

3）编辑yum配置文件

```bash
[root@samba yum.repos.d]# pwd
/etc/yum.repos.d
[root@samba yum.repos.d]# vim ded.repo

[BaseOS]	# 软件仓库名（可随便写；不要有特殊符号）
name=BaseOS	# 描述信息（可随便写）
baseurl=file:///media/BaseOS	# 指定软件仓库的所在路径：/media/BaseOS
gpgcheck=0	# 是否开启数字签名验证
enabled=1	# 启动仓库

[AppStream]
name=AppStream
baseurl=file:///media/AppStream
gpgcheck=0
enabled=1
```

3. 安装测试

```bash
# 清空yum缓存
[root@samba yum.repos.d]# yum clean all 
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
12 文件已删除

# 创建yum缓存
[root@samba yum.repos.d]# yum makecache
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream                                                                                                                                                                     213 MB/s | 5.3 MB     00:00
BaseOS                                                                                                                                                                        264 MB/s | 2.2 MB     00:00
上次元数据过期检查：0:00:01 前，执行于 2023年05月17日 星期三 09时08分41秒。
元数据缓存已建立。
```

# 服务概述

## 一、服务概述

+ 运行在操作系统后台的一个或者多个程序，为系统或者用户提供特定的服务
+ 可靠的、并发的、连续的不间断的运行，随时接受请求
+ 通过交互式提供服务

## 二、Linux下两大服务

### 1.独立服务

+ 独立的进程和独立的启动脚本
+ 启动方式：`systemcrl start serverName`

正是因为带有独立的脚本，所以可以直接使用`systemctl`控制

### 2.依赖服务

+ 没有毒瘤的启动服务，以来于xinetd服务（xinted服务本身是一个独立的服务）
+ 启动方式：`必须启动xinetd服务`

#### 什么是xinetd服务？

+ Extended internet daemon(扩展的网络守护进程)，又叫超级Internet)服务，常用来管理多种轻量级Internet)服务；
+ 作用：唤醒在睡觉的服务，由xinetd管理的服务只有在用到的时候才被唤醒，平时不占用系统资源：支
  持Tcp_Wrappers一种安全策略机制。

#### TCP_Wrappers简介：

TCP_Wrappers.是一个工作在应用层的安全工具，它只能针对某些具体的应用或者服务起到一定的防护作用。比如说ssh FTP等服务的请求，都会先受到TCP_Wrapperst的拦截。

# SSH服务

### SSH登录方式

+ 基于密码认证

  1. Client 向 Server 发起请求
  2. Server 向 Client 发送公钥
  3. Client 使用 Server 发送的公钥加密密码
  4. Server 使用私钥解密密码并判断密码是否正确
  5. 返回登录结果

  + 这种方法无法防御中间人攻击。在第一次登录的时候，会询问是否登录该SSH服务器

+ 基于密钥对登录（免密码）

  1. Client 在本地生成一对非对称密码
  2. Client 将公钥传给 Server
  3. Client 向 Server 发起 SSH 请求，并发送 Client 的公钥
  4. Server 比对 Client 的公钥与一开始发送的是否一致
  5. 一致则生成一串随机字符串并使用 Client 的公钥加密发给 Client
  6. Client 使用私钥解密处随机字符串并发给Server
  7. Server 验证字符串是否正确，并返回登录结果

### SSH密钥对登录配置流程

#### 1.Client 本地生成密钥对

```bash
# 客户端在本地生成密钥对
[root@samba ~]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):	# 保存密钥对的文件路径
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:+D8pmNd+esDiEi+R2uK3oVpAjQMYX9byIj0h6paDnZk root@samba.server
The key's randomart image is:
+---[RSA 2048]----+
|+.  o.           |
|.o.=o .          |
| .=o.+           |
|....+ ..         |
|o.o= o..S.       |
|.=E.  +.. o      |
|. . .o.B.o o     |
|   .o.B.=.+ o    |
|  .ooo.= o+=     |
+----[SHA256]-----+

[root@samba ~]# ll .ssh/
总用量 8
-rw-------. 1 root root 1823 5月  18 07:55 id_rsa	# 私钥
-rw-r--r--. 1 root root  399 5月  18 07:55 id_rsa.pub	# 公钥
```

#### 2.Client 上传公钥到Server端

> 上传到哪个用户的家目录，在SSH的时候就会以那个用户身份登录

```bash
# ssh-copy-id -i 公钥文件路径 登录用户@IP地址
[root@samba ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.231.129
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: ".ssh/id_rsa.pub"
The authenticity of host '192.168.231.129 (192.168.231.129)' can't be established.
ECDSA key fingerprint is SHA256:LHhmaYmTXaGoJIUQTKG4VyD32CHbyrM6mbPdVMR6wS8.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.231.129's password:

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@192.168.231.129'"
and check to make sure that only the key(s) you wanted were added.
```

#### 3.测试登录

登录成功！不需要密码

```bash
[root@samba ~]# ssh root@192.168.231.129
Activate the web console with: systemctl enable --now cockpit.socket
```

### SSH安全配置

#### 禁止root用户登录

​	了解软件相关知识

```bash
[root@samba ~]# rpm -ql openssh-server
/etc/ssh/sshd_config	# 配置文件
/usr/sbin/sshd	# 二进制命令
```

修改配置文件

```bash
[root@samba ~]# vim /etc/ssh/sshd_config
#LoginGraceTime 2m
#PermitRootLogin yes
PermitRootLogin no
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

# 重启服务
[root@samba ~]# systemctl restart sshd.service
```

#### 修改默认端口号

```bash
[root@samba ~]# vim /etc/ssh/sshd_config
#Port 22
Port 10022
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

# 重启服务
[root@samba ~]# systemctl restart sshd.service
```

修改端口号之后，需要做以下操作才能保证SSH正常服务

1. 连接SSH的时候增加 -p 参数指定端口号
2. 防火墙允许 10022 端口号通过

# DHCP 服务器配置

## 软件安装

### 查看软件包名

```bash
[root@samba ~]# yum list |grep dhcp
dhcp-client.x86_64                                   12:4.3.6-30.el8                                   @anaconda
dhcp-common.noarch                                   12:4.3.6-30.el8                                   @anaconda
dhcp-libs.x86_64                                     12:4.3.6-30.el8                                   @anaconda
dhcp-libs.i686                                       12:4.3.6-30.el8                                      BaseOS
dhcp-relay.x86_64                                    12:4.3.6-30.el8                                      BaseOS
dhcp-server.x86_64                                   12:4.3.6-30.el8                                      BaseOS
```

### 安装软件包

```bash
[root@samba ~]# yum -y install dhcp-server.x86_64
```

### 查看服务相关文件

```
[root@samba ~]# rpm -ql dhcp-server.x86_64
/etc/dhcp
/etc/dhcp/dhcpd.conf	# 配置文件
/usr/sbin/dhcpd	# 二进制命令
```

### 编辑配置文件

```bash
[root@samba ~]# cat /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp-server/dhcpd.conf.example	# DHCP服务配置参考这个文件
#   see dhcpd.conf(5) man page

option domain-name "itcast.cc";		# 域名配置（可选）
option domain-name-servers 114.114.114.114, 8.8.8.8;		# DNS服务器地址（可选）
default-lease-time 3600;	# 缺省租约
max-lease-time 7200;		# 客户端最大租约
log-facility local7;		# 定义日志设备载体（/var/log/boot.log 输出）

subnet 192.168.231.0 netmask 255.255.255.0 {	# 子网<掩码>
    range 192.168.231.1 192.168.231.100;		# IP 地址池范围
    option routers 192.168.231.129;				# 默认网关
    option broadcast-address 192.168.231.255;	# 广播地址
}
```

缺省租约和客户端最大租约介绍：

​	当客户端的 缺省租约 到期之后，就应该向服务器进行IP地址的续期。如果客户端没有这么做，那么最多到 客户端最大租约 时间，IP地址就会失效，服务器就会回收IP地址

# FTP服务配置

> 匿名用户的家目录默认在：/var/ftp

## 软件安装-Server

### 安装vsftpd

```bash
[root@samba ~]# yum install -y vsftpd
```

### 了解文件列表

```bash
[root@samba ~]# rpm -ql vsftpd
/etc/logrotate.d/vsftpd	# 日志轮转文件
/etc/pam.d/vsftpd		# 安全认证相关文件
/etc/vsftpd				# 配置文件主目录
/etc/vsftpd/ftpusers	# 用户列表文件（黑名单）
/etc/vsftpd/user_list	# 用户列表文件（黑名单|可黑可白）
/etc/vsftpd/vsftpd.conf	# 主配置文件	
/usr/share/doc/vsftpd/EXAMPLE/VIRTUAL_HOSTS/README		# 虚拟主机
/usr/share/doc/vsftpd/EXAMPLE/VIRTUAL_USERS/README		# 虚拟用户
/usr/share/man/man5/vsftpd.conf.5.gz					# 帮助手册
/usr/share/man/man8/vsftpd.8.gz
```

### 认识配置文件

```bash
[root@samba ~]# grep -v ^# /etc/vsftpd/vsftpd.conf
anonymous_enable=NO		# 支持匿名用户访问
local_enable=YES		# 非匿名用户访问
write_enable=YES		# 是否可写
local_umask=022			# 反掩码	file:644（666）	dir:755（777）
dirmessage_enable=YES	# 启用消息功能（banner）
xferlog_enable=YES		# 启用 xferlog 日志格式
connect_from_port_20=YES	# 支持主动模式（默认是被动模式）；RHEL8 还在使用 xinetd 来管理服务
xferlog_std_format=YES		# xferlog 日志模式
listen=NO					# ftp服务独立模式下的监听
listen_ipv6=YES

pam_service_name=vsftpd		# 必须与 /etc/pam.d/vsftpd 文件名保持一致
userlist_enable=YES			# 启用用户列表
```

### 赋予权限

```bash
chmod o+w /var/ftp/pub/
```

### 防火墙允许FTP服务通过

```bash
[root@samba ~]# firewall-cmd --permanent --add-service=ftp
success
[root@samba ~]# firewall-cmd --reload
success
[root@samba ~]# firewall-cmd --list-all |grep ftp
  services: cockpit dhcpv6-client ftp ssh
```

### 启动服务并开机自启

```bash
[root@samba ~]# systemctl start vsftpd.service
[root@samba ~]# systemctl enable vsftpd.service
Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /usr/lib/systemd/system/vsftpd.service.
# 查看端口状态
[root@samba ~]# netstat -nltp|grep 21
tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      2181/dnsmasq
tcp6       0      0 :::21                   :::*                    LISTEN      36258/vsftpd
```

## 软件安装-Client

```bash
[root@samba ~]# yum -y install ftp lftp		# 可以只安装 ftp
```

### 客户端登录

```bash
Name (192.168.231.128:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
```

## 开启本地用户消息功能

> 在哪个用户家目录创建消息文件，哪个用户在登录的时候就会显示消息

### 配置文件开启消息功能

```bash
[root@localhost ~]# grep -v ^# 
dirmessage_enable=YES
```

### 在用户家目录创建消息文件

匿名用户~

```bash
[root@localhost ~]# echo "welcome to anon home" > /var/ftp/.message
```

### 客户端访问

```bash
[root@samba ~]# ftp 192.168.231.130
Connected to 192.168.231.130 (192.168.231.130).
220 (vsFTPd 3.0.3)
Name (192.168.231.130:root): ftp
331 Please specify the password.
Password:
230-welcome to anon home
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
```

## 案例

### 1）允许匿名用户上传文件，并且可以下载其他用户上传的文件

```bash
[root@localhost vsftpd]# vim vsftpd.conf
# Allow anonymous FTP? (Beware - allowed by default if you comment this out).
anonymous_enable=yes		# 允许匿名登录
anon_upload_enable=YES		# 允许匿名上传
anon_umask=022				# 允许匿名用户上传文件
```

### 2）匿名用户上传的文件都保存在 /anon/data 里

```bash
[root@localhost ~]# mkdir /anon/data
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
anon_root=/anon/data		# 匿名用户的根目录设置
[root@localhost /]# chmod 555 /data/pub/		# 预防500错误
```

### 3）本地用户上传的文件都保存到 /local/data 里

```bash
[root@localhost ~]# mkdir /local
[root@localhost ~]# mkdir /local/data
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
local_root=/local/data		# 本地用户根目录设置
```

### 4）禁止用户访问其他用户的家目录

```bash
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
# chroot)
chroot_local_user=YES
```

### 5）允许匿名用户上传文件

#### FTP服务器操作

```bash
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=YES
anon_upload_enable=YES
anon_mkdir_write_enable=YES

[root@localhost ~]# systemctl restart vsftpd.service
```

#### FTP客户端上传文件测试

```bash
[root@localhost ~]# ftp 192.168.231.132
Connected to 192.168.231.132 (192.168.231.132).
220 (vsFTPd 3.0.3)
Name (192.168.231.132:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd upload
250 Directory successfully changed.
ftp> pwd
257 "/upload" is the current directory
ftp> put ftp.txt
local: ftp.txt remote: ftp.txt
227 Entering Passive Mode (192,168,231,132,93,168).
150 Ok to send data.
226 Transfer complete.
9 bytes sent in 0.00016 secs (56.25 Kbytes/sec)
```





## FTP访问控制

### 禁止用户访问

要禁止哪个用户访问FTP服务器，就把哪个用户添加到这里就好

```bash
[root@localhost ~]# cat /etc/vsftpd/ftpusers
# Users that are not allowed to login via ftp
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
```

## FTP虚拟用户

### 1、创建虚拟用户

密码文件格式：

​	username

​	password

```bash
[root@localhost ~]# mkdir /vftp
[root@localhost ~]# vim /vftp/vuser.txt
user2
123456
```

### 2、生成数据库文件

文本文件的密码格式无法被系统直接调用，所以需要使用`db_load`生成数据库文件

```bash
[root@localhost ~]# db_load -T -t hash -f /vftp/vuser.txt /vftp/vuser.db
[root@localhost ~]# ls /vftp/
vuser.db  vuser.txt
```

### 3、配置 PAM 文件

为了使服务器能够使用数据库文件，对客户端进行身份验证，需要调用系统的PAM模块；该目录下保存这大量与认证相关的配置文件

```
auth required pam_userdb.so db=/vftp/vuser 
这一行指定了 pam_userdb.so 模块对于身份验证是必需的，并且应使用位于 /vftp/vuser 的数据库进行查找。

account required pam_userdb.so db=/vftp/vuser 
这一行指定了 pam_userdb.so 模块对于帐户管理是必需的，并且应使用位于 /vftp/vuser 的相同数据库。
```



```bash
[root@localhost pam.d]# cd /etc/pam.d
[root@localhost pam.d]# cp vsftpd vsftpd.bak
[root@localhost pam.d]# vim vsftpd
#%PAM-1.0
#session    optional     pam_keyinit.so    force revoke
#auth       required    pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed
#auth       required    pam_shells.so
#auth       include     password-auth
#account    include     password-auth
#session    required     pam_loginuid.so
#session    include     password-auth
auth            required                pam_userdb.so           db=/vftp/vuser
account         required                pam_userdb.so           db=/vftp/vuser
```

### 4、创建虚拟账户对应账户

```bash
[root@localhost pam.d]# useradd -d /var/ftp/vuser vuser		# -d选项：指定用户家目录
[root@localhost pam.d]# chown vuser:vuser /var/ftp/vuser	# 修改目录的 所有着:所属组
[root@localhost pam.d]# ll /var/ftp/
总用量 0
drwxr-xr-x. 2 root  root   6 8月  12 2018 pub
drwx------. 3 vuser vuser 78 5月  19 23:20 vuser
[root@localhost pam.d]# chmod 555 /var/ftp/vuser/			# 缩小权限以预防 ftp 500 错误
[root@localhost pam.d]# echo "vuser' s home is here" > /var/ftp/vuser/vuser.txt
```

### 5、修改配置文件

```bash
[root@localhost pam.d]# grep -v ^# /etc/vsftpd/vsftpd.conf
anonymous_enable=NO			# 禁止匿名登录
local_enable=YES			# 允许本地用户访问FTP服务器
write_enable=NO				# 禁止用户对FTP做写入
local_umask=022				# 本地用户权限 file：644 folder：755
dirmessage_enable=YES		# 开启消息功能
xferlog_enable=YES			# 开启日志轮换
connect_from_port_20=YES	# 连接端口：20
xferlog_std_format=YES		# 日志写入格式 xferlog
chroot_local_user=YES		# 禁止用户访问其他用户家目录
listen=YES					# 开启独立模式 ipv4
listen_ipv6=NO				# 关闭独立模式 ipv6

pam_service_name=vsftpd		# 指定用于认证的PAM文件名
userlist_enable=YES			# 将 /etc/vsftpd/user_list 设置为黑名单；NO则为白名单
allow_writeable_chroot=YES	# 允许用户在家目录中上传和修改文件
guest_enable=YES			# 启用虚拟用户				
guest_username=vuser		# 虚拟用户名为：vuser
```

### 6、防火墙配置

```bash
[root@localhost vsftpd]# setenforce 0
[root@localhost vsftpd]# firewall-cmd --permanent --add-service=ftp
success
[root@localhost vsftpd]# firewall-cmd --reload
success
```

### 7、客户端测试

```bash
[root@samba /]# ftp 192.168.231.130
Connected to 192.168.231.130 (192.168.231.130).
220 (vsFTPd 3.0.3)
Name (192.168.231.130:root): user2
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
```

# Samba 服务器配置

## Samba服务的主要进程

+ smbd进程：控制发布共享目录与权限，复制文件传输 TCP 139 445
+ nmbd进程：用于名称解析NetBIOS UDP 137 138；基于NetBIOS 协议获得计算机名 ---> 解析为相应IP地址，实现信息通讯

## Samba 服务的安装配置

### 软件安装-Server

```bash
[root@localhost vsftpd]# yum -y install samba.x86_64
[root@localhost vsftpd]# rpm -ql samba
/etc/openldap/schema
/etc/openldap/schema/samba.schema
/etc/pam.d/samba
/usr/bin/smbstatus
```

### 防火墙开放服务

```bash
[root@localhost vsftpd]# firewall-cmd --permanent --add-service=samba
success
[root@localhost vsftpd]# firewall-cmd --reload
success
```

### 客户端安装

```
[root@samba /]# yum install -y samba-client.x86_64
```

### 客户端连接测试

`-L`：列出服务器上的共享资源	

```bash
[root@samba ~]# smbclient -L 192.168.231.130
Enter SAMBA\root's password:
Anonymous login successful

        Sharename       Type      Comment
        ---------       ----      -------
        print$          Disk      Printer Drivers
        IPC$            IPC       IPC Service (Samba 4.9.1)
Reconnecting with SMB1 for workgroup listing.
Anonymous login successful

        Server               Comment
        ---------            -------

        Workgroup            Master
        ---------            -------
```

## 认识配置文件

```bash

[root@localhost vsftpd]# vim /etc/samba/smb.conf
# See smb.conf.example for a more detailed config file or
# read the smb.conf manpage.
# Run 'testparm' to verify the config is correct after
# you modified it.

[global]							# 全局配置
        workgroup = SAMBA			# 工作组名称
        security = user				# 安全等级：user 用户名密码登录 | share 匿名登录 | server 外部服务器用户名密码

        passdb backend = tdbsam		# 指定密码数据库后端为tdbsam，即使用TDB格式的本地数据库存储用户密码

        printing = cups				# 启用打印功能，并使用CUPS作为打印系统。
        printcap name = cups		# 指定CUPS打印系统的打印机配置文件名称。
        load printers = yes			# 加载打印机
        cups options = raw			# 打印机选项

[homes]								# 定义了用户的个人目录共享。
        comment = Home Directories	# 描述信息
        valid users = %S, %D%w%S	# 允许访问个人目录共享的有效用户列表。
        browseable = No				# 隐藏共享名
        read only = No				# 不是只读
        inherit acls = Yes			# 继承访问控制列表（ACL）

[printers]							# 定义了打印机共享。
        comment = All Printers		# 描述信息
        path = /var/tmp				# 指定路径
        printable = Yes				# 允许打印机共享进行打印操作
        create mask = 0600			# 创建的文件权限掩码为0600
        browseable = No				# 隐藏共享名

[print$]								# 打印驱动共享
        comment = Printer Drivers		# 描述信息
        path = /var/lib/samba/drivers	# 打印驱动程序共享的路径为"/var/lib/samba/drivers"
        write list = @printadmin root	# 允许具有"printadmin"组权限和"root"用户权限的用户进行写操作
        force group = @printadmin		# 强制将文件所属组设置为"printadmin"组
        create mask = 0664				# 创建的文件权限掩码为0664
        directory mask = 0775			# 创建的目录权限掩码为0775
```

## 创建SMB用户

> Samba 不直接与本地账户共享账户，需要额外建立 Samba 账户。但是前提还得是本地需要有该账户

```bash
[root@localhost vsftpd]# useradd zhangsan
[root@localhost vsftpd]# smbpasswd -a zhangsan
New SMB password:
Retype new SMB password:
Added user zhangsan.
[root@localhost vsftpd]# pdbedit -L
zhangsan:1002:
```

### Samba用户登录

`-U`：指定用户名访问Samba服务

```bash
[root@samba ~]# smbclient //192.168.231.130/zhangsan -U zhangsan
Enter SAMBA\zhangsan's password:
Try "help" to get a list of possible commands.
smb: \> 
```

## Samba允许匿名用户访问 /samba/share 共享资源，本地不能访问

### 修改配置文件

```bash
[root@localhost vsftpd]# vim /etc/samba/smb.conf
[anon_share]
path = /home/samba
public = yes
writable = yes

[root@localhost vsftpd]# mkdir /home/samba -p
[root@localhost vsftpd]# systemctl restart smb.service

# 修改SELINUX，保证客户端可成功访问家目录的文件
[root@localhost home]# setsebool samba_enable_home_dirs  1
```

### 客户端访问

```bash
[root@samba ~]# smbclient //192.168.231.130/anon_share		# 路径的指定由配置中的全局名字决定
Enter SAMBA\root's password:
Anonymous login successful
Try "help" to get a list of possible commands.
smb: \>
```

# DNS服务器搭建

## 服务配置

```
[root@localhost vsftpd]# yum install -y bind
```

### 查看相关文件

```
[root@localhost vsftpd]# rpm -ql bind
/etc/logrotate.d/named
/etc/named
/etc/named.conf				# 配置文件
/var/log/named.log			# 日志文件
/var/named					# 数据文件的主目录
/var/named/data
/var/named/dynamic
/var/named/named.ca			# 根域服务器
/var/named/named.empty
/var/named/named.localhost	# 正向解析区域文件的模板
/var/named/named.loopback	# 反向解析区域文件的模板
/var/named/slaves			# 从dns服务器下载文件的默认路径
```

### 修改主配置文件

```bash
[root@localhost named]# vim /etc/named.conf
options {
        listen-on port 53 { 127.0.0.1;any; };				# 监听方式 any表示全网监听（需修改）
        listen-on-v6 port 53 { ::1; };						# IPv6的监听方式
        directory       "/var/named";						# DNS的数据文件存放位置
        dump-file       "/var/named/data/cache_dump.db";	# 缓存文件
        statistics-file "/var/named/data/named_stats.txt";	# 统计
        memstatistics-file "/var/named/data/named_mem_stats.txt";	# 内存统计
        secroots-file   "/var/named/data/named.secroots";
        recursing-file  "/var/named/data/named.recursing";
        allow-query     { localhost;any; };					# any 允许全网查询（需修改）

        /*
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable
           recursion.
         - If your recursive DNS server has a public IP address, you MUST enable access
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface
        */
        recursion yes;										# 是否递归

        dnssec-enable no;									# dns安全扩展机制（签名认证）
        dnssec-validation no;								

        managed-keys-directory "/var/named/dynamic";

        pid-file "/run/named/named.pid";
        session-keyfile "/run/named/session.key";

        /* https://fedoraproject.org/wiki/Changes/CryptoPolicy */
        include "/etc/crypto-policies/back-ends/bind.config";
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
        type hint;
        file "named.ca";
};
		
include "/etc/named.rfc1912.zones";							# 包含配置文件
include "/etc/named.root.key";
```

### 修改子配置文件

#### 管理区域文件

```bash
[root@localhost named]# vim /etc/named.rfc1912.zones
zone "misshou.io" IN {				# 定义区域
        type master;				# 定义为主服务器
        file "misshou.io.zone";		# 定义该区域的配置文件
        allow-update { none; };		# 不允许更新
};
```

#### 创建区域配置文件

```bash
[root@localhost named]# cp -p /var/named/named.localhost /var/named/misshou.io.zone		# 必须加上-p选项，文件的所有者和所属组不许更改
[root@localhost named]# ll /var/named/misshou.io.zone
-rw-r-----. 1 root named 152 6月  21 2007 /var/named/misshou.io.zone

[root@localhost named]# vim /var/named/misshou.io.zone
$TTL 1D
@       IN SOA  misshou.io. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns1.misshou.io.
dns1    A       192.168.231.130
www     A       192.168.231.254

```

#### 区域配置文件了解

```bash
$TTL 	缓存的生命周期
1D		1 Day 一天
@ = zonename = misshou.io	当前域名
IN		互联网
SOA		开始授权
NS		dns服务端
A		正向解析
AAAA	ipv6 解析
CNAME	别名
MX		邮件交互记录，数字代表优先级，优先级约低越优先

[root@localhost named]# vim /var/named/misshou.io.zone
$TTL 1D
@       IN SOA  misshou.io. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns1.misshou.io.			# 定义当前DNS服务器的名字
dns1    A       192.168.231.130				# 定义当前DNS服务器的IP地址
www     A       192.168.231.254				# A 记录解析
```

### 检查配置文件

```powershell
[root@localhost named]# named-checkconf /etc/named.conf
[root@localhost named]# named-checkconf /etc/named.rfc1912.zones
```

### 检查区域文件

```bash
[root@localhost named]# cd /var/named/
[root@localhost named]# named-checkzone misshou.io.zone misshou.io.zone			# 区域文件写两遍
zone misshou.io.zone/IN: loaded serial 0
OK
```

### 防火墙放行

```bash
root@localhost ~]# setenforce 0
[root@localhost named]# firewall-cmd --permanent --add-service=dns
success
[root@localhost named]# firewall-cmd --reload
success
[root@localhost named]# systemctl restart named.service
```

## 客户端测试

```bash
[root@samba ~]# nslookup
> www.misshou.io
Server:         192.168.231.130
Address:        192.168.231.130#53

Name:   www.misshou.io
Address: 192.168.231.254
```

## 反向解析

### 修改子配置文件

```
# 主配置文件 /etc/named.conf 按上面实验修改，添加两个 any 就好
# 修改区域管理文件
[root@localhost named]# vim /etc/named.rfc1912.zones
zone "231.168.192.in-addr.arpa" IN {
        type master;
        file "192.168.231.zone";
        allow-update { none; };
};
```

### 修改区域配置文件

```bash
[root@localhost named]# cp -p /var/named/named.loopback /var/named/192.168.231.zone
[root@localhost named]# vim /var/named/192.168.231.zone
$TTL 1D
@       IN SOA  misshou.io. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns1.misshou.io.		# 如果在正向区域文件里存在 dns1.misshou.io，则可以不用写A记录
        A       192.168.231.130
254     PTR     www.misshou.io.			# 参数一：主机地址	参数二：PTR	参数三：PTR映射的完整域名
```

### 客户端测试

```bash
[root@samba ~]# nslookup
> 192.168.231.254
254.231.168.192.in-addr.arpa    name = www.misshou.io.
```

## 总结

DNS涉及的配置文件比较多，这里做一下总结：

1. `/etc/named.conf`：DNS服务的主配置文件（全局配置文件），定义了DNS服务器如何与客户端进行通信

2. `/etc/named.rfc1912.zones`：DNS服务器的区域配置文件（子配置文件），定义了DNS服务器的区域

   ```
   zone "231.168.192.in-addr.arpa" IN {
           type master;
           file "192.168.231.zone";
           allow-update { none; };
   };
   ```

3. `/var/named/192.168.231.zone`：定义了区域文件的详细信息。具体记录在这里写**（文件名必须保证与区域配置文件相同）**

# Web服务器配置

## 服务搭建

### 软件安装

```bash
[root@localhost named]# yum install -y httpd
```

### 了解相关文件

```bash
[root@localhost named]# rpm -ql httpd
/etc/httpd/conf		# 主配置文件目录
/etc/httpd/conf.d/welcome.conf		# 欢迎页
/etc/httpd/logs		# apache 日志文件
```

### 了解配置文件

```bash
ServerRoot "/etc/httpd"			# 服务主目录

Listen 80						# 监听端口

Include conf.modules.d/*.conf	# 包含conf.d下的*.conf文件

User apache						# 以 Apache 用户运行
Group apache					# 以 Apache 用户组运行

ServerAdmin root@localhost


<Directory />					# 系统的根目录授权
    AllowOverride none			# 不支持.htaceess 访问列表。.hataccess 文件提供了针对每个目录改变配置的方法
    Require all denied			
</Directory>


DocumentRoot "/var/www/html"	# 指定Web根目录

<Directory "/var/www">
    AllowOverride None
    Require all granted
</Directory>

<Directory "/var/www/html">		# 授权
    Options Indexes FollowSymLinks	#支持索引 支持软链接
    AllowOverride None		# 不支持 .htaccess 访问列表
    Require all granted		# 允许所有人访问
</Directory>

<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

<Files ".ht*">
    Require all denied
</Files>

ErrorLog "logs/error_log"

LogLevel warn

<IfModule log_config_module>
    LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" co                                                                                                                               mbined
    LogFormat "%h %l %u %t \"%r\" %>s %b" common

    <IfModule logio_module>
      LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %                                                                                                                               I %O" combinedio
    </IfModule>
    CustomLog "logs/access_log" combined
</IfModule>

<IfModule alias_module>
    ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"

</IfModule>

<Directory "/var/www/cgi-bin">
    AllowOverride None
    Options None
    Require all granted
</Directory>

<IfModule mime_module>
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz
    AddType text/html .shtml
    AddOutputFilter INCLUDES .shtml
</IfModule>

AddDefaultCharset UTF-8

<IfModule mime_magic_module>
    MIMEMagicFile conf/magic
</IfModule>


EnableSendfile on

IncludeOptional conf.d/*.conf
```

### 防火墙放行

```bash
[root@localhost named]# setenforce  0
[root@localhost named]# firewall-cmd --permanent --add-service=http
success
[root@localhost named]# firewall-cmd --reload
success
```

## 基于IP的虚拟主机

### 创建网页内容

```bash
[root@localhost conf]# mkdir /var/www/ip1
[root@localhost conf]# mkdir /var/www/ip2
[root@localhost conf]# echo "This is ip1's web" > /var/www/ip1/index.html
[root@localhost conf]# echo "This is ip2's web" > /var/www/ip2/index.html
```

### 编辑`/etc/httpd/conf.d/vhost.conf`配置文件

指定虚拟主机并指定每一个虚拟主机的网站根目录

```bash
<Virtualhost 192.168.231.130>
    DocumentRoot /var/www/ip1
</Virtualhost>


<Virtualhost 192.168.231.140>
    DocumentRoot /var/www/ip2
</Virtualhost>
```

### 编辑`/etc/httpd/conf/httpd.conf`配置文件

由于虚拟主机的网页根目录是在`/var/www/ip{1,2}`，所以可以直接在`/var/www`授权即可

```bash
<Directory "/var/www">
    AllowOverride None		# 不启用 .htaccess 文件
    # Allow open access:
    Require all granted		# 允许所有用户访问受保护内容，无需身份验证
</Directory>
```

## 基于端口的虚拟主机

### 创建文件内容

```bash
[root@localhost conf]# mkdir /var/www/9000
[root@localhost conf]# mkdir /var/www/50001
[root@localhost conf]# echo "This is port:8088's web" > /var/www/8088/index.html
[root@localhost conf]# echo "This is port:8089's web" > /var/www/8089/index.html

```

### 修改`/etc/httpd/conf/httpd.conf`配置文件

+ 监听端口

+ 对相应的文件夹开启权限

  由于两个HTML文件都在`/var/www`下，所以对`/var/www`授权即可

```bash
[root@localhost conf]# vim /etc/httpd/conf/httpd.conf
Listen 80
Listen 9000
Listen 50001

<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>
```

### 编辑`/etc/httpd/conf.d/vhost.conf`配置文件

```bash
[root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf
<Virtualhost 192.168.231.130:9000>
    DocumentRoot /var/www/8088
</Virtualhost>


<Virtualhost 192.168.231.130:50001>
    DocumentRoot /var/www/8089
</Virtualhost>
```

### 防火墙放行

注意：放行端口，HTTP基于TCP协议

```bash
[root@localhost ~]# firewall-cmd --permanent --add-service=http
success
[root@localhost ~]# firewall-cmd --permanent --add-port=9000/tcp
success
[root@localhost ~]# firewall-cmd --permanent --add-port=50001/tcp
success
[root@localhost ~]# firewall-cmd --reload
success
```

## 基于域名的虚拟主机

### 编辑网页内容

```bash
[root@localhost ~]# mkdir /var/www/www1
[root@localhost ~]# mkdir /var/www/www2
[root@localhost ~]# echo "This is domain1's web" > /var/www/www1/index.html
[root@localhost ~]# echo "This is domain2's web" > /var/www/www2/index.html
```

### 修改`/etc/httpd/conf/httpd.conf`配置文件

由于`www1`和`www2`都是`/var/www`的子目录，所以直接对`/var/www`进行授权即可

```bash
[root@localhost ~]# vim /etc/httpd/conf/httpd.conf
<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>
```

### 修改`/etc/httpd/conf.d/vhost.conf`配置文件

```bash
[root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf
<Virtualhost 192.168.231.130>
    DocumentRoot /var/www/www1
    ServerName www1.long60.cn
</Virtualhost>

<Virtualhost 192.168.231.130>
    DocumentRoot /var/www/www2
    ServerName www2.long60.cn
</Virtualhost>
```

### 修改`/etc/hosts`文件

> 在正常的业务环境中，是应该搭配DNS服务器做域名解析一起使用的

```bash
[root@localhost ~]# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
www1.long60.cn          IN              A               192.168.231.130
www2.long60.cn          IN              A               192.168.231.130
```

### 客户端测试

在测试之前需要先编辑hosts文件

```bash
[root@samba ~]# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.231.130 www1.long60.cn
192.168.231.130 www2.long60.cn
```

# iptables防火墙

## iptables防火墙介绍

+ Linux.系统内核集成了网络访问控制的功能，通过netfiltel模块来实现，是内核的一部分（内核空间)
+ 用户层（用户空间）可以通过iptables程序对netfilteri进行控制管理，进而实现网络的访问控制
+ TCP_Wrappers也是一个网络访问控制的一个工具，作用在应用层(7层防火墙)》

总结：

+ netfilter模块	内核空间，是内核一部分
+ iptables组件用户空间，提供管理防火墙的手段，它主要作用在传输层(4层防火墙)

## iptables结构

> iptables 是表的集合 - 表是链的集合 - 链是规则的集合
>
> Iptables 有4张表，分别是：filter、nat、mangle、raw

### filter 表

`filter表`总共有三条链：负责对数据包的过滤

+ INPUT
+ FORWARD
+ OUTPUT

```bash
[root@localhost ~]# iptables -t filter -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             192.168.122.0/24     ctstate RELATED,ESTABLISHED
ACCEPT     all  --  192.168.122.0/24     anywhere
ACCEPT     all  --  anywhere             anywhere
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootpc
```

### NAT表

`NAT表`共有四条链：负责NAT地址转换

+ PREROUTING（路由前）
+ INPUT
+ OUTPUT
+ POSTROUTING（路由后）

```bash
[root@localhost ~]# iptables -t nat -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
RETURN     all  --  192.168.122.0/24     base-address.mcast.net/24
RETURN     all  --  192.168.122.0/24     255.255.255.255
MASQUERADE  tcp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535
MASQUERADE  udp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535
MASQUERADE  all  --  192.168.122.0/24    !192.168.122.0/24

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

### Mangle表

`Mangle表`共有五条链 ：

+ PREROUTING（路由前）
+ INPUT
+ FORWARD
+ OUTPUT
+ POSTROUTING（路由后）

```
[root@localhost ~]# iptables -t mangle -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
CHECKSUM   udp  --  anywhere             anywhere             udp dpt:bootpc CHECKSUM fill

```

### Raw表

`Raw表`共有2条链：

+ PREROUTING（路由前）
+ OUTPUT

```bash
[root@localhost ~]# iptables -t raw -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source  
```

## Iptables 防火墙工作源流（数据包流向）

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230522220447608.png" alt="image-20230522220447608" style="zoom: 80%;" />

### 数据包的过滤

对于数据包的过滤，会去走`filter`表，`filter`表会有三条链：`PREROUTING、FORWARD、POSTROUTING`，数据包的过滤操作会在`FORWORAD`链进行

### NAT表的走向

数据首先从`PREROUTING`进入，再进入`INPUT`，再有系统（localhost）进行地址翻转，之后再从`OUTPUT`转发，最后由`POSTROUTING`输出

## Iptables基本语法

+ `iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作]`

  ​							小写			大写		大写		小写				 大写

说明：

+ 表名和链名：用于指定iptables命令所操作的表和链
+ 命令选项：用于指定管理iptables规则的方式（比如：增加、插入、删除、查看等）
+ 规则号码：用于指定规则的编号
+ 条件匹配：用于指定对符合什么样条件的数据包进行处理（比如：什么协议、出入网卡等）
+ 目标动作：用于指定数据包的处理方式（比如：允许通过、拒绝、丢弃等）

### iptables配置文件

```bash
[root@localhost ~]# cat /etc/sysconfig/iptables-config
```

### iptables 常用的命令选项

````
常见的命令选项：
-L [链名]										查看
-A [链名] 									追加，放置最后一条
-I [链名] [插入位置num]						  插入，默认插入第一条
-D [链名]	[删除位置num]						  删除指定规则
-F [链名]										清空Flush
-p [链名]	[动作]								设置默认策略policy
-R [链名] [插入位置num]						  在指定位置覆盖规则

处理动作：
-j ACCEPT					允许
-j DROP						拒绝，没有提示信息
-j REJECT					拒绝，有提示信息
-j log						写日志	/var/log/message 然后将输出包传递给下一条规则

nat表：
-j SNAT						源地址传唤 POSTROUTING
-j DNAT						目标地址转换 PREROUTING
````

## 实例一：全部允许或拒绝

```bash
iptables -t filter -A INPUT -j DROP			# 添加规则。丢弃所有进来的数据包
iptables -t filter -A INPUT -j ACCEPT		# 添加规则，转发所有进来的数据包	
iptables -t filter -I INPUT 2 -j ACCEPT		# 在指定编号位置插入 ACCEPT 规则
iptables -t filter -D INPUT 2 -j ACCEPT		# 删除指定编号的规则
iptables -t filter -F						# 删除所有规则
iptables -t filter -P INPUT ACCEPT			# 修改指定链的规则
iptables -t filter -R INPUT 2 -j DROP		# 覆盖指定编号的规则
iptables -t filter -L --line-numbers		# 带编号显示规则
```

## 实例二：根据源目地址匹配

```bash
-s 192.168.134.0/24		# 源地址
-d 192.168.134.0/24		# 目标地址
-p tcp|udp|icmp			# 协议
-i eth0					# 从eth0接口进入的数据包
-o eth0					# 从eth0接口出去的数据包
-p tcp --dport 80		# 丢弃基于目标80端口的TCP报文
-p udp --sport 53		# 丢弃基于源53端口的UDP报文
```

```bash
iptables -t filter -A INPUT -s 192.168.231.129 -j DROP			# 拒绝源地址为：192.168.231.129 通过
iptables -t filter -A INPUT -s 192.168.231.0/24 -j DROP			# 拒绝网段为：192.168.231.0/24 通过
iptables -t filter -A OUTPUT -d 192.168.231.1 -j ACCEPT			# 允许目标地址：192.168.231.1 通过
```

## 示例三：根据源目端口

```bash
-p tcp|udp|icmp			# 协议
-p tcp --dport 80		# 丢弃基于目标80端口的TCP报文
-p udp --sport 53		# 丢弃基于源53端口的UDP报文
```

```bash
iptables -t filter -A INPUT -s 192.168.231.129 -p tcp -j DROP		# 拒绝源地址为：192.168.231.129 的主机访问TCP协议的一切服务
iptables -t filter -A INPUT -p tcp --dport 80 -s 192.168.231.129 -j DROP		# 拒绝源地址为：192.168.231.129 的主机访问HTTP服务、

# 只允许我ping别人，不允许别人ping我
iptables -t filter -A INPUT -p icmp --icmp-type 8 -s 192.168.231.130 -j ACCEPT		# 允许源地址为：192.168.231.130 协议为：icmp 并且 icmp 的类型是 8 的报文通过（ICMP type 8 = ICMP request）
iptables -t filter -A INPUT -p icmp --icmp-type 0 -d 192.168.231.130 -j ACCEPT		# 允许目标地址为：192.168.231.130 协议为：icmp 并且 IC名片 的类型是 0 的报文通过（ICMP type 0 = ICMP Response）
iptables -t filter -A INPUT -p icmp -j DROP											# 拒绝所有ICMP报文通过
```

## 综合练习

1. 禁用另一台服务器访问80端口

2. 允许其他人访问80端口
2. 只允许你ping通别人，不允许别人ping你

4. 拒绝所有人访问sshd服务

```bash
# 第一题
iptables -t filter -A INPUT -p tcp --drpot 80 -s 192.168.231.129 -j DROP
# 第二题不需要做任何操作，默认全通过
# 第三题
iptables -t filter -A INPUT -p icmp --icmp-type 8 -s 192.168.231.130 -j ACCEPT
iptables -t filter -A INPUT -p icmp --icmp-type 0 -d 192.168.231.130 -j ACCEPT
iptables -t filter -A INPUT -p icmp -j DROP
# 第四题
iptables -t filter -A INPUT -p tcp --dport 22 -j DROP

[root@localhost ~]# iptables -t filter -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  192.168.231.129      anywhere             tcp dpt:http
ACCEPT     icmp --  localhost.localdomain  anywhere             icmp echo-request
ACCEPT     icmp --  anywhere             localhost.localdomain  icmp echo-reply
DROP       icmp --  anywhere             anywhere            
DROP       tcp  --  anywhere             anywhere             tcp dpt:ssh

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination  
```

## iptables 内置模块（扩展）

### multiport 模块

```bash
-m 参数 + <模块名>
1. multiport	多端口	目的：指定多个不连续端口，减少IP tables的条目，达到优化效果（iptables的条目越小，速度自然也越快）
用法：
iptables -m multiport --help
-m multiport
	--dports port[,port:port,port...]
	--sports port[,port:port,port...]
	
iptables -t filter -A INPUT -p tcp --dport 20 -j ACCEPT
iptables -t filter -A INPUT -p tcp --dport 21 -j ACCEPT
等于
iptables -t filter -A INPUT -m multiport -p tcp --dports 20,21 -j ACCEPT
或
iptables -t filter -A INPUT -m multiport -p tcp --dports 20:21 -j ACCEPT
```

### iprange 模块

```bash
iprange ip范围
用法：
iptable -m iprange --help
-m iprange
	--src-range ip[-ip]
	--dst-range ip[-ip]

# 允许 192.168.231.10 - 192.168.231.100 地址段访问服务器的TCP访问
iptables -t filter -A INPUT -m iprange -p tcp --src-range 192.168.231.10-192.168.231.100 -j ACCEPT
```

# Iptables 防火墙 - NAT表

## NAT 简介

NAT，地址翻转协议。由于如今互联网的IPv4地址严重不足，无法满足上网需求，所以研制出了NAT协议。企业通过购买1-2个公网IP，内网使用私有IP做网络划分，最后在出口路由器做NAT地址翻转，已达到内网N个用户只使用1-2个IP地址上网的目的（节省IP地址）

NAT 分为两种类型：

+ 源NAT：通过翻转数据包中的源地址，以达到成功通信的目的。通常用于：内网 --> 外网，访问互联网
+ 目NAT：通过翻转数据包中的目的IP地址，以达到成功通信的目的。通常用于：外网 --> 内网，用户可以从外网访问内网的服务器。企业也可以保证内网服务器的IP划分不被泄露

## SNAT 实战

### 实验环境：

NAT Server：192.168.231.130 | 192.168.80.254

NAT Client：192.168.80.129

Target Server：192.168.231.1

要求：NAT Client 通过 NAT Server 的地址翻转，成功 ping 通 target Server

### 开启路由转发功能

1 代表开启，如果为 0 则执行第二条命令

```bash
[root@localhost ~]# cat /proc/sys/net/ipv4/ip_forward
1
```

```bash
[root@localhost ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
```

### 做SNAT地址翻转

```bash
[root@localhost ~]# iptables -t nat -A POSTROUTING -s 192.168.80.129 -j SNAT --to 192.168.231.130
```

## DNAT 实战

### 实验环境

NAT Server：192.168.231.130 | 192.168.80.254

NAT Client：192.168.231.1

Target Server：192.168.80.129

### 开启路由转发功能

1 代表开启，如果为 0 则执行第二条命令

```bash
[root@localhost ~]# cat /proc/sys/net/ipv4/ip_forward
1
```

```bash
[root@localhost ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
```

### 做DNAT地址翻转

```bash
[root@localhost ~]# iptables -t nat -A PREROUTING -d 192.168.231.130 -j DNAT --to 192.168.80.129
```

## 总结

+ 对于SNAT，需要在POSTROUTING链上做翻转，原因是：需要保证目标地址可达之后源IP地址才应该允许被翻转
+ 对于DNAT，需要在PREROUTING链上做翻转，原因是：需要在路由前保证翻转后d

+ 不管是SNAT或者是DNAT，都需要在已有的IP地址上做翻转，绝对不能使用没有的IP地址！

# Linux CA证书服务原理与搭建

## HTTPS 的通信原理-简化

1. Client 获得 Server 的证书
2. Client 验证 Server 的证书的有效性（通过 CA 的公钥）
3. 证书有效，Client 生成一串随机字符串
4. Client 使用 Server 的公钥对这串字符串进行加密并发给 Server
5. Server 使用私钥对信息进行解密，得到这串随机字符串
6. 后续通信，Client 和 Server 使用这串随机字符串对做对称加密进行通信以保证数据的安全

## opensll

### openssl命令对称加密

工具：openssl enc

加密：

+ 使用 openssl enc 工具
+ `-e`：加密
+ `-des3`：使用`des3`算法
+ `-a`：对密文使用`BASE64`编码输出，保证密文不会出现乱码
+ `-salt`：对密文做加盐处理，保证哈希算法不被爆破
+ `-in`：指定使用哪个文件进行加密
+ `-out`：输出到哪个具体文件

```bash
openssl enc -e -des3 -a -salt -in passwd_simple -out passwd_sce
```

解密：

+ 使用 openssl enc 工具
+ `-d`：解密
+ `-des3`：使用`des3`算法
+ `-a`：对密文使用`BASE64`编码输出，保证密文不会出现乱码
+ `-salt`：对密文做加盐处理，保证哈希算法不被爆破
+ `-in`：指定使用哪个文件进行加密
+ `-out`：输出到哪个具体文件

```bash
openssl enc -d -des3 -a -salt -in passwd_sce -out soso
```

### openssl命令做哈希算法

工具：opensll dsgt

命令格式：openssl <哈希算法> 哈希文件

```bash
[root@localhost data]# openssl md5 passwd_simple
MD5(passwd_simple)= f447b20a7fcbf53a5d5be013ea0b15af
```

### openssl 生成用户密码

```bash
[root@localhost data]# openssl passwd --help
Usage: passwd [options]
Valid options are:
 -help               Display this summary
 -in infile          Read passwords from file
 -noverify           Never verify when reading password from terminal
 -quiet              No warnings
 -table              Format output as table
 -reverse            Switch table columns
 -salt val           Use provided salt
 -stdin              Read passwords from stdin
 -6                  SHA512-based password algorithm
 -5                  SHA256-based password algorithm
 -apr1               MD5-based password algorithm, Apache variant
 -1                  MD5-based password algorithm
 -aixmd5             AIX MD5-based password algorithm
 -crypt              Standard Unix password algorithm (default)
 -rand val           Load the file(s) into the random number generator
 -writerand outfile  Write random data to the specified file
```

示例：

`-6`：使用`SHA512`算法

`-salt`：指定盐值

```bash
[root@localhost data]# openssl passwd -6 -salt TmwDSId5COmUu.7T
Password:
$6$TmwDSId5COmUu.7T$CKychemhqx4EViz8/9EbOGfG.Z0M8BRO2JR/K.UJh3S088SCbQP.G/KdX3JLj5l.H2APGLo/zKhLx77Z5nxUC/
```

### opensll生成随机数

随机数生成器：仅随机数字，利用键盘和鼠标，块设备中断生成随机数

`/dev/random`：进从熵池返回随机数；随机数用尽，阻塞

`/dev/urandom`：从熵池返回随机数；随机数用尽，会利用软件生成伪随机数，非阻塞

```bash
[root@localhost data]# openssl rand --help
Usage: rand [flags] num
Valid options are:
 -help               Display this summary
 -out outfile        Output file
 -rand val           Load the file(s) into the random number generator
 -writerand outfile  Write random data to the specified file
 -base64             Base64 encode output
 -hex                Hex encode output
 -engine val         Use engine, possibly a hardware device
 
 # 生成9个字节的随机数，并且使用BASE64编码输出
 [root@localhost data]# openssl rand -base64 9
fOVYMkLx0zay
```

### openssl PKI密钥实现

生成私钥：

```bash
[root@localhost data]# openssl genrsa -out /app.key		# 使用rsa算法生成私钥
```

在私钥中提取公钥

`opensll rsa`：指定为rsa算法

`-in`：导入私钥

`-out`：导入公钥

`-pubout:`提取公钥

```bash
[root@localhost data]# openssl rsa -in /app.key -pubout -out /public.key
```

## 建立私有CA实现证书申请颁发

证书申请及签署步骤：

1. 生成证书申请请求
2. RA核验
3. CA签署
4. 获取证书

### 配置文件：

`/etc/pki/tls/openssl`.conf

### 了解配置文件：

**`$dir` = [CA_default] 下的 dir项 **

`dir = /etc/pki/CA`

```bash
####################################################################
[ ca ]
default_ca      = CA_default            # The default ca section		

####################################################################
[ CA_default ]

dir             = /etc/pki/CA           # Where everything is kept			# CA的工作路径，存放CA的所有配置文件
certs           = $dir/certs            # Where the issued certs are kept	# 所有已颁发证书的存放位置
crl_dir         = $dir/crl              # Where the issued crl are kept
database        = $dir/index.txt        # database index file.				# 数据库索引文件
#unique_subject = no                    # Set to 'no' to allow creation of
                                        # several certs with same subject.
new_certs_dir   = $dir/newcerts         # default place for new certs.		# 新颁发的证书的存放位置

certificate     = $dir/cacert.pem       # The CA certificate				# 根CA颁发的证书
serial          = $dir/serial           # The current serial number
crlnumber       = $dir/crlnumber        # the current crl number			# 被吊销的证书编号的存放位置
                                        # must be commented out to leave a V1 CRL
crl             = $dir/crl.pem          # The current CRL					# 存放所有被吊销的证书列表
private_key     = $dir/private/ cakey.pem# The private key					# 存放私钥
RANDFILE        = $dir/private/.rand    # private random number file		# 存放随机值

x509_extensions = usr_cert              # The extensions to add to the cert

# Comment out the following two lines for the "traditional"
# (and highly broken) format.
name_opt        = ca_default            # Subject Name options
cert_opt        = ca_default            # Certificate field options

# Extension copying option: use with caution.
# copy_extensions = copy

# Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs
# so this is commented out by default to leave a V1 CRL.
# crlnumber must also be commented out to leave a V1 CRL.
# crl_extensions        = crl_ext

default_days    = 365                   # how long to certify for			# 颁发证书的默认有效期
default_crl_days= 30                    # how long before next CRL			
default_md      = sha256                # use SHA-256 by default
preserve        = no                    # keep passed DN ordering

# A few difference way of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy          = policy_match												# 指定使用什么策略

# For the CA policy															
# match 表示必须匹配
# optional 可以不匹配
[ policy_match ]															# 客户端所填写的资料与策略进行对比
countryName             = match												
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied											# 域名，必填
emailAddress            = optional

# For the 'anything' policy
# At this point in time, you must list all acceptable 'object'
# types.
[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
```

### 创建私有CA

#### 1、创建所需要的目录

```bash
[root@localhost pki]# mkdir -pv /etc/pki/CA/{certs,crl,newcerts,private}
mkdir: 已创建目录 '/etc/pki/CA'
mkdir: 已创建目录 '/etc/pki/CA/certs'
mkdir: 已创建目录 '/etc/pki/CA/crl'
mkdir: 已创建目录 '/etc/pki/CA/newcerts'
mkdir: 已创建目录 '/etc/pki/CA/private'
```

#### 2、创建CA所需要的文件

```
# 生成证书索引数据库文件
touch /etc/pki/CA/index.txt
touch /etc/pki/CA/index.txt.attr

# 指定第一个颁发证书的序列号
echo 01 > /etc/pki/CA/serial
```

#### 3、生成CA私钥

在配置文件中，`$dir/private/cakey.pem` 指定了私钥文件的存放路径为：private/cakey.pem

`umask 066`：指定CA的私钥文件的文件权限为600

`-out`：输出私钥的文件路径

`2048`：指定私钥长度

```bash
[root@localhost CA]# openssl genrsa -out private/cakey.pem 2048
Generating RSA private key, 2048 bit long modulus (2 primes)
....+++++
............................................................................................+++++
e is 65537 (0x010001)
```

#### 4、为CA创建自签名证书

选项说明：

```
-new：生成新证书签署请求
-x509：专用于CA生成自签证书
-key：生成请求时用到的私钥文件
-days n：证书的有效期限
-put /PATH/TO/SOMECERTFILE：证书的保存路径
```



```bash
[root@localhost CA]# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 365 -out /etc/pki/CA/cacert.pem
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:guangdong
Locality Name (eg, city) [Default City]:shenzhen
Organization Name (eg, company) [Default Company Ltd]:sziit
Organizational Unit Name (eg, section) []:sziit
Common Name (eg, your name or your server's hostname) []:ca.sziit.org
Email Address []:123456789@qq.com

[root@localhost CA]# tree /etc/pki/CA
/etc/pki/CA
├── cacert.pem
├── certs
├── crl
├── newcerts
└── private
    └── cakey.pem

4 directories, 2 files

# 查看证书
[root@localhost CA]# openssl x509 -in /etc/pki/CA/cacert.pem -noout -text
```

### 客户端申请并颁发证书

#### 1、客户端生成私钥文件

```bash
[root@samba app1]# (umask 066; openssl genrsa -out app1.key 2048)
Generating RSA private key, 2048 bit long modulus (2 primes)
...+++++
...............................+++++
e is 65537 (0x010001)
```

#### 2、客户端生成证书申请

选项说明：

```bash
req：生成一个证书请求
-new：生成一个新的证书请求
-key：指定私钥
-out：证书请求文件的输出路径
```

```bash
[root@samba app1]# openssl req -new -key app1.key -out app1.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:guangdong
Locality Name (eg, city) [Default City]:shenzhen
Organization Name (eg, company) [Default Company Ltd]:sziit
Organizational Unit Name (eg, section) []:sziit
Common Name (eg, your name or your server's hostname) []:ca.sziit.org
Email Address []:123456789@qq.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:	
An optional company name []:
```

#### 3、CA颁发证书文件

```powershell
[root@localhost app1]# openssl ca -in /data/app1/app1.csr -out /etc/pki/CA/certs/app1.crt -days 1000
Using configuration from /etc/pki/tls/openssl.cnf
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number: 1 (0x1)
        Validity
            Not Before: May 24 04:43:00 2023 GMT
            Not After : Feb 17 04:43:00 2026 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = guangdong
            organizationName          = sziit
            organizationalUnitName    = sziit
            commonName                = ca.sziit.org
            emailAddress              = 123456789@qq.com
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            Netscape Comment:
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier:
                95:96:66:EC:14:56:9A:F8:D1:43:FC:96:F2:D7:B8:ED:69:27:FF:03
            X509v3 Authority Key Identifier:
                keyid:A6:43:FE:E8:45:4C:38:00:14:FE:F2:83:64:2B:E7:5E:97:90:2F:9F

Certificate is to be certified until Feb 17 04:43:00 2026 GMT (1000 days)
Sign the certificate? [y/n]:y
```

#### 4、查看证书

查看证书的有效信息：

```bash
[root@localhost app1]# openssl x509 -in /etc/pki/CA/certs/app1.crt -noout -issuer
issuer=C = CN, ST = guangdong, L = shenzhen, O = sziit, OU = sziit, CN = ca.sziit.org, emailAddress = 123456789@qq.com

[root@localhost client]# tree
.
├── app.crt
├── app.csr
└── app.key

0 directories, 3 files

```

验证证书有效性：

```bash
[root@localhost app1]# openssl ca -status 01
Using configuration from /etc/pki/tls/openssl.cnf
01=Valid (V)
```

#### 5、导出证书传给用户

```bash
[root@localhost app1]# cp /etc/pki/CA/certs/app1.crt /data/app1/
```

## 吊销证书

#### 查看证书编号

```bash
[root@localhost client]# cat /etc/pki/CA/index.txt
V       260309140058Z           01      unknown /C=CN/ST=guangdong/O=sziit/OU=sziit/CN=www.sziit.edu
```

#### 吊销证书

根据编号吊销

```bash
[root@localhost client]# openssl ca -revoke /etc/pki/CA/newcerts/01.pem
Using configuration from /etc/pki/tls/openssl.cnf
Revoking Certificate 01.
Data Base Updated
```

### 总结：

+ 服务器：
  + 初始化CA配置
  + 生成私钥
  + 用私钥生成自签名证书

+ 客户端：
  + 生成私钥
  + 用私钥生成证书申请
  + 使用证书申请向服务器生成证书

# cfssl使用

## cfssl 安装

```bash
VERSION=$(curl --silent "https://api.github.com/repos/cloudflare/cfssl/releases/latest" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
VNUMBER=${VERSION#"v"}
wget https://github.com/cloudflare/cfssl/releases/download/${VERSION}/cfssl_${VNUMBER}_linux_amd64 -O cfssl
chmod +x cfssl
sudo mv cfssl /usr/local/bin
```

## cfssljson 安装

```bash
 # 下载源代码
 wget https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssljson_1.6.1_linux_amd64
 # 添加执行权限
chmod +x cfssljson_1.6.1_linux_amd64
# 修改名字
mv cfssljson_1.6.1_linux_amd64 cfssljson
# 添加到环境变量
 mv cfssljson_1.6.1_linux_amd64 /usr/local/bin/
```

## 查看CA配置的默认选项

```bash
[root@localhost cfssl]# cat config.json
{
    "signing": {
        "default": {
            "expiry": "168h"
        },
        "profiles": {
            "www": {
                "expiry": "8760h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth"
                ]
            },
            "client": {
                "expiry": "8760h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "client auth"
                ]
            }
        }
    }
}
```

## 查看CA证书请求文件

```bash
[root@localhost cfssl]# cfssl print-defaults csr
{
    "CN": "example.net",
    "hosts": [
        "example.net",
        "www.example.net"
    ],
    "key": {
        "algo": "ecdsa",
        "size": 256
    },
    "names": [
        {
            "C": "US",
            "ST": "CA",
            "L": "San Francisco"
        }
    ]
}
```

## 修改证书请求文件

```bash
[root@localhost cfssl]# cp csr.json ca-csr.json
[root@localhost cfssl]# vim ca-csr.json
{
    "CN": "server",
    "key": {
        "algo": "rsa",		# 指定加密算法
        "size": 2048		# 指定密钥长度
    },
    "names": [
        {
            "C": "CN",			# 指定国家
            "ST": "GunagDong",	# 指定省份
            "L": "ShenZhen"		# 指定城市
        }
    ]
}
```

## 生成CA的证书和私钥（自签名证书）

```bash
[root@localhost cfssl]# cfssl gencert -initca ca-csr.json | cfssljson -bare ca
2023/05/24 02:52:05 [INFO] generating a new CA key and certificate from CSR
2023/05/24 02:52:05 [INFO] generate received request
2023/05/24 02:52:05 [INFO] received CSR
2023/05/24 02:52:05 [INFO] generating key: rsa-2048
2023/05/24 02:52:05 [INFO] encoded CSR
2023/05/24 02:52:05 [INFO] signed certificate with serial number 435324584926603866224607034223788757067404112011
[root@localhost cfssl]# ls
ca.csr  ca-csr.json  ca-key.pem  ca.pem  config.json  csr.json

知识点：ca-kay.pem（私钥） ca.pem（公钥）
```

## 用户生成证书请求文件

```bash
[root@localhost cfssl]# cp ca-csr.json server-csr.json
[root@localhost cfssl]# vim server-csr.json
{
    "CN": "www",
    "hosts":[
        "127.0.0.1",
        "192.168.231.130",
        "*.example.com",
        "localhost"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "GunagDong",
            "L": "ShenZhen",
            "O": "sziit",
            "OU": "sziit"
        }
    ]
}
```

## 通过`server-csr.json`生成一个新的证书请求和新的密钥

```bash
[root@localhost ca_client]# cfssl genkey server-csr.json | cfssljson -bare server
2023/05/24 03:04:57 [INFO] generate received request
2023/05/24 03:04:57 [INFO] received CSR
2023/05/24 03:04:57 [INFO] generating key: rsa-2048
2023/05/24 03:04:57 [INFO] encoded CSR
[root@localhost ca_client]# ls
server.csr  server-csr.json  server-key.pem
```

## CA向服务器颁发证书

通过服务器的证书请求文件`server.csr`来申请

```
[root@localhost cfssl]# cfssl sign -ca /cfssl/ca.pem -ca-key ca-key.pem /ca_client/server.csr | cfssljson -bare ca-signed-server
2023/05/24 03:14:11 [INFO] signed certificate with serial number 718581241199119637765630909677547559055267326454
```

## 总结

```
CA（证书颁发机构）是负责颁发和管理数字证书的实体。数字证书是一种用于验证实体身份和建立安全通信的电子文档。

CSR（证书签名请求）：是一种包含公钥和其他标识信息的消息，用于申请数字证书。CSR 通常由申请数字证书的实体生成，并提交给 CA 进行签名。

PEM（隐私增强邮件）：是一种用于存储加密密钥、证书和其他加密材料的文件格式。PEM 文件通常以 .pem 扩展名结尾，并使用 Base64 编码将二进制数据转换为 ASCII 文本。

除此之外，还有许多与 CA 和数字证书相关的术语，例如：

CRT（证书）：是一种包含公钥和实体标识信息的文件，用于验证实体身份和建立安全通信。

CRL（证书撤销列表）：是一种包含已撤销数字证书列表的文件，用于验证数字证书是否有效。

OCSP（在线证书状态协议）：是一种用于检查数字证书状态的协议，可以快速确定数字证书是否已被撤销。
```

# SELinux

## SELinux概述

SElinux 主要作用就是最小限度地减小系统中服务进程可访问的资源（最小权限原则）

## SELinux 工作原理和工作模式

### DAC（自主访问控制）& MAC（强制访问控制）

DAC：自主访问控制，权限管理机制的主题是用户；使用权限来判断资源是否可被对应的用户访问（读、写、执行）

MAC：再使用了SELinux的操作系统中，决定一个资源是否被访问处理上述因素外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这种权限管理机制的主体是进程，也称为前置访问控制（MAC）

二者区别：

1. DAC的主体是真实有效的用户和组ID，MAC主体是安全上下文，两者的UID是各自独立的
2. DAC的访问控制模式是rwxrwxrwx，MAC的访问控制模式是user:role:type

### SELinux  基本架构

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524180326658.png" alt="image-20230524180326658" style="zoom: 67%;" />

当一个进程在运行并需要访问所需的资源时，会进行如下操作：

1. 查找资源是否存在
2. 检查DAC是否允许访问
3. 检查 LSM hook（SELinux）是否允许访问

### SELinux 三种工作模式

1. enforceing：强制模式。违反SELinux规则的行为将被阻止并记录到日志中
2. permissive：宽容模式：违反S。ELinux规则的行为将会被允许。并记录到日志中
3. disabled：关闭SELinux

```bash
[root@localhost selinux]# vim /etc/selinux/config
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of these three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted
```

### SELinux 状态管理：修改工作模式

设置SELinux模式及开关使用命令有3个：

+ getenforce	# 获取SELinux的当前状态

  ```bash
  [root@localhost selinux]# getenforce
  Enforcing
  ```

+ sestatus # 查看SELinux完整状态

  ```bash
  [root@localhost selinux]# sestatus
  SELinux status:                 enabled
  SELinuxfs mount:                /sys/fs/selinux
  SELinux root directory:         /etc/selinux
  Loaded policy name:             targeted
  Current mode:                   enforcing
  Mode from config file:          enforcing
  Policy MLS status:              enabled
  Policy deny_unknown status:     allowed
  Memory protection checking:     actual (secure)
  Max kernel policy version:      31
  ```

+ setenforce[Enforcing|Permissive 0|1]

  ```bash
  [root@localhost selinux]# setenforce  1
  ```

  

+ 通过修改`/etc/selinux/config`做到永久设置

  ```
  [root@localhost selinux]# vim /etc/selinux/config
  # This file controls the state of SELinux on the system.
  # SELINUX= can take one of these three values:
  #     enforcing - SELinux security policy is enforced.
  #     permissive - SELinux prints warnings instead of enforcing.
  #     disabled - No SELinux policy is loaded.
  SELINUX=enforcing
  # SELINUXTYPE= can take one of these three values:
  #     targeted - Targeted processes are protected,
  #     minimum - Modification of targeted policy. Only selected processes are protected.
  #     mls - Multi Level Security protection.
  SELINUXTYPE=targeted
  ```

  

## SELinux 的安全上下文介绍

SELinux中“一切都得有一个标签”

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524202705538.png" alt="image-20230524202705538" style="zoom: 50%;" />

## SELinux 用户管理

### SELinux用户管理概述

> 本地用户会映射SELinux用户

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524211613883.png" alt="image-20230524211613883" style="zoom: 67%;" />

+ 查看Linux中的用户

  ```bash
  [root@localhost selinux]# cat /etc/passwd
  root:x:0:0:root:/root:/bin/bash
  bin:x:1:1:bin:/bin:/sbin/nologin
  daemon:x:2:2:daemon:/sbin:/sbin/nologin
  adm:x:3:4:adm:/var/adm:/sbin/nologin
  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
  sync:x:5:0:sync:/sbin:/bin/sync
  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
  halt:x:7:0:halt:/sbin:/sbin/halt
  mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
  operator:x:11:0:operator:/root:/sbin/nologin
  games:x:12:100:games:/usr/games:/sbin/nologin
  ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
  nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin
  dbus:x:81:81:System message bus:/:/sbin/nologin
  systemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin
  systemd-resolve:x:193:193:systemd Resolver:/:/sbin/nologin
  tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin
  polkitd:x:998:996:User for polkitd:/:/sbin/nologin
  geoclue:x:997:995:User for geoclue:/var/lib/geoclue:/sbin/nologin
  rtkit:x:172:172:RealtimeKit:/proc:/sbin/nologin
  pulse:x:171:171:PulseAudio System Daemon:/var/run/pulse:/sbin/nologin
  qemu:x:107:107:qemu user:/:/sbin/nologin
  usbmuxd:x:113:113:usbmuxd user:/:/sbin/nologin
  unbound:x:996:991:Unbound DNS resolver:/etc/unbound:/sbin/nologin
  rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
  gluster:x:995:990:GlusterFS daemons:/run/gluster:/sbin/nologin
  chrony:x:994:989::/var/lib/chrony:/sbin/nologin
  libstoragemgmt:x:993:987:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin
  pipewire:x:992:986:PipeWire System Daemon:/var/run/pipewire:/sbin/nologin
  setroubleshoot:x:991:985::/var/lib/setroubleshoot:/sbin/nologin
  saslauth:x:990:76:Saslauthd user:/run/saslauthd:/sbin/nologin
  dnsmasq:x:984:984:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin
  radvd:x:75:75:radvd user:/:/sbin/nologin
  clevis:x:983:982:Clevis Decryption Framework unprivileged user:/var/cache/clevis:/sbin/nologin
  cockpit-ws:x:982:980:User for cockpit-ws:/:/sbin/nologin
  sssd:x:981:979:User for sssd:/:/sbin/nologin
  colord:x:980:978:User for colord:/var/lib/colord:/sbin/nologin
  gdm:x:42:42::/var/lib/gdm:/sbin/nologin
  rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
  gnome-initial-setup:x:979:977::/run/gnome-initial-setup/:/sbin/nologin
  sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
  insights:x:978:976:Red Hat Insights:/var/lib/insights:/sbin/nologin
  avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
  tcpdump:x:72:72::/:/sbin/nologin
  admin:x:1000:1000:admin:/home/admin:/bin/bash
  apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin
  share:x:1001:1001::/home/share:/bin/bash
  ```

+ 查看SELinux的账户

  ```bash
  [root@localhost selinux]# semanage user -l
  
                  标记中        MLS/       MLS/
  SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色
  
  guest_u         user       s0         s0                             guest_r
  root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
  staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
  sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
  system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
  unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
  user_u          user       s0         s0                             user_r
  xguest_u        user       s0         s0                             xguest_r
  ```

+ 查看两者的映射关系；只会看到已登录的用户

  ```bash
  [root@localhost selinux]# semanage login -l
  
  登录名                  SELinux 用户           MLS/MCS 范围           服务
  
  __default__          unconfined_u         s0-s0:c0.c1023       *
  root                 unconfined_u         s0-s0:c0.c1023       *
  ```

  

### SELinux用户管理

![image-20230524212609097](%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524212609097.png)

#### 添加映射关系

`-a`：添加映射关系

`-s`：指定映射的SELinux user用户

```bash
# 将share用户的SELinux用户映射为staff_u
[root@localhost ~]# semanage login -a -s staff_u share
```

#### 修改映射关系

`-m`：修改映射关系

`-s`：指定映射的SELinux user用户

```bash
# 将share的SELinux用户的映射关系修改为：sysadm_u
[root@localhost ~]# semanage login -m -s sysadm_u share
```

#### 删除映射关系

`-d`：删除映射关系

```bash
[root@localhost ~]# semanage login -d share
```

#### 添加自定义SELinux用户

`-a`：添加新用户

`-R`：指定角色身份

```bash
[root@localhost ~]# semanage user -a -R staff_r new_user
[root@localhost ~]# semanage user -l

                标记中        MLS/       MLS/
SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色

guest_u         user       s0         s0                             guest_r
new_user        user       s0         s0                             staff_r		# 新添加的用户
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
```

#### 修改自定义SELinux用户

```bash
[root@localhost ~]# semanage user -m -R "guest_r" new_user
[root@localhost ~]# semanage user -l

                标记中        MLS/       MLS/
SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色

guest_u         user       s0         s0                             guest_r
new_user        user       s0         s0                             guest_r		# 被修改用户
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
```

#### 删除自定义SELinux用户

```bash
[root@localhost ~]# semanage user -d  new_user
[root@localhost ~]# semanage user -l

                标记中        MLS/       MLS/
SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色

guest_u         user       s0         s0                             guest_r
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
```

## SELinux的布尔值操作

### `getsebool`查看相应服务的布尔值

```bash
[root@localhost ~]# getsebool samba_share_nfs
samba_share_nfs --> off
```

### `setsebool`设置相应服务的布尔值

```bash
[root@localhost ~]# setsebool samba_share_nfs on
```

### semange修改布尔值

```bash
[root@localhost ~]# semanage boolean -m user_exec_content -1
[root@localhost ~]# getsebool user_exec_content
user_exec_content --> on
```

## SELinux的文件上下文

```bash
[root@localhost data]# ls -Z
unconfined_u:object_r:default_t:s0 app1
SELinux 用户 SELinux 角色  上下文	
```

每一个文件都会有其相对应的上下文，每个进程主体通过判断其上下文来识别出是否是其管理的文件，并判断是否给予运行

+ 创建新文件：会继承父目录的上下文
+ 复制文件：会继承父目录的上下文
+ 移动文件：会保留原有的上下文

### SELinux 文件上下文

#### chcon用法解释

```
chcon [选项]... 环境 文件... 
chcon [选项]... [-u 用户] [-r 角色] [-l 范围] [-t 类型] 文件... 
chcon [选项]... --reference=参考文件 文件...

-h, --no-dereference：影响符号连接而非引用的文件。
 --reference=参考文件：使用指定参考文件的安全环境，而非指定值。 
-R, --recursive：递归处理所有的文件及子目录。 
-v, --verbose：为处理的所有文件显示诊断信息。 
-u, --user=用户：设置指定用户的目标安全环境。
-r, --role=角色：设置指定角色的目标安全环境。
-t, --type=类型：设置指定类型的目标安全环境。 
-l, --range=范围：设置指定范围的目标安全环境。
```



```bash
unconfined_u:object_r:default_t:s0 app1  unconfined_u:object_r:default_t:s0 app2
[root@localhost data]# chcon -v -t default_t /data/app1
正在更改'/data/app1' 的安全环境
```

通过参考第一个文件来修改上下文

```bash
[root@localhost data]# chcon --reference /data/app1 /data/app2
```

恢复上下文

```bash
[root@localhost data]# restorecon -F /data/app1/
```

## SELinux进程上下文

### 查看HTTP进程上下文

```bash
[root@localhost data]# ps -eZ|grep httpd
system_u:system_r:httpd_t:s0     10774 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10775 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10776 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10777 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10778 ?        00:00:00 httpd
```

### 查看HTTP文件上下文

```bash
[root@localhost data]# ls -Z /var/www/
unconfined_u:object_r:httpd_sys_content_t:s0 8088         system_u:object_r:httpd_sys_content_t:s0 html
unconfined_u:object_r:httpd_sys_content_t:s0 8089     unconfined_u:object_r:httpd_sys_content_t:s0 www1
system_u:object_r:httpd_sys_script_exec_t:s0 cgi-bin  unconfined_u:object_r:httpd_sys_content_t:s0 www2
```

### SELinux 端口上下文

#### 1、修改HTTP服务监听端口

```bash
[root@localhost ~]# vim /etc/httpd/conf/httpd.conf
Listen 12345
```

#### 2、重启服务-重启失败

```bash
[root@localhost ~]# systemctl restart httpd.service
Job for httpd.service failed because the control process exited with error code.
See "systemctl status httpd.service" and "journalctl -xe" for details.
```

#### 3、查看SELinux HTTP 相关端口

可以看到由于`http_port_t `并没有运行对端口12345进行监听，导致服务启动失败

```bash
[root@localhost ~]# semanage port -l |grep http
http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010
http_cache_port_t              udp      3130
http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t            tcp      5988
pegasus_https_port_t           tcp      5989
```

#### 4、添加端口

`-a`：添加端口

`-t`：指定类型

`-p`：指定端口

```bash
[root@localhost ~]# semanage port -a -t http_port_t -p tcp 12345
[root@localhost ~]# semanage port -l |grep http
http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010
http_cache_port_t              udp      3130
http_port_t                    tcp      12345, 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t            tcp      5988
pegasus_https_port_t           tcp      5989

# 重启成功
[root@localhost ~]# systemctl restart httpd.service
```

#### 删除规则

```bash
[root@localhost ~]# semanage port -d -t http_port_t -p tcp 12345
```

# 文本处理三剑客

## 通配符

```
* - 代表所有
? - 通配符，代表任意1个字符
; - 连续不同命令的分隔符
# - 配置文件注释
| - 管道符
~ - 当前用户的家目录
- - 上次的目录或者路径
$ - 变量前需要加的符号
	[root@localhost log]# echo $USER
	root

/ - 路径分割符号
> - 重定向
>> - 追加
< - 输入重定向
<< - 追加输入重定向
` - 单引号，不具备变量置换的功能，不解析函数，所见即所得
	[root@localhost log]# echo 'data'
	data
“ - 双引号，具有变量置换功能，解析函数
	[root@localhost log]# echo "`ls`"
    10:00:00
    error.log
    error-ssl.log
反引号 - 解析命令
    [root@localhost log]# echo `ls`
    10:00:00 error.log error-ssl.log
{} - 内容序列
	[root@localhost log]# echo data{1,2,3}
	data1 data2 data3
! - 取反
&& - and
|| - or
.. - 上一级目录
. - 当前目录
```

## 正则表达式

```
^word	匹配以word开头的内容
[root@localhost log]# grep "^root" /etc/passwd
root:x:0:0:root:/root:/bin/bash

word$	匹配以word结尾的内容
[root@localhost log]# grep "bash$" /etc/passwd
root:x:0:0:root:/root:/bin/bash
admin:x:1000:1000:admin:/home/admin:/bin/bash

^$		表示空
.		代表且只能代表一个字符
\		转义符号。例\.代表.本身
*		匹配0个或多个
.*		匹配所有字符

[abc]	匹配字符abc任意一个[a-z|0-9]
[^abc]	排除匹配字符abc任意一个

a\{n,m\}	匹配a字符n-m次
[root@localhost log]# grep "0\{3\}" /etc/passwd
admin:x:1000:1000:admin:/home/admin:/bin/bash

a\{n}		匹配a字符n次
[root@localhost log]# grep "0\{1\}" /etc/passwd
root:x:0:0:root:/root:/bin/bash
sync:x:5:0:sync:/sbin:/bin/sync

a\{n,}		匹配a字符至少n次
[root@localhost log]# grep "0\{1,\}" /etc/passwd
root:x:0:0:root:/root:/bin/bash
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown

a\{,m}		匹配a字符最多m次
[root@localhost log]# grep "a\{,1\}" /etc/passwd
root:x:0:0:root:/root:/bin/bash

+ -			1个或多个
? - 		0个或1个
| - 		同时过滤多个字符串
() - 		分组过滤，满足一个即可
[root@localhost log]# grep -E "(root|admin)" /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
admin:x:1000:1000:admin:/home/admin:/bin/bash

```



## grep 文本过滤

### 格式

```bash
grep [options] pattern [file...]
```

### 常用选项

- `-i`：忽略大小写进行匹配。
- `-v`：反向查找，只打印不匹配的行。
- `-n`：显示匹配行的行号。
- `-r`：递归查找子目录中的文件。
- `-l`：只打印匹配的文件名。
- `-c`：只打印匹配的行数。

### 基本演示

**1. -v 反向选择**

```bash
# 不显示带有root字符串的信息
[root@localhost log]# grep -v root /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

**2. -i 忽略大小写**

```bash
[root@localhost log]# grep -i ROOT /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
```

**3. -n 显示文件行号**

```bash
[root@localhost log]# grep -n root /etc/passwd
1:root:x:0:0:root:/root:/bin/bash
10:operator:x:11:0:operator:/root:/sbin/nologin
```

**4. -c 计算数量**

```bash
[root@localhost log]# grep -c root /etc/passwd
2
```

**5. -o 只显示匹配到的字符串**

```bash
[root@localhost log]# grep -o root /etc/passwd
root
root
root
root
```

**6. -B 显示匹配信息与匹配信息的前n行**

```bash
[root@localhost log]# grep -B1 root /etc/passwd
root:x:0:0:root:/root:/bin/bash
--
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin

```

**7. -A 显示匹配信息与匹配信息的后n行**

```bash
[root@localhost log]# grep -A1 root /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
--
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
```

**8. -C 显示匹配信息与信息的上下n行**

```bash
[root@localhost log]# grep -C1 root /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
--
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin

```

**9. -e 匹配多个选项**

```bash
[root@localhost log]# grep -e root -e lp /etc/passwd
root:x:0:0:root:/root:/bin/bash
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin

```

**10. -w 匹配单个单词**

```bash
[root@localhost log]# netstat -anut |grep -w 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN

```

### 实战：找出root最后一次登录的IP地址

```bash
[root@localhost ~]# last |grep "root" | grep "[0-9].[0-9].[0-9]"
root     pts/1        192.168.231.1    Fri Jun 16 06:07    gone - no logout
root     pts/0        192.168.231.1    Tue Jun 13 12:07 - 12:27  (00:19)
root     pts/0        192.168.231.1    Tue Jun 13 09:54 - 11:21  (01:27)
root     pts/1        192.168.231.132  Mon Jun 12 08:32 - 08:32  (00:00)
root     pts/0        192.168.231.1    Mon Jun 12 08:30 - 09:50  (01:19)
root     pts/1        192.168.231.1    Sun Jun 11 09:19 - 09:51  (00:32)
```

## sed 流编辑器

“sed” 是一个 Linux 命令行工具，用于对文本文件进行基于流的编辑。在 “sed” 中，模式空间（pattern space）是一个缓冲区，用于存储当前正在处理的行。

当 “sed” 读取一个新行时，它会将该行复制到模式空间中。然后，“sed” 会根据指定的命令对模式空间中的文本进行编辑。最后，当 “sed” 处理完一行时，它会打印模式空间中的内容（除非指定了 “-n” 选项），然后清空模式空间，以便处理下一行。

### 语法

```
sed [-hnV][-e<script>][-f<script文件>][文本文件]
```

**参数说明**：

- -e以选项中指定的script来处理输入的文本文件。
- -f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。
- -h或--help 显示帮助。
- -n或--quiet或--silent 仅显示script处理后的结果。
- -V或--version 显示版本信息。
- -i 确定操作，默认不改变文件

**动作说明**：

- a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
- c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
- d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；
- i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
- p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
- s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s/old/new/g 就是啦！

### 演示

**打印第n行**

```bash
[root@localhost test]# sed -n '1p' passwd
root:x:0:0:root:/root:/bin/bash
```

**打印偶数行**

```bash
# sed -n '从第x行开始~步长yp'
[root@localhost test]# seq 1 10 |sed -n '2~2p'
2
4
6
8
10

```

**删除奇数行**

```bash
[root@localhost test]# seq 1 10 | sed  '1,2d'
3
4
5
6
7
8
9
10
```

**追加字符串 a 在索引的后面**

```bash
[root@localhost test]# seq 1 10 | sed '2ahello'
1
2
hello
3
4
5
6
7
8
9
10
```

**插入字符串 i 在索引的前面**

```bash
[root@localhost test]# seq 1 10 | sed '2ihello'
1
hello
2
3
4
5
6
7
8
9
10
```

**替换指定行 c**

```bash
[root@localhost test]# seq 1 10 | sed '2chello'
1
hello
3
4
5
6
7
8
9
10
```

**-i.bak 修改文件并备份**

```bash
# 删除第二行并创建备份文件
[root@localhost test]# cat -n passwd |sed -i.bak '2d'
[root@localhost test]# ls
passwd  passwd.bak
```

**sed批量修改字符**

```bash
# 将所有的root替换为roat，g 重复替换，i不区分大小写
[root@localhost test]# sed 's/root/roat/gi' passwd |head
roat:x:0:0:roat:/roat:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

# 将第1-10行的所有roat替换为root，g 重复替换，i不区分大小写
[root@localhost test]# sed '1,10s/root/root/gi' passwd |head
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
```

**sed正则准确匹配root**

```bash
# -r 使用正则；\<root\> 规定bian
[root@localhost test]# sed -r 's/\<root\>/rooter/gi' passwd |head
rooter:x:0:0:rooter:/rooter:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

```

## awk 模式扫描和处理语言

### 语法

```
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

**选项参数说明：**

- -F fs or --field-separator fs
  指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
- -v var=value or --asign var=value
  赋值一个用户定义变量。
- -f scripfile or --file scriptfile
  从脚本文件中读取awk命令。
- -mf nnn and -mr nnn
  对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
- -W compact or --compat, -W traditional or --traditional
  在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。
- -W copyleft or --copyleft, -W copyright or --copyright
  打印简短的版权信息。
- -W help or --help, -W usage or --usage
  打印全部awk选项和每个选项的简短说明。
- -W lint or --lint
  打印不能向传统unix平台移植的结构的警告。
- -W lint-old or --lint-old
  打印关于不能向传统unix平台移植的结构的警告。
- -W posix
  打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。
- -W re-interval or --re-inerval
  允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。
- -W source program-text or --source program-text
  使用program-text作为源代码，可与-f命令混用。
- -W version or --version
  打印bug报告信息的版本。

### 分隔符、域和记录

+ 由分隔符分隔的字段（列column,域field)标记$1，$2.$n称为域标识，$0为所有域，注意：和shell中变量$符含义不同
+ 文件的每一行称为记录record
+ 如果省略action,则默认执行print$0的操作

### 动作print

格式：

```
print item1, item2
```

说明：

+ 逗号分隔符
+ 输出item可以字符串，也可是数值；当前记录的字段、变量或awk的表达式
+ 如省略item,相当于print$O

演示：

打印出日志文件中访问次数最多的IP地址

```bash
# $1指定打印第一列的内容，uniq 删除重复出现的IP地址并使用 -c 做次数统计，sort 做排序，-n 从小到大排序，-r倒序
[root@localhost log]# awk '{print $1}' access.log | uniq -c |sort -nr |head
  14200 201.54.214.79
   3016 201.54.214.79
   2924 201.54.214.79
   2662 20.195.192.160
   2582 201.54.214.79
   2171 201.54.208.61
   2110 201.54.214.79
   2002 20.195.192.160
   1727 20.195.192.160
   1686 201.54.214.79

# 取出访问量前3的IP地址
[root@localhost log]# awk '{print $1}' access.log |uniq -c |sort -nr |head -3
  14200 201.54.214.79
   3016 201.54.214.79
   2924 201.54.214.79

# 取出iconfig中的所有IP地址
[root@localhost log]# ifconfig |awk '/inet [0-9].[0-9].[0-9]/ {print $2}'
192.168.231.133
127.0.0.1
192.168.122.1

```

# Linux 应急响应

## 1. Linux 应急响应思路

**1.1 用户文件排查**

+ 查看`/etc/passwd`文件，查看是否有可疑用户，具体查看UID为0的用户
+ 查看`/etc/sudoers`文件，查看允许使用sudo命令的用户有哪些

**1.2 用户操作命令**

```bash
# 锁定用户
usermod -l <username>
# 删除用户
userdel <username>
# 删除用户并删除用户家目录
userdel -
```

# Linux 安全加固

## `/etc/login.defs`

### 文件功能

定义了`/etc/password`以及`/etc/shadown`配套的用户限制，如果这两个文件与`/etc/login.defgs`发生冲突，则以这两个文件为准

```bash
[root@localhost ~]# grep -Ev "^#|^$" /etc/login.defs
MAIL_DIR        /var/spool/mail
PASS_MAX_DAYS   99999								# 密码有效期，单位：天
PASS_MIN_DAYS   0									# 两次密码修改的时间间隔，单位：天
PASS_MIN_LEN    5									# 密码的最小长度
PASS_WARN_AGE   7									# 密码过期前n天开始提示
UID_MIN                  1000						# 用户最小的UID，当创建一个新用户之后，会从1000递增
UID_MAX                 60000						# 用户最大UID
SYS_UID_MIN               201						# 系统最小UID
SYS_UID_MAX               999						# 系统最大UID
GID_MIN                  1000
GID_MAX                 60000
SYS_GID_MIN               201
SYS_GID_MAX               999
CREATE_HOME     yes									# 创建用户时是否创建用户的家目录
UMASK           077									# 用户对家目录所拥有的权限 UMASK值
USERGROUPS_ENAB yes									# 在删除用户时是否删除仅有改用户的用户组
ENCRYPT_METHOD SHA512								# 用户密码加密模式
```

用户UID和系统UID的区别：用户UID标识的是一个用户，系统UID标识的是一个进程或者服务

## `/etc/passwd`

```bash
# 以 : 做分隔符
root  : x         : 0    : 0   : root     : /root    : /bin/bash
用户名 密码（被隐藏） UID    GID   用户的注释   用户家目录  用户的shell
```

## `/etc/shadown`

```bash
root:$6$hyeoQzvLxwn1Cy5p$HSPOHPuSMuyqxg7lDorxdzlulYAKPlGcq7UXBCI6xbtIy/3eOR0bvLaeErhYi47o.FllV0O5.9zhKtwsxcRxO/::0:99999:7:::
# 用户名:$盐$sha512后的密码
```

## `/etc/ssh/sshd_conf`

```bash
Port 22													# 默认监听端口
ListenAddress 0.0.0.0									# 默认监听地址
MaxAuthTries 6											# 最多可尝试登录6次
PermitEmptyPasswords no									# 不允许空密码登录
```

# Linux 从入门到精通

## 文件和用户管理

### 文件管理

#### Linux目录结构

+ bin：普通用户所使用的命令
+ sbin：管理员所使用的命令
+ dev：设备文件，驱动
+ root：超级管理员家目录
+ home：普通用户家目录
+ boot：系统启动文件
+ etc：服务配置文件
+ run：当前正在允许的文件
+ tmp：临时文件
+ var：日志文件。经常发送变动的文件

#### 文件常见类型

`-`：普通文件

`d`：文件目录

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/桌面/ctf]
└─# ll
总用量 16
-rwxrw-rw- 1 pinginglab pinginglab  164  7月  7  2015 dianli_jbctf_MISC_T10076_20150707_rar.rar
drwxr-xr-x 2 root       root       4096  6月 24 23:54 test
```

### 文件管理命令

#### `cd`切换目录

```shell
cd [-L|[-P [-e]]] [dir]
```

#### `touch`创建文件

```shell
touch(选项)(参数)
```

#### `mkdir`创建文件夹

```shell
mkdir (选项)(参数)
```

##### 选项

```shell
-Z：设置安全上下文，当使用SELinux时有效；
-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限；
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
--version 显示版本信息。
```

##### 演示

```bash
# -p 递归创建多个目录
[root@localhost ~]# mkdir -p test/aaa/nnn

```

#### `cp`复制

```
cp (选项) 源文件 目标路径
```

##### 选项

```shell
-a：此参数的效果和同时指定"-dpR"参数相同；
-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
-f：强行复制文件或目录，不论目标文件或目录是否已存在；
-i：覆盖既有文件之前先询问用户；
-l：对源文件建立硬连接，而非复制文件；
-p：保留源文件或目录的属性；
-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；
-s：对源文件建立符号连接，而非复制文件；
-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
-b：覆盖已存在的文件目标前将目标文件备份；
-v：详细显示命令执行的操作。
```

##### 演示

```bash
# -r 拷贝整个文件夹
[root@localhost ~]# cp -r test/aaa/nnn/ test/
```

#### `mv`剪切

```shell
mv (选项) 源文件 目标文件
```

##### 选项

```shell
--backup=<备份模式>：若需覆盖文件，则覆盖前先行备份；
-b：当文件存在时，覆盖前，为其创建一个备份；
-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
```

#### `rm`删除文件

```shell
rm (选项) 文件名
```

##### 选项

```shell
-f：强制删除文件或目录；
-i：删除已有文件或目录之前先询问用户；
-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；
-v：显示指令的详细执行过程。
```

##### 演示

```bash
[root@localhost ~]# rm test/{a1,a2}
rm：是否删除普通空文件 'test/a1'？
rm：是否删除普通空文件 'test/a2'？
```

#### `cat`查看文件

```shell
cat [OPTION]... [FILE]...
```

##### 选项

```shell
-n, --number             对所有行编号，从1开始编号。
```

#### `vim`文档编辑器

vim是vi的升级版，vim的高亮显示功能是vi不具备的

##### vim常用命令

```
yy：复制
nyy：复制n行
p：粘贴
dd：删除一行
ndd：删除n行
u：撤回
hjkl：上下左右
0 $：行首行尾
gg G：页首页尾
NG：进入第N行
/string（n N可以循环）：查找字符串
:1,5 s/root/qingfeng/g：从1-5行将root替换为qingfeng
:w /tmp/aaa.txt：另存为/tmp下的aaa.txt
:set nu：设置行号
:set list：显示控制字符
:set nonu：取消设置行号
```

##### vim意外退出产生的临时文件

在vim的使用过程中，如果意外关闭了vim程序，那么系统就会自动对当前的文件做备份，备份名：`.名字.swp`，此时打开原文件会看到下面内容

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230626204755121.png" alt="image-20230626204755121" style="zoom:50%;" />

解决方法：使用`rm`命令删除该备份文件即可

### 用户管理

#### `/etc/passwd`

```bash
[root@localhost test]# head -1 /etc/passwd
root:x:0:0:root:/root:/bin/bash
```

+ root：用户名
+ x：密码，被隐藏
+ 0：UID，==UID为0代表超管，1-499系统用户，1000+普通用户==
+ 0：GID
+ root：用户描述
+ /root：用户家目录
+ /bin/bash：shell解释器

#### `/etc/shadow`

```bash
[root@localhost test]# grep admin /etc/shadow
admin:$6$8umyR7VQCelQNKOP$3ZRGVt6kf87laTgPRW7t9cO04xW379x2zWp1c.ZP6GwvmdiQHAFpyi3Tqihgi4olN2pMxZFv2LCNOvhPtxlcC/:19519:0:99999:7:::
```

+ root：账户名
+ $6$8umy：密文和加密信息
  + $n$：表示加密算法：
    + $6$：SHA-512加密
    + $1$：MD5加密
    + $2$：Blowfish加密
    + $5$：SHA-256加密

+ 19519：最后一次修改时间，从1970年1月1日开始计算，加19519天
+ 0：两次密码修改的时间间隔，0表示可随时修改
+ 99999：密码有效期
+ 7：密码过期警告时间，密码过期前7天警告用户
+ 不活动时间：用户在N天之内都没有再登录系统，则直接禁用用户
+ 失效时间：用户在创建者之后N天后就直接禁用删除
+ 系统保留

#### `/etc/group`

```bash
[root@localhost test]# grep wheel /etc/group
wheel:x:10:admin
```

+ 组名
+ 组密码
+ 组ID
+ 组成员

### 用户管理命令

#### `useradd`添加用户

```shell
useradd (选项) (参数)
```

##### 选项

```
-c<备注>：加上备注文字。备注文字会保存在passwd的备注栏位中；      √
-d<登入目录>：指定用户登入时的启始目录；						  √
-D：变更预设值；
-e<有效期限>：指定帐号的有效期限；
-f<缓冲天数>：指定在密码过期后多少天即关闭该帐号；
-g<群组>：指定用户所属的群组；
-G<群组>：指定用户所属的附加群组；
-m：自动建立用户的登入目录；
-M：不要自动建立用户的登入目录；
-n：取消建立以用户名称为名的群组；
-r：建立系统帐号；
-s<shell>：指定用户登入后所使用的shell；
-u<uid>：指定用户id。                                       √
```

##### 演示

```bash
# 创建一个名为 user01 的用户，UID为1060，家目录在 /user01
[root@localhost test]#  useradd user01 -u 1060 -d /user01
```

#### `id`查看用户信息

```shell
id [OPTION]... [USER]...
```

###### 选项

```shell
-a               兼容性选项，没有实际作用。
-Z, --context    只打印进程的安全上下文。
-g, --group      只打印有效的组ID。
-G, --groups     打印全部组ID。
-u, --user       只打印有效的用户ID。
-z, --zero       使用空字符代替默认的空格来分隔条目。
--help           显示帮助信息并退出。
--version        显示版本信息并退出。
```

###### 演示

```bash
[root@localhost test]# id user01
uid=1060(user01) gid=1060(user01) 组=1060(user01)
```

#### `passwd`修改密码

```shell
passwd (选项) (参数)
```

##### 选项

```shell
-d：删除密码，仅有系统管理者才能使用；
-f：强制执行；
-k：设置只有在密码过期失效后，方能更新；
-l：锁住密码；
-s：列出密码的相关信息，仅有系统管理者才能使用；
-u：解开已上锁的帐号。
```

##### 演示

```bash
[root@localhost test]# passwd user01
更改用户 user01 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
```

#### `usermod`修改用户

```shell
usermod(选项)(参数)
```

##### 选项

```shell
-c<备注>：修改用户帐号的备注文字；
-d<登入目录>：修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用；
-m<移动用户家目录>:移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。
-e<有效期限>：修改帐号的有效期限；
-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；
-g<群组>：修改用户所属的群组；							√
-G<群组>；修改用户所属的附加群组；						   √
-l<帐号名称>：修改用户帐号名称；
-L：锁定用户密码，使密码无效；							√
-s<shell>：修改用户登入后所使用的shell；
-u<uid>：修改用户ID；
-U:解除密码锁定。
```

##### 演示

```bash
# 锁定账户
[root@localhost test]# usermod -L user01
```

#### `userdel`删除用户

```shell
userdel(选项)(参数)
```

##### 选项

```
-f：强制删除用户，即使用户当前已登录；
-r：删除用户的同时，删除与用户相关的所有文件。
```

##### 演示

```bash
# 删除用户并且删除用户的家目录
[root@localhost test]# userdel -r user01
```

### 用户组管理

#### 用户组管理类型

+ 基本组：基本组随用户的创建而创建，与用户名同名
+ 附加组：附加组是某个用户加入到基本组以外的组

基本组和附加组的定义都是基于用户而定义的

### 用户组管理命令

#### `groupadd`创建组

```shell
groupadd (选项) (参数)
```

##### 选项

```shell
-g：指定新建工作组的id；
-r：创建系统工作组，系统工作组的组ID小于500；
-K：覆盖配置文件“/ect/login.defs”；
-o：允许添加组ID号不唯一的工作组。
```

##### 演示

```bash
[root@localhost test]# grep group01 /etc/gro
[root@localhost test]# grep group01 /etc/group
group01:x:1606:
```

#### `groupdel`删除组

```shell
groupdel(参数)
```

##### 演示

```bash
[root@localhost test]# groupdel group01
```

### 提权

#### `su` 永久提权

```shell
su(选项)(参数)
```

##### 选项

```shell
-c<指令>或--command=<指令>：执行完指定的指令后，即恢复原来的身份；
-f或——fast：适用于csh与tsch，使shell不用去读取启动文件；
-l或——login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量；
-m,-p或--preserve-environment：变更身份时，不要变更环境变量；
-s<shell>或--shell=<shell>：指定要执行的shell；
--help：显示帮助；
--version；显示版本信息。
```

##### 演示

```bash
[user01@localhost root]$ su - root
密码：
```

#### `sudo`暂时提权

```shell
sudo(选项)(参数)
```

##### 选项

```shell
-b：在后台执行指令；
-E：继承当前环境变量
-h：显示帮助；
-H：将HOME环境变量设为新身份的HOME环境变量；
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
-l：列出目前用户可执行与无法执行的指令；
-p：改变询问密码的提示符号；
-s<shell>：执行指定的shell；
-u<用户>：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
-v：延长密码有效期限5分钟；
-V ：显示版本信息。
```

##### 演示

```bash
[user01@localhost root]$ sudo useradd user02
```

##### 扩展

`sudo`命令的使用不是所有普通用户都有资格，资格的授予在`/etc/sudoers`中

```bash
[root@localhost ~]# vim /etc/sudoers
# 用户名|组名 ALL=(ALL)	ALL
user01 ALL=(ALL)        ALL
```

## 用户的权限

### 基本权限UGO

对于文件或者目录都有3类权限，分别是：

+ R：4
+ W：2
+ X：1

#### 用户权限修改命令

##### `chmod`修改文件或文件夹权限

```shell
chmod [OPTION]... MODE[,MODE]... FILE...
chmod [OPTION]... OCTAL-MODE FILE...
chmod [OPTION]... --reference=RFILE FILE...
```

###### 选项

```shell
-c, --changes：当文件的权限更改时输出操作信息。
--no-preserve-root：不将'/'特殊化处理，默认选项。
--preserve-root：不能在根目录下递归操作。
-f, --silent, --quiet：抑制多数错误消息的输出。
-v, --verbose：无论文件是否更改了权限，一律输出操作信息。
--reference=RFILE：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。
-R, --recursive：对目录以及目录下的文件递归执行更改权限操作。								√
--help：显示帮助信息并退出。
--version：显示版本信息并退出。
```

###### 演示

```bash
[root@localhost test]# chmod a=rwx a1.txt
[root@localhost test]# ll a1.txt
-rwxrwxrwx. 1 root root   80 6月  27 06:46 a1.txt

[root@localhost test]# chmod 777 a1.txt
[root@localhost test]# ll a1.txt
-rwxrwxrwx. 1 root root 80 6月  27 06:46 a1.txt
[root@localhost test]#

# 递归修改文件夹中的所有文件权限
[root@localhost ~]# chmod -R 777 test/
[root@localhost ~]# ll test/
总用量 12
-rwxrwxrwx. 1 root root   80 6月  27 06:46 a1.txt
-rwxrwxrwx. 1 root root    0 6月  25 05:49 a2
```

##### `chown`修改属主或属组

```shell
chown (选项) (参数)
```

###### 选项

```shell
-c或——changes：效果类似“-v”参数，但仅回报更改的部分；
-f或--quite或——silent：不显示错误信息；
-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；
-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；					√
-v或——version：显示指令执行过程；
--dereference：效果和“-h”参数相同；
--help：在线帮助；
--reference=<参考文件或目录>：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；
--version：显示版本信息。
```

###### 演示

```bash
# 递归修改文件夹中所有文件的属主和属组
[root@localhost ~]# chown -R user01:user01 test/
[root@localhost ~]# ll test/
总用量 12
-rwxrwxrwx. 1 user01 user01   80 6月  27 06:46 a1.txt
-rwxrwxrwx. 1 user01 user01    0 6月  25 05:49 a2
```

### 基本权限ACL

一般情况下使用基本权限UGO就可以完成日常需求，但是在复制需求下，ACL可有满足多用户多组的权限秀爱

#### `setfacl`设置文件ACL

##### 选项

```shell
-b,--remove-all：删除所有扩展的acl规则，基本的acl规则(所有者，群组，其他）将被保留。			√
-k,--remove-default：删除缺省的acl规则。如果没有缺省规则，将不提示。
-n，--no-mask：不要重新计算有效权限。setfacl默认会重新计算ACL mask，除非mask被明确的制定。
--mask：重新计算有效权限，即使ACL mask被明确指定。
-d，--default：设定默认的acl规则。
--restore=file：从文件恢复备份的acl规则（这些文件可由getfacl -R产生）。通过这种机制可以恢复整个目录树的acl规则。此参数不能和除--test以外的任何参数一同执行。
--test：测试模式，不会改变任何文件的acl规则，操作后的acl规格将被列出。
  -X, --remove-file=file  删除ACL条目
-R，--recursive：递归的对所有文件及目录进行操作。											√
-L，--logical：跟踪符号链接，默认情况下只跟踪符号链接文件，跳过符号链接目录。
-P，--physical：跳过所有符号链接，包括符号链接文件。
--version：输出setfacl的版本号并退出。
--help：输出帮助信息。
--：标识命令行参数结束，其后的所有参数都将被认为是文件名
-：如果文件名是-，则setfacl将从标准输入读取文件名。
```

##### 演示

```bash
# 为用户 user02 添加读写权限
[root@localhost test]# setfacl -m u:user02:rw a1.txt
[root@localhost test]# ll a1.txt
# + 表示该文件配置了ACL
-rwxrwxrwx+ 1 user01 user01 80 6月  27 06:46 a1.txt

# 删除用户 root 的权限
[root@localhost test]# setfacl -x u:root a1.txt

# 删除所有ACL
[root@localhost test]# setfacl -b a1.txt
```

#### `getfacl`查看文件ACL

```bash
[root@localhost test]# getfacl a1.txt
# file: a1.txt
# owner: user01
# group: user01
user::rwx
group::rwx
other::rwx
```

### 特殊权限

#### 特殊位SUID

==此位只对可执行文件有效==

在执行一个可执行文件时，会使用==所属主==的权限来执行

```bash
# 将cat提权为SUID权限，此时cat将时一个提权文件
# 其他用户并没有读取权限但依然可以查看该文件
[user01@localhost ~]$ ll /tmp/a1.txt
-rws------. 1 root root 100 6月  28 03:48 /tmp/a1.txt
[user01@localhost ~]$ cat /tmp/a1.txt
echo "Hello World!"
echo "Hello World!"
echo "Hello World!"
echo "Hello World!"
echo "Hello World!"
```

#### 文件属性`chattr`

```shell
chattr (选项)
```

##### 选项

```shell
a：让文件或目录仅供附加用途；
b：不更新文件或目录的最后存取时间；
c：将文件或目录压缩后存放；
d：将文件或目录排除在倾倒操作之外；
i：不得任意更动文件或目录；
s：保密性删除文件或目录；
S：即时更新文件或目录；
u：预防意外删除。
-R：递归处理，将指令目录下的所有文件及子目录一并处理；
-v<版本编号>：设置文件或目录版本；
-V：显示指令执行过程；
+<属性>：开启文件或目录的该项属性；
-<属性>：关闭文件或目录的该项属性；
=<属性>：指定文件或目录的该项属性。
```

##### 演示

```bash
# 增加 i 权限
[root@localhost test]# chattr +i a1.txt
# 查看特殊权限
[root@localhost test]# lsattr a1.txt
----i------------- a1.txt
# 增加了 i 特殊权限的文件无法被删除修改和重命名
[root@localhost test]# rm -rf a1.txt
rm: 无法删除'a1.txt': 不允许的操作
```

## 进程管理

### `ps`查看进程状态

```shell
ps (选项)
```

#### 选项

```shell
-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。
a：显示现行终端机下的所有程序，包括其他用户的程序。
-A：显示所有程序。
-c：显示CLS和PRI栏位。
c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
-C<指令名称>：指定执行指令的名称，并列出该指令的程序的状况。
-d：显示所有程序，但不包括阶段作业领导者的程序。
-e：此选项的效果和指定"A"选项相同。
e：列出程序时，显示每个程序所使用的环境变量。
-f：显示UID,PPIP,C与STIME栏位。
f：用ASCII字符显示树状结构，表达程序间的相互关系。
-g<群组名称>：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
g：显示现行终端机下的所有程序，包括群组领导者的程序。
-G<群组识别码>：列出属于该群组的程序的状况，也可使用群组名称来指定。
h：不显示标题列。
-H：显示树状结构，表示程序间的相互关系。
-j或j：采用工作控制的格式显示程序状况。
-l或l：采用详细的格式来显示程序状况。
L：列出栏位的相关信息。
-m或m：显示所有的执行绪。
n：以数字来表示USER和WCHAN栏位。
-N：显示所有的程序，除了执行ps指令终端机下的程序之外。
-p<程序识别码>：指定程序识别码，并列出该程序的状况。
p<程序识别码>：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
r：只列出现行终端机正在执行中的程序。
-s<阶段作业>：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
s：采用程序信号的格式显示程序状况。
S：列出程序时，包括已中断的子程序资料。
-t<终端机编号>：指定终端机编号，并列出属于该终端机的程序的状况。
t<终端机编号>：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
-T：显示现行终端机下的所有程序。
-u<用户识别码>：此选项的效果和指定"-U"选项相同。
u：以用户为主的格式来显示程序状况。
-U<用户识别码>：列出属于该用户的程序的状况，也可使用用户名称来指定。
U<用户名称>：列出属于该用户的程序的状况。
v：采用虚拟内存的格式显示程序状况。
-V或V：显示版本信息。
-w或w：采用宽阔的格式来显示程序状况。　
x：显示所有程序，不以终端机来区分。
X：采用旧式的Linux i386登陆格式显示程序状况。
-y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
-<程序识别码>：此选项的效果和指定"p"选项相同。
--cols<每列字符数>：设置每列的最大字符数。
--columns<每列字符数>：此选项的效果和指定"--cols"选项相同。
--cumulative：此选项的效果和指定"S"选项相同。
--deselect：此选项的效果和指定"-N"选项相同。
--forest：此选项的效果和指定"f"选项相同。
--headers：重复显示标题列。
--help：在线帮助。
--info：显示排错信息。
--lines<显示列数>：设置显示画面的列数。
--no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
--group<群组名称>：此选项的效果和指定"-G"选项相同。
--Group<群组识别码>：此选项的效果和指定"-G"选项相同。
--pid<程序识别码>：此选项的效果和指定"-p"选项相同。
--rows<显示列数>：此选项的效果和指定"--lines"选项相同。
--sid<阶段作业>：此选项的效果和指定"-s"选项相同。
--tty<终端机编号>：此选项的效果和指定"-t"选项相同。
--user<用户名称>：此选项的效果和指定"-U"选项相同。
--User<用户识别码>：此选项的效果和指定"-U"选项相同。
--version：此选项的效果和指定"-V"选项相同。
--widty<每列字符数>：此选项的效果和指定"-cols"选项相同。
```

由于ps命令能够支持的系统类型相当的多，所以选项多的离谱！

#### 实例

```shell
ps axo pid,comm,pcpu # 查看进程的PID、名称以及CPU 占用率
ps aux | sort -rnk 4 # 按内存资源的使用量对进程进行排序
ps aux | sort -nk 3  # 按 CPU 资源的使用量对进程进行排序
ps -A # 显示所有进程信息
ps -u root # 显示指定用户信息
ps -efL # 查看线程数
ps -e -o "%C : %p :%z : %a"|sort -k5 -nr # 查看进程并按内存使用大小排列
ps -ef # 显示所有进程信息，连同命令行
ps -ef | grep ssh # ps 与grep 常用组合用法，查找特定进程
ps -C nginx # 通过名字或命令搜索进程
ps aux --sort=-pcpu,+pmem # CPU或者内存进行排序,-降序，+升序
ps -f --forest -C nginx # 用树的风格显示进程的层次关系
ps -o pid,uname,comm -C nginx # 显示一个父进程的子进程
ps -e -o pid,uname=USERNAME,pcpu=CPU_USAGE,pmem,comm # 重定义标签
ps -e -o pid,comm,etime # 显示进程运行的时间
ps -aux | grep named # 查看named进程详细信息
ps -o command -p 91730 | sed -n 2p # 通过进程id获取服务名称
```

将目前属于您自己这次登入的 PID 与相关信息列示出来

```shell
[root@localhost test]# ps -aux |head -2
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.7 179004 13752 ?        Ss   6月27   0:06 /usr/lib/systemd/systemd --switched-root --system --deserialize 18
```

+ `USER`：用户
+ `PID`：进程的唯一标识符
+ `%CPU`：CPU资源占用
+ `%MEM`：内存的资源占用
+ `VSZ`：虚拟内存的占用（硬盘会划出一小部分空间出来做虚拟内存）
+ `RSS`：实际内存的资源占用
+ `TTY`：终端号（? 表示当前终端）
+ `STAT`：进程状态：
  + R：Run（运行）
  + S：Sleep（睡眠）
  + T：sTop（停止）
  + Z：Zombie（未响应）

+ `START`：进程启动时间
+ `TIME`：CPU运行运了多久
+ `COMMAND`：启动命令 

### `top`实时查看进程状态

```shell
top (选项)
```

#### 选项

```shell
-b：以批处理模式操作；
-c：显示完整的治命令；
-d：屏幕刷新间隔时间；
-I：忽略失效过程；
-s：保密模式；
-S：累积模式；
-i<时间>：设置间隔时间；
-u<用户名>：指定用户名；
-p<进程号>：指定进程；
-n<次数>：循环显示的次数。
```

#### 演示

```shell
top - 09:44:56 up 16 days, 21:23,  1 user,  load average: 9.59, 4.75, 1.92
Tasks: 145 total,   2 running, 143 sleeping,   0 stopped,   0 zombie
Cpu(s): 99.8%us,  0.1%sy,  0.0%ni,  0.2%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   4147888k total,  2493092k used,  1654796k free,   158188k buffers
Swap:  5144568k total,       56k used,  5144512k free,  2013180k cached
```

**解释：**

- top - 09:44:56[当前系统时间],
- 16 days[系统已经运行了16天],
- 1 user[个用户当前登录],
- load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度]
- Tasks: 145 total[总进程数],
- 2 running[正在运行的进程数],
- 143 sleeping[睡眠的进程数],
- 0 stopped[停止的进程数],
- 0 zombie[冻结进程数],
- Cpu(s): 99.8%us[用户空间占用CPU百分比],
- 0.1%sy[内核空间占用CPU百分比],
- 0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比],
- 0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比],
- 0.0%hi[],
- 0.0%st[],
- Mem: 4147888k total[物理内存总量],
- 2493092k used[使用的物理内存总量],
- 1654796k free[空闲内存总量],
- 158188k buffers[用作内核缓存的内存量]
- Swap: 5144568k total[交换区总量],
- 56k used[使用的交换区总量],
- 5144512k free[空闲交换区总量],
- 2013180k cached[缓冲的交换区总量],

### `kill`向进程发送信号

```shell
kill [-s sigspec | -n signum | -sigspec] pid | jobspec ...
kill -l [sigspec]
```

#### 选项

```shell
[user2@pc] kill -l 9
KILL

# 列出所有信号名称：
[user2@pc] kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

# 下面是常用的信号。
# 只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。

HUP     1    用于重新加载指定服务的配置文件
INT     2    中断（同 Ctrl + C）
QUIT    3    退出（同 Ctrl + \）
KILL    9    强制终止
TERM   15    终止
CONT   18    继续（与STOP相反，fg/bg命令）
STOP   19    暂停（同 Ctrl + Z）
```

### `nice`进程优先级

```shell
nice (选项) (参数)
```

#### 选项

```shell
-n：指定进程的优先级（整数）。
```

#### 演示

```bash
# 创建进程时指定优先级
[root@localhost test]# nice -n -5 sleep 5

# 创建进程后再指定优先级
# renice -n <优先级> <PID>
[root@localhost test]# renice -n -15 2364
2364 (process ID) 旧优先级为 0，新优先级为 -15

# kill -1 不重启服务但重新加载配置文件
[root@localhost ~]# ps aux |grep mysql
mysql      2421  0.7 21.8 1770728 403652 ?      Ssl  08:09   1:19 /usr/sbin/mysqld --defaults-group-suffix=@multi/user
root       4317  0.0  0.0  12320  1128 pts/0    S+   10:57   0:00 grep --color=auto mysql
[root@localhost ~]# kill -1 2421

```

### `jobs`作业控制

```shell
jobs [-lnprs] [jobspec ...]
jobs -x command [args]
```

#### 选项

```shell
-l    在作业信息中额外的列出PID。
-n    只列出最近一次通知以来状态变更的作业。
-p    只列出PID。
-r    只输出处于运行状态的作业。
-s    只输出处于停止状态的作业。
```

#### 演示

```bash
# 创建一个sleep进程并将其丢到后台运行
[root@localhost test]# sleep 10000 &
[1] 8465
# 查看后台运行的程序
[root@localhost test]# jobs
[1]+  运行中               sleep 10000 &
# fg 丢到前台运行
[root@localhost test]# fg 1
sleep 10000
# killsha
[root@localhost test]# kill %1
[root@localhost test]# jobs
[1]+  已终止               sleep 10000
```

## 管道和重定向

### FD 文件描述符

Linux 文件描述符，描述的是一种文件路径和数字的映射关系，如：`/dev/pts/0`映射为`1`，以达到将冗长的路径名映射为某个数字的目的

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230629104656750.png" alt="image-20230629104656750" style="zoom:50%;" />

每一个进程都会有序列号为：0、1、2的FD

+ 0：标准输入（键盘、鼠标）
+ 1：标准输出（正常信息回显）
+ 2：标准错误输出（错误信息输出）

```bash
[root@localhost ~]# ll /proc/2857/fd
总用量 0
lrwx------. 1 root root 64 6月  28 22:45 0 -> /dev/pts/0
lrwx------. 1 root root 64 6月  28 22:45 1 -> /dev/pts/0
lrwx------. 1 root root 64 6月  28 22:45 2 -> /dev/pts/0
lr-x------. 1 root root 64 6月  28 22:45 3 -> /var/lib/sss/mc/passwd
lrwx------. 1 root root 64 6月  28 22:45 4 -> 'socket:[53321]'
```

### 重定向

#### 输出重定向`>`

将标准输出的信息重定向到其他位置输出；`> = 1>`

`1> 代表标砖输出`

`2> 代表标准错误输出`

```bash
[root@localhost test]# echo "Hello world" > 1.txt
[root@localhost test]# cat 1.txt
Hello world

# 也可以输出到其他终端上
[root@localhost test]# echo "DDDDD" > /dev/pts/0
# 也可以直接输出到当前终端
[root@localhost test]# echo "DDDDD" > /dev/pts/1
DDDDD

# 错误输出重定向
[root@localhost test]# ls /aaa 2> 1.txt
[root@localhost test]# cat 1.txt
ls: 无法访问'/aaa': 没有那个文件或目录

# 将输入输出重定向分开
# 将标准输出重定向到11.txt，将标准错误输出重定向到1.txt
[root@localhost test]# ls /aaa 2> 1.txt > 11.txt

# &> 将标砖输出和标准错误输出都重定向到另一个地方
[root@localhost test]# ls /aaa &> /dev/null
```

#### 追加重定向`>>`

将标准输出追加到某个文件或终端，期间不会覆盖文件

```bash
[root@localhost test]# echo "HHHHHH" >> 1.txt
[root@localhost test]# echo "HHHHHH" >> 1.txt
[root@localhost test]# cat 1.txt
HHHHHH
HHHHHH
HHHHHH
```

#### 输入重定向`<`

将指定内容往程序中输入

```bash
[root@localhost test]# sort < 1.txt

1
3
4
5
6
6
8
8
8
```

### 管道

#### `|`双通管道

作用：将管道左边的标准输出做标准输入到右边的命令

```bash
[root@localhost test]# cat /etc/passwd |head -1
root:x:0:0:root:/root:/bin/bash
```

#### `|tee` 三通管道

作用：在双通管道的基础上再加上一个功能：可以将输出输入到文件中

```bash
[root@localhost test]# cat /etc/passwd |tee 1.txt |head -1
root:x:0:0:root:/root:/bin/bash
[root@localhost test]# cat 1.txt
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
...
```

#### `|xargs`参数传递

由于格式的错误，如果直接使用`|`输出到`rm cp`命令会执行失败

```bash
[root@localhost test]# touch file{1..5}
[root@localhost test]# ls file*
file1  file2  file3  file4  file5
[root@localhost test]# cat 1.txt
file1
file3
file5
[root@localhost test]# cat 1.txt | rm -rf
[root@localhost test]# ls file*
file1  file2  file3  file4  file5

# 使用 |xargs 格式化输出使得rm命令能看懂
[root@localhost test]# cat 1.txt |xargs rm -rvf
已删除'file1'
已删除'file3'
已删除'file5'
```

## 磁盘管理

### 磁盘挂载

> 磁盘挂载分为三部：磁盘分区、磁盘格式化、磁盘挂载

### 主分区



#### 磁盘分区-主分区

```bash
[root@localhost test]# fdisk /dev/sda

欢迎使用 fdisk (util-linux 2.32.1)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

设备不包含可识别的分区表。
创建了一个磁盘标识符为 0x36b4735a 的新 DOS 磁盘标签。

命令(输入 m 获取帮助)：n
分区类型
   p   主分区 (0个主分区，0个扩展分区，4空闲)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：p
分区号 (1-4, 默认  1): 1
第一个扇区 (2048-10485759, 默认 2048):
上个扇区，+sectors 或 +size{K,M,G,T,P} (2048-10485759, 默认 10485759): +2G

创建了一个新分区 1，类型为“Linux”，大小为 2 GiB。

命令(输入 m 获取帮助)：w
分区表已调整。
将调用 ioctl() 来重新读分区表。
正在同步磁盘。

# 刷新分区，立即生效
[root@localhost test]# partprobe /dev/sda

# 查看分区情况
[root@localhost test]# lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0    5G  0 disk
└─sda1          8:1    0    2G  0 part
sr0            11:0    1  6.6G  0 rom
nvme0n1       259:0    0   20G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   19G  0 part
  ├─rhel-root 253:0    0   17G  0 lvm  /
  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
```

#### 磁盘格式化-主分区

```bash
[root@localhost test]# mkfs.ext4 /dev/sda1
mke2fs 1.44.3 (10-July-2018)
创建含有 524288 个块（每块 4k）和 131072 个inode的文件系统
文件系统UUID：5cc0b25c-84f8-425f-baf3-0007d859571a
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376, 294912

正在分配组表： 完成
正在写入inode表： 完成
创建日志（16384 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

#### 磁盘挂载-主分区

```bash
[root@localhost test]# mkdir /newDisk
[root@localhost test]# mount -t ext4 /dev/sda1 /newDisk/
[root@localhost test]# df -HT
文件系统              类型      容量  已用  可用 已用% 挂载点
devtmpfs              devtmpfs  932M     0  932M    0% /dev
tmpfs                 tmpfs     947M     0  947M    0% /dev/shm
tmpfs                 tmpfs     947M  9.9M  938M    2% /run
tmpfs                 tmpfs     947M     0  947M    0% /sys/fs/cgroup
/dev/mapper/rhel-root xfs        19G  5.3G   13G   30% /
/dev/nvme0n1p1        xfs       1.1G  177M  887M   17% /boot
tmpfs                 tmpfs     190M   17k  190M    1% /run/user/42
tmpfs                 tmpfs     190M  4.1k  190M    1% /run/user/0
/dev/sda1             ext4      2.1G  6.3M  2.0G    1% /newDisk
```

### 扩展分区

由于Linux使用的是MBR文件系统，所以一块磁盘最多只嫩容纳**4个主分区**，为了解决分区数量不足的问日，就引入了**扩展分区**

扩展分区的作用：一般管理员会将第4个分区作为扩展分区，然后在扩展分区的基础上划分**逻辑分区**，以此，就可以突破4个分区的限制

#### 创建扩展分区

```bash
命令(输入 m 获取帮助)：p
Disk /dev/sda：5 GiB，5368709120 字节，10485760 个扇区
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x36b4735a

设备       启动    起点    末尾    扇区  大小 Id 类型
/dev/sda1          2048 4196351 4194304    2G 83 Linux
/dev/sda2       4196352 5244927 1048576  512M 83 Linux
/dev/sda3       5244928 6293503 1048576  512M 83 Linux

命令(输入 m 获取帮助)：n
分区类型
   p   主分区 (3个主分区，0个扩展分区，1空闲)
   e   扩展分区 (逻辑分区容器)
选择 (默认 e)：

将使用默认回应 e。
已选择分区 4
第一个扇区 (6293504-10485759, 默认 6293504):
上个扇区，+sectors 或 +size{K,M,G,T,P} (6293504-10485759, 默认 10485759):

创建了一个新分区 4，类型为“Extended”，大小为 2 GiB。
```

#### 创建逻辑分区

```bash
命令(输入 m 获取帮助)：n
所有主分区都在使用中。
添加逻辑分区 5
第一个扇区 (6295552-10485759, 默认 6295552):
上个扇区，+sectors 或 +size{K,M,G,T,P} (6295552-10485759, 默认 10485759): +512M

创建了一个新分区 5，类型为“Linux”，大小为 512 MiB。

命令(输入 m 获取帮助)：n
所有主分区都在使用中。
添加逻辑分区 6
第一个扇区 (7346176-10485759, 默认 7346176):
上个扇区，+sectors 或 +size{K,M,G,T,P} (7346176-10485759, 默认 10485759): +512M

创建了一个新分区 6，类型为“Linux”，大小为 512 MiB。

命令(输入 m 获取帮助)：p
Disk /dev/sda：5 GiB，5368709120 字节，10485760 个扇区
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0x36b4735a

设备       启动    起点     末尾    扇区  大小 Id 类型
/dev/sda1          2048  4196351 4194304    2G 83 Linux
/dev/sda2       4196352  5244927 1048576  512M 83 Linux
/dev/sda3       5244928  6293503 1048576  512M 83 Linux
/dev/sda4       6293504 10485759 4192256    2G  5 扩展
/dev/sda5       6295552  7344127 1048576  512M 83 Linux
/dev/sda6       7346176  8394751 1048576  512M 83 Linux

# 刷新分区，立即生效
[root@localhost test]# partprobe /dev/sda

# 查看分区情况
[root@localhost ~]# lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0    5G  0 disk
├─sda1          8:1    0    2G  0 part
├─sda2          8:2    0  512M  0 part
├─sda3          8:3    0  512M  0 part
├─sda4          8:4    0    1K  0 part
├─sda5          8:5    0  512M  0 part
└─sda6          8:6    0  512M  0 part
sr0            11:0    1  6.6G  0 rom
nvme0n1       259:0    0   20G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   19G  0 part
  ├─rhel-root 253:0    0   17G  0 lvm  /
  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
```

#### 格式化逻辑分区

```bash
[root@localhost ~]# mkfs.ext4 /dev/sda5
mke2fs 1.44.3 (10-July-2018)
创建含有 131072 个块（每块 4k）和 32768 个inode的文件系统
文件系统UUID：88c04579-770a-4fec-914a-617f8687c247
超级块的备份存储于下列块：
        32768, 98304

正在分配组表： 完成
正在写入inode表： 完成
创建日志（4096 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

#### 挂载逻辑分区

```bash
[root@localhost ~]# mkdir /mnt/disk5
[root@localhost ~]# mount -t ext4 /dev/sda5 /mnt/disk5/
[root@localhost ~]# df -HT
文件系统              类型      容量  已用  可用 已用% 挂载点
devtmpfs              devtmpfs  932M     0  932M    0% /dev
tmpfs                 tmpfs     947M     0  947M    0% /dev/shm
tmpfs                 tmpfs     947M  9.9M  938M    2% /run
tmpfs                 tmpfs     947M     0  947M    0% /sys/fs/cgroup
/dev/mapper/rhel-root xfs        19G  5.3G   13G   30% /
/dev/nvme0n1p1        xfs       1.1G  177M  887M   17% /boot
tmpfs                 tmpfs     190M   17k  190M    1% /run/user/42
tmpfs                 tmpfs     190M  4.1k  190M    1% /run/user/0
/dev/sda5             ext4      512M  799k  474M    1% /mnt/disk5
```

### 交换分区

当内存不足时，系统会从硬盘中扩展一小部分空间出来做**虚拟空间**，以加快磁盘的读写速度

#### 创建主分区

```bash
# 创建一个主分区
[root@localhost ~]# fdisk /dev/sdb

欢迎使用 fdisk (util-linux 2.32.1)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

设备不包含可识别的分区表。
创建了一个磁盘标识符为 0xc70d6529 的新 DOS 磁盘标签。

命令(输入 m 获取帮助)：n
分区类型
   p   主分区 (0个主分区，0个扩展分区，4空闲)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：p
分区号 (1-4, 默认  1): 1
第一个扇区 (2048-10485759, 默认 2048): +1024
值超出范围。
第一个扇区 (2048-10485759, 默认 2048):
上个扇区，+sectors 或 +size{K,M,G,T,P} (2048-10485759, 默认 10485759): +1024

创建了一个新分区 1，类型为“Linux”，大小为 512.5 KiB。

命令(输入 m 获取帮助)：w
分区表已调整。
将调用 ioctl() 来重新读分区表。
正在同步磁盘。
```

#### 格式化交换分区

```bash
[root@localhost ~]# mkswap /dev/sdb1
正在设置交换空间版本 1，大小 = 508 KiB (520192  个字节)
无标签，UUID=035447ca-1631-4d6b-99f8-71c471323f49
```

#### 挂载交换分区

```bash
[root@localhost ~]# swapon /dev/sdb1
[root@localhost ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1806        1031         309           3         464         610
Swap:          2048           8        2039
```

### 逻辑卷

将多块磁盘组成一个磁盘组，逻辑卷的创建会从磁盘组中划分空间，且逻辑卷可根据实际需求任意扩展大小

#### 创建物理卷

```bash
[root@localhost ~]# pvcreate /dev/sdb
  Physical volume "/dev/sdb" successfully created.
```

#### 创建逻辑卷组

```bash
[root@localhost ~]# vgcreate vg1 /dev/sdb
  Volume group "vg1" successfully created
```

#### 创建逻辑卷

```bash
[root@localhost ~]# lvcreate -L 512M -n test vg1
  Logical volume "test" created.
```

#### 格式化磁盘

```bash
[root@localhost ~]# mkfs.ext4 /dev/vg1/test
mke2fs 1.44.3 (10-July-2018)
创建含有 131072 个块（每块 4k）和 32768 个inode的文件系统
文件系统UUID：1b869d1a-ec26-4e7d-b1e5-79fab5c607c9
超级块的备份存储于下列块：
        32768, 98304

正在分配组表： 完成
正在写入inode表： 完成
创建日志（4096 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

#### 创建并挂载磁盘

```bash
[root@localhost ~]# mkdir /mnt/test
[root@localhost ~]# mount /dev/vg1/test /mnt/test/
[root@localhost ~]# df -hT
文件系统              类型      容量  已用  可用 已用% 挂载点
devtmpfs              devtmpfs  889M     0  889M    0% /dev
tmpfs                 tmpfs     904M     0  904M    0% /dev/shm
tmpfs                 tmpfs     904M  9.4M  894M    2% /run
tmpfs                 tmpfs     904M     0  904M    0% /sys/fs/cgroup
/dev/mapper/rhel-root xfs        17G  5.0G   13G   30% /
/dev/nvme0n1p1        xfs      1014M  169M  846M   17% /boot
tmpfs                 tmpfs     181M   16K  181M    1% /run/user/42
tmpfs                 tmpfs     181M  4.0K  181M    1% /run/user/0
/dev/sda1             ext4      2.0G  6.0M  1.8G    1% /newDisk
/dev/mapper/vg1-test  ext4      488M  780K  452M    1% /mnt/test
```

## 文件系统详解

### EXT4文件系统

文件系统分为三部分：

+ 索引（inode）
  + 记录文件的属性
  + 一个文件占用一个inode，同时记录着此文件数据所在的blck number
  + inode 大小为 128byte
+ 块大小（block）
  + 存储文件的实际数据
  + 实际存储文件的内容，若文件叫大，则占用多个block
  + block大小默认为4K
+ 超级块（superblock）
  + block 与 inode 的总量
  + 为使用与已使用的 inode / block 数量

### 链接方式

#### 软链接

Linux软链接先当于Windows的快捷方式，记录的是文件的**绝对路径**，即能对文件做，也能做目录做

##### 演示

```bash
[root@localhost ~]# ln -s log/ /root/桌面/
[root@localhost 桌面]# ll
总用量 0
lrwxrwxrwx. 1 root root 4 7月   4 08:58 log -> log/
```

#### 硬链接

硬链接更像是一种备份的方式，即使删掉了源文件，硬链接也不会受到影响，只能对**同分区**下的文件做，不能对目录做

##### 演示

```bash
[root@localhost 桌面]# ln /root/test/1.txt 1-h.txt
[root@localhost 桌面]# ll
总用量 4
-rw-r--r--. 2 root root 18 6月  28 23:37 1-h.txt
```

### RAID

常用的RAID有RAID0，RAID1，RAID5

+ RAID0：至少用有两块磁盘，将数据分开写到磁盘中，后续数据的读取会从这些磁盘中一起读取，以达到200%的速率（速度最快，但是没有容错，利用率：100%）
+ RAID1：也叫镜像盘，至少有两块磁盘组成，一块做数据盘，一块做镜像盘（速度最慢，容错最高，利用率：%50）
+ RAID5：至少由3块磁盘组成，将数据平均写入磁盘中并在每块磁盘上保留一定的位置做备份（速度较快，容错较高，利用率：n/n-1）

##### 演示

```bash
# 创建RIAD5盘
[root@localhost ~]# mdadm -C /dev/md0 -l5 -n3 -x1 /dev/sd{a..d}
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
[root@localhost ~]# lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINT
sda             8:0    0    1G  0 disk
└─md0           9:0    0    2G  0 raid5
sdb             8:16   0    1G  0 disk
└─md0           9:0    0    2G  0 raid5
sdc             8:32   0    1G  0 disk
└─md0           9:0    0    2G  0 raid5
sdd             8:48   0    1G  0 disk
└─md0           9:0    0    2G  0 raid5
sr0            11:0    1  6.6G  0 rom
nvme0n1       259:0    0   20G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part  /boot
└─nvme0n1p2   259:2    0   19G  0 part
  ├─rhel-root 253:0    0   17G  0 lvm   /
  └─rhel-swap 253:1    0    2G  0 lvm   [SWAP]
  
# 格式化磁盘
[root@localhost ~]# mkfs.ext4 /dev/md0
mke2fs 1.44.3 (10-July-2018)
创建含有 523264 个块（每块 4k）和 130816 个inode的文件系统
文件系统UUID：645e1c44-87d8-4764-a038-0be6d63cfc77
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376, 294912

正在分配组表： 完成
正在写入inode表： 完成
创建日志（8192 个块）完成
写入超级块和文件系统账户统计信息： 已完成

# 挂载磁盘
[root@localhost ~]# mkdir /mnt/raid5
[root@localhost ~]# mount /dev/md0 /mnt/raid5/
```

## 查找和压缩

#### 查找

##### `which`查找命令

返回命令的绝对路径

###### 选项

```shell
-n<文件名长度>：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；
-p<文件名长度>：与-n参数相同，但此处的<文件名长度>包含了文件的路径；
-w：指定输出时栏位的宽度；
-V：显示版本信息。
```

###### 演示

```bash
[root@localhost ~]# which ls
alias ls='ls --color=auto'
        /usr/bin/ls
[root@localhost ~]# which cat
/usr/bin/cat
```

##### `find`查找文件

返回文件的绝对路径

###### 选项

```shell
-amin<分钟>：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
-anewer<参考文件或目录>：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
-atime<24小时数>：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
-cmin<分钟>：查找在指定时间之时被更改过的文件或目录；
-cnewer<参考文件或目录>查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
-ctime<24小时数>：查找在指定时间之时被更改的文件或目录，单位以24小时计算；
-daystart：从本日开始计算时间；
-depth：从指定目录下最深层的子目录开始查找；
-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；
-exec<执行指令>：假设find指令的回传值为True，就执行该指令；
-false：将find指令的回传值皆设为False；
-fls<列表文件>：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
-follow：排除符号连接；
-fprint<列表文件>：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；
-fprint0<列表文件>：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；
-fprintf<列表文件><输出格式>：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
-fstype<文件系统类型>：只寻找该文件系统类型下的文件或目录；
-gid<群组识别码>：查找符合指定之群组识别码的文件或目录；
-group<群组名称>：查找符合指定之群组名称的文件或目录；
-help或--help：在线帮助；
-ilname<范本样式>：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；
-iname<范本样式>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；
-inum<inode编号>：查找符合指定的inode编号的文件或目录；
-ipath<范本样式>：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；
-iregex<范本样式>：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；
-links<连接数目>：查找符合指定的硬连接数目的文件或目录；
-lname<范本样式>：指定字符串作为寻找符号连接的范本样式；
-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；
-maxdepth<目录层级>：设置最大目录层级；
-mindepth<目录层级>：设置最小目录层级；
-mmin<分钟>：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
-mount：此参数的效果和指定“-xdev”相同；
-mtime<24小时数>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；
-name<范本样式>：指定字符串作为寻找文件或目录的范本样式；
-newer<参考文件或目录>：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
-nogroup：找出不属于本地主机群组识别码的文件或目录；
-noleaf：不去考虑目录至少需拥有两个硬连接存在；
-nouser：找出不属于本地主机用户识别码的文件或目录；
-ok<执行指令>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；
-path<范本样式>：指定字符串作为寻找目录的范本样式；
-perm<权限数值>：查找符合指定的权限数值的文件或目录；
-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；
-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；
-printf<输出格式>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；
-prune：不寻找字符串作为寻找文件或目录的范本样式;
-regex<范本样式>：指定字符串作为寻找文件或目录的范本样式；
-size<文件大小>：查找符合指定的文件大小的文件；
-true：将find指令的回传值皆设为True；
-type<文件类型>：只寻找符合指定的文件类型的文件；
-uid<用户识别码>：查找符合指定的用户识别码的文件或目录；
-used<日数>：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；
-user<拥有者名称>：查找符和指定的拥有者名称的文件或目录；
-version或——version：显示版本信息；
-xdev：将范围局限在先行的文件系统中；
-xtype<文件类型>：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。
```

###### 演示

```bash
# find 路径 选项 文件名
[root@localhost ~]# find /etc -name "hosts"
/etc/hosts
/etc/avahi/hosts

# -iname 不区分大小写
[root@localhost ~]# find /etc/ -iname "HOSTS"
/etc/hosts
/etc/avahi/hosts

# 查找 /etc 文件下大小大于2M的文件
[root@localhost ~]# find /etc/ -size +2M
/etc/selinux/targeted/policy/policy.31
/etc/udev/hwdb.bin

# 查找 /etc /文件夹下4层目录的文件 -a：and
[root@localhost ~]# find / -maxdepth 4 -a -name "ifcfg-en*"
/etc/sysconfig/network-scripts/ifcfg-ens160

# 查找属主和属组都是user01的文件 -user：指定用户；-group：指定组
[root@localhost ~]# find . -user "user01" -a -group "user01"
./test
./test/passwd.bak
./test/passwd
./test/aaa
./test/aaa/nnn
./test/nnn
./test/a2
./test/a1.txt

# 按文件类型查找；f：普通文件，b：设备文件；d：目录；l：链接文件
[root@localhost ~]# find . -type f |head -1
./.bash_logout

# 按文件权限查找 -per 文件qu
[root@localhost ~]# find . -perm 644 |head -1
./.bash_logout

```

## 软件安装

### `yum`

yum命令两大优势：

+ 自动下载
+ 自动处理依赖

#### 本地源配置

##### 挂载镜像文件

```bash
[root@localhost yum.repos.d]# mount /dev/cdrom /media/
mount: /media: WARNING: device write-protected, mounted read-only.
```

##### 编辑本地源配置文件

```bash
[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo
[BaseOS]								# 仓库名
name=BaseOS								# 描述
baseurl=file:///media/BaseOS			# 本地仓库路径
gpgcheck=0								# 是否开启校验，如果这里开启了，那么就要加上响应的校验地址
enabled=1								# 是否启用该仓库

[rhel8-AppStream]
name=AppStream
baseurl=file:///media/AppStream
gpgcheck=0
enabled=1
```

##### 安装程序

```bash
# 安装程序
yum -y install httpd
# 卸载成勋
yun -y remove httpd
```

### `rpm`

rpm相比yum最大的缺点是**无法处理依赖关系**

```bash
# -i：安装程序
[root@localhost Packages]# rpm -ivh  wget-1.19.5-7.el8.x86_64.rpm
警告：wget-1.19.5-7.el8.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID fd431d51: NOKEY
Verifying...                          ################################# [100%]
准备中...                          ################################# [100%]
        软件包 wget-1.19.5-7.el8.x86_64 已经安装
# -q：显示是否已安装
[root@localhost Packages]# rpm -q  wget-1.19.5-7.el8.x86_64.rpm
警告：wget-1.19.5-7.el8.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID fd431d51: NOKEY
wget-1.19.5-7.el8.x86_64
[root@localhost Packages]#
[root@localhost Packages]# rpm -q wget
wget-1.19.5-7.el8.x86_64

# 删除程序
[root@localhost Packages]# rpm -evh wget
准备中...                          ################################# [100%]
正在清理/删除...
   1:wget-1.19.5-7.el8                ################################# [100%]

```

### 源码安装

以`Tnginx`为例

#### 安装编译软件

```bash
[root@localhost tengine-2.3.3]# yum install gcc make zlib-devel pcre pcre-devel openssl-devel
```

#### 下载

```bash
[root@localhost ~]# wget https://tengine.taobao.org/download/tengine-2.3.3.tar.gz
--2023-07-05 10:00:46--  https://tengine.taobao.org/download/tengine-2.3.3.tar.gz
正在解析主机 tengine.taobao.org (tengine.taobao.org)... 59.82.23.207, 2408:4001:f00::18c, 2408:4001:f00::3                                                                                                    08, ...
正在连接 tengine.taobao.org (tengine.taobao.org)|59.82.23.207|:443... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度：2848144 (2.7M) [application/octet-stream]
正在保存至: “tengine-2.3.3.tar.gz”

tengine-2.3.3.tar.gz       100%[======================================>]   2.72M  1.04MB/s  用时 2.6s

2023-07-05 10:00:50 (1.04 MB/s) - 已保存 “tengine-2.3.3.tar.gz” [2848144/2848144])
```

#### 解压

```bash
[root@localhost ~]# tar -xf tengine-2.3.3.tar.gz
```

#### 配置

```bash
[root@localhost tengine-2.3.3]# ./configure --user=www --group=www --prefix=/usr/local/nginx
```

#### 编译

```bash
[root@localhost tengine-2.3.3]# make
```

#### 安装

```bash
[root@localhost tengine-2.3.3]# make install
```

#### 启动

```bash
[root@localhost tengine-2.3.3]# /usr/local/nginx/sbin/nginx
```

## 任务计划

### 查看定时任务

```bash
# 在6月7日的9点删除用户 aaa
[root@localhost ~]# crontab -l
0 9 7 6 * userdel aaa
```

### `at` 制定临时任务

```shell
at [-V] [-q 队列] [-f 文件] [-mldbv] 时间 at -c 作业 [作业...]
```

#### 选项

```shell
-f：指定包含具体指令的任务文件；
-q：指定新任务的队列名称；
-l：显示待执行任务的列表；
-d：删除指定的待执行任务；
-m：任务执行完成后向用户发送E-mail。
```

#### 示例

```bash
# 在2分钟后执行 ls 命令
[root@localhost ~]# at now +2min
warning: commands will be executed using /bin/sh
at> ls
at> <EOT>
job 2 at Thu Jul  6 08:48:00 2023

# 明天的 5:20 执行任务
[root@localhost ~]# at 17:20 tomorrow
at> date >/root/2013.log
at> <EOT>
job 8 at 2013-01-06 17:20
```

#### 查看临时任务表

```bash
[root@localhost ~]# atq
3       Thu Jul  6 08:53:00 2023 a root
```

### `crontab` 指定循环任务

```shell
crontab(选项)(参数)
```

#### 选项

```shell
-e：编辑该用户的计时器设置；
-l：列出该用户的计时器设置；
-r：删除该用户的计时器设置；
-u<用户名称>：指定要设定计时器的用户名称。
```



```shell
minute   hour   day   month   week   command     顺序：分 时 日 月 周
```

其中：

- minute： 表示分钟，可以是从0到59之间的任何整数。
- hour：表示小时，可以是从0到23之间的任何整数。
- day：表示日期，可以是从1到31之间的任何整数。
- month：表示月份，可以是从1到12之间的任何整数。
- week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。
- command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。

#### 示例

每1分钟执行一次command

```shell
* * * * * command
```

每小时的第3和第15分钟执行

```shell
3,15 * * * * command
```

在上午8点到11点的第3和第15分钟执行

```shell
3,15 8-11 * * * command
```

每隔两天的上午8点到11点的第3和第15分钟执行

```shell
3,15 8-11 */2 * * command
```

每个星期一的上午8点到11点的第3和第15分钟执行

```shell
3,15 8-11 * * 1 command
```

每晚的21:30重启smb 

```shell
30 21 * * * /etc/init.d/smb restart
```

## 日志管理

### 常规日志

```
/var/log/message		# 系统主日志文件
/var/log/secure			# 认证、安全相关文件，记录用户切换，SSH等操作
/var/log/yum.log		# yum的日志文件
/var/log/maillog		# 与邮件相关的日志
/var/log/cron			# cron、at进程产生的日志
/var/log/dmesg			# 和系统启动相关日志文件
```

小提示：

使用整个终端来查看日志

```bash
[root@localhost ~]# tail -f /var/log/messages
```

### `rsyslog`服务

格式：`设备.级别`

在`rsysfu`服务用于记录大部分系统服务的日志文件路径

```bash
[root@localhost ~]# vim /etc/rsyslog.conf
#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;authpriv.none;cron.none                /var/log/messages

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 :omusrmsg:*

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log
```

#### 服务名称

我们首先需要确定 rsyslogd 服务可以识别哪些服务的日志，也可以理解为以下这些服务委托 rsyslogd 服务来代为管理日志。这些服务如表 1 所示。

| 服务名称                     | 说 明                                                        |
| ---------------------------- | ------------------------------------------------------------ |
| auth(LOG AUTH)               | 安全和认证相关消息 (不推荐使用authpriv替代）                 |
| authpriv(LOG_AUTHPRIV)       | 安全和认证相关消息（私有的）                                 |
| cron (LOG_CRON)              | 系统定时任务cront和at产生的日志                              |
| daemon (LOG_DAEMON)          | 与各个守护进程相关的曰志                                     |
| ftp (LOG_FTP)                | ftp守护进程产生的曰志                                        |
| kern(LOG_KERN)               | 内核产生的曰志（不是用户进程产生的）                         |
| Iocal0-local7 (LOG_LOCAL0-7) | 为本地使用预留的服务                                         |
| lpr (LOG_LPR)                | 打印产生的日志                                               |
| mail (LOG_MAIL)              | 邮件收发信息                                                 |
| news (LOG_NEWS)              | 与新闻服务器相关的日志                                       |
| syslog (LOG_SYSLOG)          | 存syslogd服务产生的曰志信息（虽然服务名称己经改为reyslogd，但是很多配罝依然沿用了 syslogd服务的，所以这里并没有修改服务名称） |
| user (LOG_USER)              | 用户等级类别的日志信息                                       |
| uucp (LOG_UUCP>              | uucp子系统的日志信息，uucp是早期Linux系统进行数据传递的协议，后来 也常用在新闻组服务中 |

#### 日志等级

| 等级名称             | 说 明                                                        |
| -------------------- | ------------------------------------------------------------ |
| debug (LOG_DEBUG)    | 一般的调试信息说明                                           |
| info (LOG_INFO)      | 基本的通知信息                                               |
| nolice (LOG_NOTICE)  | 普通信息，但是有一定的重要性                                 |
| warning(LOG_WARNING) | 警吿信息，但是还不会影响到服务或系统的运行                   |
| err(LOG_ERR)         | 错误信息, 一般达到err等级的信息已经可以影响到服务成系统的运行了 |
| crit (LOG_CRIT)      | 临界状况信思，比err等级还要严®                               |
| alert (LOG_ALERT)    | 状态信息，比crit等级还要严重，必须立即采取行动               |
| emerg (LOG_EMERG)    | 疼痛等级信息，系统已经无法使用了                             |
| *                    | 代表所有日志等级。比如，“authpriv.*”代表amhpriv认证信息服务产生的日志，所有的日志等级都记录 |

#### priority格式：
  指定日志的优先级

```makefile
*: 所有级别
none：没有级别，即不记录
PRIORITY：指定级别（含）以上的所有级别
=PRIORITY：仅记录指定级别的日志信息
```

### 日志轮转

日志会随着服务的使用而无限增长，所以系统会自动将日志文件按规则切割并保存，且将日期久远的日志文件自动删除，以达到节省硬盘空间资源的目的

#### 配置文件

```bash
[root@localhost ~]# vim /etc/logrotate.conf
# rotate log files weekly
weekly															# 按周轮转，每星期都做一次切割

# keep 4 weeks worth of backlogs
rotate 4														# 保留4份日志

# create new (empty) log files after rotating old ones
create															# 切割后创建新的日志文件，后续的日志写到这个文件中

# use date as a suffix of the rotated file
dateext															# 日志文件使用日期做后缀

# uncomment this if you want your log files compressed
#compress														# 是否压缩（不压缩）

# RPM packages drop log rotation information into this directory
include /etc/logrotate.d										# 包含子配置目录的文件


/var/log/boot.log
{
    missingok													# 丢失不提示
    daily														# 按天轮转
    copytruncate												# 在轮换时，通过复制和截断来处理日志文件，而不是重新创建它
    rotate 7													# 保留7份
    notifempty													# 空日志也轮转
}

```

## 网络管理

#### 网卡配置

Linux 网卡配置文件都在：`/etc/sysconfig/network-script/网卡名`中

```bash
[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens160 
TYPE=Ethernet									# 网卡类型
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=none									# 是要设置为手动（none）还是自动（DHCP）
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens160
UUID=cf8d4357-09f1-4d4d-8fbb-9ff370a288d4
DEVICE=ens160									# 设备名
ONBOOT=yes										# 是否开机自启
IPADDR=192.168.231.132							# IP 地址
NETMASK=255.255.255.0							# 掩码
GETWAY=192.168.231.254							# 网关
DNS1=8.8.8.8									# DNS
```

#### 主机名配置

主机名的配置可以修改配置文件`/etc/hostname`

```bash
[root@localhost ~]# vim /etc/hostname
localhost.localdomain

# 重启生效
[root@localhost ~]# reboot
```

#### `ss`命令查看端口号

比 netstat 好用的socket统计信息，iproute2 包附带的另一个工具，允许你查询 socket 的有关统计信息

##### 选项

```shell
-h, --help      帮助信息
-V, --version   程序版本信息
-n, --numeric   不解析服务名称
-r, --resolve   解析主机名
-a, --all       显示所有套接字（sockets）
-l, --listening 显示监听状态的套接字（sockets）
-o, --options   显示计时器信息
-e, --extended  显示详细的套接字（sockets）信息
-m, --memory    显示套接字（socket）的内存使用情况
-p, --processes 显示使用套接字（socket）的进程
-i, --info      显示 TCP内部信息
-s, --summary   显示套接字（socket）使用概况
-4, --ipv4      仅显示IPv4的套接字（sockets）
-6, --ipv6      仅显示IPv6的套接字（sockets）
-0, --packet    显示 PACKET 套接字（socket）
-t, --tcp       仅显示 TCP套接字（sockets）
-u, --udp       仅显示 UCP套接字（sockets）
-d, --dccp      仅显示 DCCP套接字（sockets）
-w, --raw       仅显示 RAW套接字（sockets）
-x, --unix      仅显示 Unix套接字（sockets）
-f, --family=FAMILY  显示 FAMILY类型的套接字（sockets），FAMILY可选，支持  unix, inet, inet6, link, netlink
-A, --query=QUERY, --socket=QUERY
      QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]
-D, --diag=FILE     将原始TCP套接字（sockets）信息转储到文件
 -F, --filter=FILE  从文件中都去过滤器信息
       FILTER := [ state TCP-STATE ] [ EXPRESSION ]
```

##### 演示

```bash
# 查看TCP服务的套接字
[root@localhost ~]# ss -tnl
State      Recv-Q       Send-Q              Local Address:Port              Peer Address:Port
LISTEN     0            32                  192.168.122.1:53                     0.0.0.0:*
LISTEN     0            128                       0.0.0.0:22                     0.0.0.0:*
LISTEN     0            5                       127.0.0.1:631                    0.0.0.0:*
LISTEN     0            128                     127.0.0.1:6010                   0.0.0.0:*
LISTEN     0            128                     127.0.0.1:6011                   0.0.0.0:*
LISTEN     0            128                       0.0.0.0:111                    0.0.0.0:*
LISTEN     0            128                          [::]:22                        [::]:*
LISTEN     0            5                           [::1]:631                       [::]:*
LISTEN     0            128                         [::1]:6010                      [::]:*
LISTEN     0            128                         [::1]:6011                      [::]:*
LISTEN     0            70                              *:33060                        *:*
LISTEN     0            128                             *:3306                         *:*
LISTEN     0            128                          [::]:111                       [::]:*
```

# Linux 安全基线

## 0x01 初始设置

### 1. 文件系统配置：

1.1 将/tmp挂载至一个单独的分区

1.2 /tmp挂载时指定`noexec`：不允许运行可执行文件

> 该选项使得/tmp目录下的二进制文件不可被执行

1.3 /tmp挂载时指定`nosuid`

> 该选项使得/tmp目录下的文件或目录不可设置Set-UID和Set-GID标志位，能够防止提权。

1.4 操作

```bash
# 创造新分区
[root@localhost ~]# fdisk /dev/sda

欢迎使用 fdisk (util-linux 2.32.1)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

设备不包含可识别的分区表。
创建了一个磁盘标识符为 0x5a581a5f 的新 DOS 磁盘标签。

命令(输入 m 获取帮助)：n
分区类型
   p   主分区 (0个主分区，0个扩展分区，4空闲)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：p
分区号 (1-4, 默认  1): 1
第一个扇区 (2048-10485759, 默认 2048):
上个扇区，+sectors 或 +size{K,M,G,T,P} (2048-10485759, 默认 10485759): +4G

创建了一个新分区 1，类型为“Linux”，大小为 4 GiB。

命令(输入 m 获取帮助)：w
分区表已调整。
将调用 ioctl() 来重新读分区表。
正在同步磁盘。

# 格式化分区
[root@localhost ~]# mkfs.ext4 /dev/sda1
mke2fs 1.44.3 (10-July-2018)
创建含有 1048576 个块（每块 4k）和 262144 个inode的文件系统
文件系统UUID：e05fed01-5a25-4a8f-8634-fa7f7b7dc1d6
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376, 294912, 819200, 884736

正在分配组表： 完成
正在写入inode表： 完成
创建日志（16384 个块）完成
写入超级块和文件系统账户统计信息： 已完成

# 挂载的同时使用 -o 选项指定挂载项
[root@localhost ~]# mount -o noexec,nosuid /dev/sda1 /tmp/

# 查看效果
[root@localhost ~]# mount |grep nosuid
/dev/sda1 on /tmp type ext4 (rw,nosuid,noexec,relatime,seclabel)
```

### 2. 安全启动设置：

2.1 设置bootloader的配置文件的权限为`600`

> 该配置文件包含了系统启动时的引导信息，该选项可防止该文件被随意读写。

```bash
[root@localhost ~]# chmod 600 /boot/grub2/grub.cfg
[root@localhost ~]# ll /boot/grub2/grub.cfg
-rw-------. 1 root root 4880 6月  11 15:37 /boot/grub2/grub.cfg
```

### 3. 强制访问控制：

3.1 安装SELinux 【建议】

3.2 设置SELinux的状态为`enforcing` 【建议】

```bash
[root@localhost ~]# setenforce 1
[root@localhost ~]# getenforce
Enforcing
```

## 0x03 网络配置

### 1. hosts设置：

1.1 配置`/etc/hosts.allow`文件

> 指定哪些IP可以连接到本主机

1.2 配置`/etc/hosts.deny`文件

1.3 配置`/etc/hosts.allow`文件权限为`0644`

1.4 配置`/etc/hosts.deny`文件的权限为`0644`

```
系统在接受一个客户端访问时，会先检查 /etc/hosts.allow，如果有，则允许访问，没有则检查 /etc/hosts.deny，如果有则拒绝访问，如果都没有，则默认允许访问
```

```bash
# 默认就是644
[root@localhost ~]# ll /etc/hosts*
-rw-r--r--. 1 root root 370 9月  10 2018 /etc/hosts.allow
-rw-r--r--. 1 root root 460 9月  10 2018 /etc/hosts.deny
```

```bash
# 写法

# 允许 192.168.1.100 访问SSH服务,可以在/etc/hosts.allow 中配置
sshd:192.168.1.100
vsftpd:192.168.1.100
```

### 2. 防火墙配置

2.1 安装`iptables`

2.2 设置各个`Chain`的默认策略为`drop`

```bash
# 将 iptables 的 filter 表的 INPUT链 策略设置为ju'j
[root@localhost ~]# iptables -t filter -P INPUT DROP
```

### 3. 配置SSH：

2.1 配置`/etc/ssh/sshd_config`文件的权限为`0600`

2.2 关闭`X11Forwarding`

> X11Forwarding用于图形转发

2.3 设置最大认证尝试次数：4

```bash
MaxAuthTries 4
```

2.4 开启`IgnoreRhosts`：不启用基于主机的认证

> 该选项决定通过RhostsRSAAuthentication或HostbasedAuthentication验证的时候是否使用.rhosts和.shosts文件

```
IgnoreRhosts yes

# 此选项为 yes 时，表示不基于主机认证，所谓主机认证，即服务器只校验客户端的：用户名、主机名以及IP地址是否正确
```

2.5 关闭`HostbasedAuthentication`: 关闭基于主机的认证

```
HostbasedAuthentication no
```

2.6 禁止使用root直接登录：`PermitRootLogin no`

2.7 禁止使用空密码登录：`PermitEmptyPasswords no`

2.8 禁止用户环境：`PermitUserEnvironment no`

> 该选项决定SSH是否可以使用环境变量，若启用，则可能通过LD_PRELOAD绕过安全限制

2.9 设置使用的MAC算法:

```sql
hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,umac-128etm@openssh.com,hmac-sha2-512,hmac-sha2-256,umac-128@openssh.com,curve25519sha256@libssh.org,diffie-hellman-group-exchange-sha256 
```

2.10 设置空闲超时时间:180秒`ClientAliveInterval 180`

```
ClientAliveInterval选项用于设置服务器端向客户端发送空数据包的时间间隔，以保持连接。如果您将其设置为180，则表示服务器每隔180秒向客户端发送一个空数据包。如果客户端在指定时间内没有响应，则服务器会认为连接已断开并关闭连接。但是，这个选项通常与另一个选项ClientAliveCountMax一起使用。ClientAliveCountMax选项用于设置服务器在关闭连接之前允许客户端未响应的最大次数。例如，如果您将ClientAliveInterval设置为180，将ClientAliveCountMax设置为3，则表示服务器每隔180秒向客户端发送一个空数据包，如果客户端连续3次未响应，则服务器将关闭连接。即：540秒（180秒*3）内未响应，则服务器将关闭连接
```

2.11 设置一次登录花费时间：120秒`LoginGraceTime 120`

```
用户一次登录的时间最多为120s，若120s内没完成登录操作，则断开连接
```

2.12 SSH LogLevel设置为`INFO` ，`LogLevel INFO`

```
记录了用户日志级别
```

2.13 SSH使用v2安全协议 :`Protocol 2`

2.14 设置能够同时连接到服务器的Client数量：3,`ClientAliveCountMax 3`

2.15 更改SSHD端口：10086，`Port 10086`

### 4. 用户账户和环境设置：

4.1 密码有效时间：90天

4.2 密码更改最短间隔：7天

4.3 密码过期警告：7天

```bash
[root@localhost ~]# vim /etc/login.defs
# 密码有效期
PASS_MAX_DAYS   99999
# 两次密码更改间隔
PASS_MIN_DAYS   0
PASS_MIN_LEN    5
# 密码过期警告
PASS_WARN_AGE   7
```

4.4 自动禁用特定时间内没有活动的账号：365天

4.5 配置系统账号的无法登录

```
usermod -s /sbin/nologin root
```

4.6 配置root账号默认群组的GID为0

```
usermod -g 0 root
```

4.7  配置shell超时关闭会话时间：900

4.8 配置可以使用`su`命令的用户

## 0x07 系统维护

### 1. 重要文件权限：

```bash
/etc/passwd 0644 uid 0 gid 0
/etc/shadow 0000 uid 0 gid 0
/etc/group 0644 uid 0 gid 0
/etc/gshadow 0000 uid 0 gid 0
/etc/passwd- 0644 uid 0 gid 0
/etc/shadow- 0000 uid 0 gid 0
/etc/group- 0644 uid 0 gid 0
/etc/gshadow- 0000 uid 0 gid 0
```

### 2. 用户和组设置：

2.1 不允许密码为空的账号

2.2 只允许root账号的UID为0

2.3 设置path环境变量中的目录只有`owner`可写，`group`及`other`都没有`w`的权限

2.4 设置所有用户都有家目录

> 若用户没有家目录，则登录如会进入/，并且没有写入文件的权限，也不会拥有环境变量

2.5 设置所有用户家目录的权限为`0750`

2.6 设置所有用户家目录的`owner`都为其自身

2.7 设置用户家目录内以`.`开头的文件，只有`owner`可写，`group`及`other`都没有`w`的权限

2.8 确保没有`.netrc,.rhosts,.forward`文件

2.9 确保所有在`/etc/passwd`中的组都在`/etc/group`

2.10 确保每个用户的UID都不同

2.11 确保每个组的GID都不同

2.12 确保用户名唯一

2.13 确保组名唯一
