

# Linux各个目录的作用

```bash
/：根目录，位于目录结构的最顶层，包含 Fedora 操作系统中所有的目录和文件。
/bin：又称为二进制目录，包含了那些供系统管理员和普通用户使用的重要 linux 命令的二进制映像。
/boot：存放启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。
/dev：存放与设备 (包括外设) 有关的文件。
/etc：存放所有系统管理所需要的配置文件和子目录。
/home：存放用户的主目录，每个用户都有自己的用户目录，位置为：/home/用户名。
/lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。 几乎所有的应用程序都需要用到这些共享库。
/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。
/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。
/opt：这是给主机额外安装软件所摆放的目录。 比如你安装一个ORACLE数据库则就可以放到这个目录下。 默认是空的。
/proc：这是一个虚拟文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件。 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
/root：该目录为系统管理员，也称作超级权限者的用户主目录。
/sbin：只有系统管理员能使用的程序和指令。
/tmp：这个目录是用来存放一些临时文件的。
/usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。
```



# 软件包类型

## 软件包安装方法

| 系统平台                  | 包类型 | 工具          | 在线安装 |
| ------------------------- | ------ | ------------- | -------- |
| RedHat/Centos/Fedora/SUSE | rpm    | rpm、rpmbuild | yum      |
| Ubantu/Debian             | deb    | dpkg          | apt      |



## 二进制包的选择

+ 找不到合适的，就安装更高一级版本的
+ el6兼容el5，el5无法安装el6

### 选择合适的CPU的架构

+ x8664包，只能安装在64位的系统上
+ i386,i586,i686的软件包可以安装在32和64位系统上
+ noarch表示这个软件包与硬件构架无关，可以通用
+ 32位系统不能安装64位包

## 认识源码包

+ 优点：
  + 可以在任意平台上预编译，编译出来的软件包非常适合所在机器
  + 可以在编译的时候，通过配置，对某些功能进行定义，开启或关闭相应的功能

+ 缺点
  + 安装麻烦
  + 卸载麻烦
  + 升级麻烦

### 源码包安装三部曲

```
-prefix=.. Directories to put files in/usr/local 软件家目录
-bindir=.. $prefix/bin 命令的目录
--etcdir=..$prefix/etc 配置文件的目录
--mandir=..$prefix/share/man man 文档路径
--locale=...$prefix/share/locale 语言编码
```

编译：

```
make （使用gcc编辑器进行编译）
```

安装：

```
make install 类似 rpm -ivh
```

# 网络配置

## 网卡配置文件

```bash
[root@samba ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens160
TYPE=Ethernet	# 设备类型
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp	# DHCP 自动获取IP地址; static 则是静态获取IP地址
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens160
UUID=2e64b198-d0fd-4c6d-925c-209b526df159
DEVICE=ens160
ONBOOT=yes	# yes 代表在开机后自动激活网卡：no 代表需要手动激活	
```

# yum源的配置和使用

## yum 源的介绍

yum源：软件包管理器，类似于360软件管家

在互联网上，有着许多的yum仓库原，如：阿里源、华为原等。我们要做的只需要配置好yum源文件，让yum自动寻找

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230517195635400.png" alt="image-20230517195635400" style="zoom:50%;" />

## 本地yum源配置

1. 挂载镜像文件

   **注意：勾选已连接**

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230517204710854.png" alt="image-20230517204710854" style="zoom: 67%;" />

```bash
[root@samba media]# df -h
'文件系统        容量  已用  可用 已用% 挂载点
devtmpfs        1.9G     0  1.9G    0% /dev
tmpfs           1.9G     0  1.9G    0% /dev/shm
tmpfs           1.9G   10M  1.9G    1% /run
tmpfs           1.9G     0  1.9G    0% /sys/fs/cgroup
/dev/nvme0n1p2  9.3G  139M  9.2G    2% /
/dev/nvme0n1p9  7.5G  3.6G  3.9G   49% /usr
/dev/nvme0n1p7  947M   40M  908M    5% /tmp
/dev/nvme0n1p5  7.5G  251M  7.2G    4% /var
/dev/nvme0n1p3  7.5G   86M  7.4G    2% /home
/dev/nvme0n1p1  495M  155M  341M   32% /boot
/dev/nvme0n1p8  500M   16K  500M    1% /boot/efi
tmpfs           376M   16K  376M    1% /run/user/42
tmpfs           376M  3.5M  373M    1% /run/user/0
/dev/sr0        6.7G  6.7G     0  100% /media	# 这里可以看到光盘已成功挂载到了 /media 目录
```



2. 通过挂在的方式将镜像文件挂载到本地一个空目录里

   ```bash
   [root@samba /]# mount /dev/cdrom /media/
   mount: /media: WARNING: device write-protected, mounted read-only.
   ```

   

3. 告诉yum工具去哪个仓库里找相应的软件包（配置yum文件）

   1）清空并备份环境：

   ```shell
   [root@samba yum.repos.d]# pwd
   /etc/yum.repos.d
   [root@samba yum.repos.d]# ls
   redhat.repo
   [root@samba yum.repos.d]# mkdir /backup
   [root@samba yum.repos.d]# mv *.repo /backup/
   ```

​		2）查看软件仓库名和软件仓库路径

```bash
# 由于光盘是挂载到了 /media 这个目录下面，所以我们需要在这里寻找光盘的软件仓库
[root@samba yum.repos.d]# ll /media/
总用量 48
dr-xr-xr-x. 4 root root  2048 4月   4 2019 AppStream	# 软件仓库1
dr-xr-xr-x. 4 root root  2048 4月   4 2019 BaseOS	# 软件仓库2
dr-xr-xr-x. 3 root root  2048 4月   4 2019 EFI
-r--r--r--. 1 root root  8266 3月   1 2019 EULA
-r--r--r--. 1 root root  1455 4月   4 2019 extra_files.json
-r--r--r--. 1 root root 18092 3月   1 2019 GPL
dr-xr-xr-x. 3 root root  2048 4月   4 2019 images
dr-xr-xr-x. 2 root root  2048 4月   4 2019 isolinux
-r--r--r--. 1 root root   103 4月   4 2019 media.repo
-r--r--r--. 1 root root  1669 3月   1 2019 RPM-GPG-KEY-redhat-beta
-r--r--r--. 1 root root  5134 3月   1 2019 RPM-GPG-KEY-redhat-release
-r--r--r--. 1 root root  1796 4月   4 2019 TRANS.TBL
```

3）编辑yum配置文件

```bash
[root@samba yum.repos.d]# pwd
/etc/yum.repos.d
[root@samba yum.repos.d]# vim ded.repo

[BaseOS]	# 软件仓库名（可随便写；不要有特殊符号）
name=BaseOS	# 描述信息（可随便写）
baseurl=file:///media/BaseOS	# 指定软件仓库的所在路径：/media/BaseOS
gpgcheck=0	# 是否开启数字签名验证
enabled=1	# 启动仓库

[AppStream]
name=AppStream
baseurl=file:///media/AppStream
gpgcheck=0
enabled=1
```

3. 安装测试

```bash
# 清空yum缓存
[root@samba yum.repos.d]# yum clean all 
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
12 文件已删除

# 创建yum缓存
[root@samba yum.repos.d]# yum makecache
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream                                                                                                                                                                     213 MB/s | 5.3 MB     00:00
BaseOS                                                                                                                                                                        264 MB/s | 2.2 MB     00:00
上次元数据过期检查：0:00:01 前，执行于 2023年05月17日 星期三 09时08分41秒。
元数据缓存已建立。
```

# 服务概述

## 一、服务概述

+ 运行在操作系统后台的一个或者多个程序，为系统或者用户提供特定的服务
+ 可靠的、并发的、连续的不间断的运行，随时接受请求
+ 通过交互式提供服务

## 二、Linux下两大服务

### 1.独立服务

+ 独立的进程和独立的启动脚本
+ 启动方式：`systemcrl start serverName`

正是因为带有独立的脚本，所以可以直接使用`systemctl`控制

### 2.依赖服务

+ 没有毒瘤的启动服务，以来于xinetd服务（xinted服务本身是一个独立的服务）
+ 启动方式：`必须启动xinetd服务`

#### 什么是xinetd服务？

+ Extended internet daemon(扩展的网络守护进程)，又叫超级Internet)服务，常用来管理多种轻量级Internet)服务；
+ 作用：唤醒在睡觉的服务，由xinetd管理的服务只有在用到的时候才被唤醒，平时不占用系统资源：支
  持Tcp_Wrappers一种安全策略机制。

#### TCP_Wrappers简介：

TCP_Wrappers.是一个工作在应用层的安全工具，它只能针对某些具体的应用或者服务起到一定的防护作用。比如说ssh FTP等服务的请求，都会先受到TCP_Wrapperst的拦截。

# SSH服务

### SSH登录方式

+ 基于密码认证

  1. Client 向 Server 发起请求
  2. Server 向 Client 发送公钥
  3. Client 使用 Server 发送的公钥加密密码
  4. Server 使用私钥解密密码并判断密码是否正确
  5. 返回登录结果

  + 这种方法无法防御中间人攻击。在第一次登录的时候，会询问是否登录该SSH服务器

+ 基于密钥对登录（免密码）

  1. Client 在本地生成一对非对称密码
  2. Client 将公钥传给 Server
  3. Client 向 Server 发起 SSH 请求，并发送 Client 的公钥
  4. Server 比对 Client 的公钥与一开始发送的是否一致
  5. 一致则生成一串随机字符串并使用 Client 的公钥加密发给 Client
  6. Client 使用私钥解密处随机字符串并发给Server
  7. Server 验证字符串是否正确，并返回登录结果

### SSH密钥对登录配置流程

#### 1.Client 本地生成密钥对

```bash
# 客户端在本地生成密钥对
[root@samba ~]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):	# 保存密钥对的文件路径
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:+D8pmNd+esDiEi+R2uK3oVpAjQMYX9byIj0h6paDnZk root@samba.server
The key's randomart image is:
+---[RSA 2048]----+
|+.  o.           |
|.o.=o .          |
| .=o.+           |
|....+ ..         |
|o.o= o..S.       |
|.=E.  +.. o      |
|. . .o.B.o o     |
|   .o.B.=.+ o    |
|  .ooo.= o+=     |
+----[SHA256]-----+

[root@samba ~]# ll .ssh/
总用量 8
-rw-------. 1 root root 1823 5月  18 07:55 id_rsa	# 私钥
-rw-r--r--. 1 root root  399 5月  18 07:55 id_rsa.pub	# 公钥
```

#### 2.Client 上传公钥到Server端

> 上传到哪个用户的家目录，在SSH的时候就会以那个用户身份登录

```bash
# ssh-copy-id -i 公钥文件路径 登录用户@IP地址
[root@samba ~]# ssh-copy-id -i .ssh/id_rsa.pub root@192.168.231.129
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: ".ssh/id_rsa.pub"
The authenticity of host '192.168.231.129 (192.168.231.129)' can't be established.
ECDSA key fingerprint is SHA256:LHhmaYmTXaGoJIUQTKG4VyD32CHbyrM6mbPdVMR6wS8.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.231.129's password:

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@192.168.231.129'"
and check to make sure that only the key(s) you wanted were added.
```

#### 3.测试登录

登录成功！不需要密码

```bash
[root@samba ~]# ssh root@192.168.231.129
Activate the web console with: systemctl enable --now cockpit.socket
```

### SSH安全配置

#### 禁止root用户登录

​	了解软件相关知识

```bash
[root@samba ~]# rpm -ql openssh-server
/etc/ssh/sshd_config	# 配置文件
/usr/sbin/sshd	# 二进制命令
```

修改配置文件

```bash
[root@samba ~]# vim /etc/ssh/sshd_config
#LoginGraceTime 2m
#PermitRootLogin yes
PermitRootLogin no
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

# 重启服务
[root@samba ~]# systemctl restart sshd.service
```

#### 修改默认端口号

```bash
[root@samba ~]# vim /etc/ssh/sshd_config
#Port 22
Port 10022
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

# 重启服务
[root@samba ~]# systemctl restart sshd.service
```

修改端口号之后，需要做以下操作才能保证SSH正常服务

1. 连接SSH的时候增加 -p 参数指定端口号
2. 防火墙允许 10022 端口号通过

# DHCP 服务器配置

## 软件安装

### 查看软件包名

```bash
[root@samba ~]# yum list |grep dhcp
dhcp-client.x86_64                                   12:4.3.6-30.el8                                   @anaconda
dhcp-common.noarch                                   12:4.3.6-30.el8                                   @anaconda
dhcp-libs.x86_64                                     12:4.3.6-30.el8                                   @anaconda
dhcp-libs.i686                                       12:4.3.6-30.el8                                      BaseOS
dhcp-relay.x86_64                                    12:4.3.6-30.el8                                      BaseOS
dhcp-server.x86_64                                   12:4.3.6-30.el8                                      BaseOS
```

### 安装软件包

```bash
[root@samba ~]# yum -y install dhcp-server.x86_64
```

### 查看服务相关文件

```
[root@samba ~]# rpm -ql dhcp-server.x86_64
/etc/dhcp
/etc/dhcp/dhcpd.conf	# 配置文件
/usr/sbin/dhcpd	# 二进制命令
```

### 编辑配置文件

```bash
[root@samba ~]# cat /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp-server/dhcpd.conf.example	# DHCP服务配置参考这个文件
#   see dhcpd.conf(5) man page

option domain-name "itcast.cc";		# 域名配置（可选）
option domain-name-servers 114.114.114.114, 8.8.8.8;		# DNS服务器地址（可选）
default-lease-time 3600;	# 缺省租约
max-lease-time 7200;		# 客户端最大租约
log-facility local7;		# 定义日志设备载体（/var/log/boot.log 输出）

subnet 192.168.231.0 netmask 255.255.255.0 {	# 子网<掩码>
    range 192.168.231.1 192.168.231.100;		# IP 地址池范围
    option routers 192.168.231.129;				# 默认网关
    option broadcast-address 192.168.231.255;	# 广播地址
}
```

缺省租约和客户端最大租约介绍：

​	当客户端的 缺省租约 到期之后，就应该向服务器进行IP地址的续期。如果客户端没有这么做，那么最多到 客户端最大租约 时间，IP地址就会失效，服务器就会回收IP地址

# FTP服务配置

> 匿名用户的家目录默认在：/var/ftp

## 软件安装-Server

### 安装vsftpd

```bash
[root@samba ~]# yum install -y vsftpd
```

### 了解文件列表

```bash
[root@samba ~]# rpm -ql vsftpd
/etc/logrotate.d/vsftpd	# 日志轮转文件
/etc/pam.d/vsftpd		# 安全认证相关文件
/etc/vsftpd				# 配置文件主目录
/etc/vsftpd/ftpusers	# 用户列表文件（黑名单）
/etc/vsftpd/user_list	# 用户列表文件（黑名单|可黑可白）
/etc/vsftpd/vsftpd.conf	# 主配置文件	
/usr/share/doc/vsftpd/EXAMPLE/VIRTUAL_HOSTS/README		# 虚拟主机
/usr/share/doc/vsftpd/EXAMPLE/VIRTUAL_USERS/README		# 虚拟用户
/usr/share/man/man5/vsftpd.conf.5.gz					# 帮助手册
/usr/share/man/man8/vsftpd.8.gz
```

### 认识配置文件

```bash
[root@samba ~]# grep -v ^# /etc/vsftpd/vsftpd.conf
anonymous_enable=NO		# 支持匿名用户访问
local_enable=YES		# 非匿名用户访问
write_enable=YES		# 是否可写
local_umask=022			# 反掩码	file:644（666）	dir:755（777）
dirmessage_enable=YES	# 启用消息功能（banner）
xferlog_enable=YES		# 启用 xferlog 日志格式
connect_from_port_20=YES	# 支持主动模式（默认是被动模式）；RHEL8 还在使用 xinetd 来管理服务
xferlog_std_format=YES		# xferlog 日志模式
listen=NO					# ftp服务独立模式下的监听
listen_ipv6=YES

pam_service_name=vsftpd		# 必须与 /etc/pam.d/vsftpd 文件名保持一致
userlist_enable=YES			# 启用用户列表
```

### 赋予权限

```bash
chmod o+w /var/ftp/pub/
```

### 防火墙允许FTP服务通过

```bash
[root@samba ~]# firewall-cmd --permanent --add-service=ftp
success
[root@samba ~]# firewall-cmd --reload
success
[root@samba ~]# firewall-cmd --list-all |grep ftp
  services: cockpit dhcpv6-client ftp ssh
```

### 启动服务并开机自启

```bash
[root@samba ~]# systemctl start vsftpd.service
[root@samba ~]# systemctl enable vsftpd.service
Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /usr/lib/systemd/system/vsftpd.service.
# 查看端口状态
[root@samba ~]# netstat -nltp|grep 21
tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      2181/dnsmasq
tcp6       0      0 :::21                   :::*                    LISTEN      36258/vsftpd
```

## 软件安装-Client

```bash
[root@samba ~]# yum -y install ftp lftp		# 可以只安装 ftp
```

### 客户端登录

```bash
Name (192.168.231.128:root): ftp
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
```

## 开启本地用户消息功能

> 在哪个用户家目录创建消息文件，哪个用户在登录的时候就会显示消息

### 配置文件开启消息功能

```bash
[root@localhost ~]# grep -v ^# 
dirmessage_enable=YES
```

### 在用户家目录创建消息文件

匿名用户~

```bash
[root@localhost ~]# echo "welcome to anon home" > /var/ftp/.message
```

### 客户端访问

```bash
[root@samba ~]# ftp 192.168.231.130
Connected to 192.168.231.130 (192.168.231.130).
220 (vsFTPd 3.0.3)
Name (192.168.231.130:root): ftp
331 Please specify the password.
Password:
230-welcome to anon home
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
```

## 案例

### 1）允许匿名用户上传文件，并且可以下载其他用户上传的文件

```bash
[root@localhost vsftpd]# vim vsftpd.conf
# Allow anonymous FTP? (Beware - allowed by default if you comment this out).
anonymous_enable=yes		# 允许匿名登录
anon_upload_enable=YES		# 允许匿名上传
anon_umask=022				# 允许匿名用户上传文件
```

### 2）匿名用户上传的文件都保存在 /anon/data 里

```bash
[root@localhost ~]# mkdir /anon/data
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
anon_root=/anon/data		# 匿名用户的根目录设置
[root@localhost /]# chmod 555 /data/pub/		# 预防500错误
```

### 3）本地用户上传的文件都保存到 /local/data 里

```bash
[root@localhost ~]# mkdir /local
[root@localhost ~]# mkdir /local/data
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
local_root=/local/data		# 本地用户根目录设置
```

### 4）禁止用户访问其他用户的家目录

```bash
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
# chroot)
chroot_local_user=YES
```

## FTP访问控制

### 禁止用户访问

要禁止哪个用户访问FTP服务器，就把哪个用户添加到这里就好

```bash
[root@localhost ~]# cat /etc/vsftpd/ftpusers
# Users that are not allowed to login via ftp
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
news
uucp
operator
games
nobody
```

## FTP虚拟用户

### 1、创建虚拟用户

密码文件格式：

​	username

​	password

```bash
[root@localhost ~]# mkdir /vftp
[root@localhost ~]# vim /vftp/vuser.txt
user2
123456
```

### 2、生成数据库文件

文本文件的密码格式无法被系统直接调用，所以需要使用`db_load`生成数据库文件

```bash
[root@localhost ~]# db_load -T -t hash -f /vftp/vuser.txt /vftp/vuser.db
[root@localhost ~]# ls /vftp/
vuser.db  vuser.txt
```

### 3、配置 PAM 文件

为了使服务器能够使用数据库文件，对客户端进行身份验证，需要调用系统的PAM模块；该目录下保存这大量与认证相关的配置文件

```
auth required pam_userdb.so db=/vftp/vuser 
这一行指定了 pam_userdb.so 模块对于身份验证是必需的，并且应使用位于 /vftp/vuser 的数据库进行查找。

account required pam_userdb.so db=/vftp/vuser 
这一行指定了 pam_userdb.so 模块对于帐户管理是必需的，并且应使用位于 /vftp/vuser 的相同数据库。
```



```bash
[root@localhost pam.d]# cd /etc/pam.d
[root@localhost pam.d]# cp vsftpd vsftpd.bak
[root@localhost pam.d]# vim vsftpd
#%PAM-1.0
#session    optional     pam_keyinit.so    force revoke
#auth       required    pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed
#auth       required    pam_shells.so
#auth       include     password-auth
#account    include     password-auth
#session    required     pam_loginuid.so
#session    include     password-auth
auth            required                pam_userdb.so           db=/vftp/vuser
account         required                pam_userdb.so           db=/vftp/vuser
```

### 4、创建虚拟账户对应账户

```bash
[root@localhost pam.d]# useradd -d /var/ftp/vuser vuser		# -d选项：指定用户家目录
[root@localhost pam.d]# chown vuser:vuser /var/ftp/vuser	# 修改目录的 所有着:所属组
[root@localhost pam.d]# ll /var/ftp/
总用量 0
drwxr-xr-x. 2 root  root   6 8月  12 2018 pub
drwx------. 3 vuser vuser 78 5月  19 23:20 vuser
[root@localhost pam.d]# chmod 555 /var/ftp/vuser/			# 缩小权限以预防 ftp 500 错误
[root@localhost pam.d]# echo "vuser' s home is here" > /var/ftp/vuser/vuser.txt
```

### 5、修改配置文件

```bash
[root@localhost pam.d]# grep -v ^# /etc/vsftpd/vsftpd.conf
anonymous_enable=NO			# 禁止匿名登录
local_enable=YES			# 允许本地用户访问FTP服务器
write_enable=NO				# 禁止用户对FTP做写入
local_umask=022				# 本地用户权限 file：644 folder：755
dirmessage_enable=YES		# 开启消息功能
xferlog_enable=YES			# 开启日志轮换
connect_from_port_20=YES	# 连接端口：20
xferlog_std_format=YES		# 日志写入格式 xferlog
chroot_local_user=YES		# 禁止用户访问其他用户家目录
listen=YES					# 开启独立模式 ipv4
listen_ipv6=NO				# 关闭独立模式 ipv6

pam_service_name=vsftpd		# 指定用于认证的PAM文件名
userlist_enable=YES			# 将 /etc/vsftpd/user_list 设置为黑名单；NO则为白名单
allow_writeable_chroot=YES	# 允许用户在家目录中上传和修改文件
guest_enable=YES			# 启用虚拟用户				
guest_username=vuser		# 虚拟用户名为：vuser
```

### 6、防火墙配置

```bash
[root@localhost vsftpd]# setenforce 0
[root@localhost vsftpd]# firewall-cmd --permanent --add-service=ftp
success
[root@localhost vsftpd]# firewall-cmd --reload
success
```

### 7、客户端测试

```bash
[root@samba /]# ftp 192.168.231.130
Connected to 192.168.231.130 (192.168.231.130).
220 (vsFTPd 3.0.3)
Name (192.168.231.130:root): user2
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
```

# Samba 服务器配置

## Samba服务的主要进程

+ smbd进程：控制发布共享目录与权限，复制文件传输 TCP 139 445
+ nmbd进程：用于名称解析NetBIOS UDP 137 138；基于NetBIOS 协议获得计算机名 ---> 解析为相应IP地址，实现信息通讯

## Samba 服务的安装配置

### 软件安装-Server

```bash
[root@localhost vsftpd]# yum -y install samba.x86_64
[root@localhost vsftpd]# rpm -ql samba
/etc/openldap/schema
/etc/openldap/schema/samba.schema
/etc/pam.d/samba
/usr/bin/smbstatus
```

### 防火墙开放服务

```bash
[root@localhost vsftpd]# firewall-cmd --permanent --add-service=samba
success
[root@localhost vsftpd]# firewall-cmd --reload
success
```

### 客户端安装

```
[root@samba /]# yum install -y samba-client.x86_64
```

### 客户端连接测试

`-L`：列出服务器上的共享资源	

```bash
[root@samba ~]# smbclient -L 192.168.231.130
Enter SAMBA\root's password:
Anonymous login successful

        Sharename       Type      Comment
        ---------       ----      -------
        print$          Disk      Printer Drivers
        IPC$            IPC       IPC Service (Samba 4.9.1)
Reconnecting with SMB1 for workgroup listing.
Anonymous login successful

        Server               Comment
        ---------            -------

        Workgroup            Master
        ---------            -------
```

## 认识配置文件

```bash

[root@localhost vsftpd]# vim /etc/samba/smb.conf
# See smb.conf.example for a more detailed config file or
# read the smb.conf manpage.
# Run 'testparm' to verify the config is correct after
# you modified it.

[global]							# 全局配置
        workgroup = SAMBA			# 工作组名称
        security = user				# 安全等级：user 用户名密码登录 | share 匿名登录 | server 外部服务器用户名密码

        passdb backend = tdbsam		# 指定密码数据库后端为tdbsam，即使用TDB格式的本地数据库存储用户密码

        printing = cups				# 启用打印功能，并使用CUPS作为打印系统。
        printcap name = cups		# 指定CUPS打印系统的打印机配置文件名称。
        load printers = yes			# 加载打印机
        cups options = raw			# 打印机选项

[homes]								# 定义了用户的个人目录共享。
        comment = Home Directories	# 描述信息
        valid users = %S, %D%w%S	# 允许访问个人目录共享的有效用户列表。
        browseable = No				# 隐藏共享名
        read only = No				# 不是只读
        inherit acls = Yes			# 继承访问控制列表（ACL）

[printers]							# 定义了打印机共享。
        comment = All Printers		# 描述信息
        path = /var/tmp				# 指定路径
        printable = Yes				# 允许打印机共享进行打印操作
        create mask = 0600			# 创建的文件权限掩码为0600
        browseable = No				# 隐藏共享名

[print$]								# 打印驱动共享
        comment = Printer Drivers		# 描述信息
        path = /var/lib/samba/drivers	# 打印驱动程序共享的路径为"/var/lib/samba/drivers"
        write list = @printadmin root	# 允许具有"printadmin"组权限和"root"用户权限的用户进行写操作
        force group = @printadmin		# 强制将文件所属组设置为"printadmin"组
        create mask = 0664				# 创建的文件权限掩码为0664
        directory mask = 0775			# 创建的目录权限掩码为0775
```

## 创建SMB用户

> Samba 不直接与本地账户共享账户，需要额外建立 Samba 账户。但是前提还得是本地需要有该账户

```bash
[root@localhost vsftpd]# useradd zhangsan
[root@localhost vsftpd]# smbpasswd -a zhangsan
New SMB password:
Retype new SMB password:
Added user zhangsan.
[root@localhost vsftpd]# pdbedit -L
zhangsan:1002:
```

### Samba用户登录

`-U`：指定用户名访问Samba服务

```bash
[root@samba ~]# smbclient //192.168.231.130/zhangsan -U zhangsan
Enter SAMBA\zhangsan's password:
Try "help" to get a list of possible commands.
smb: \> 
```

## Samba允许匿名用户访问 /samba/share 共享资源，本地不能访问

### 修改配置文件

```bash
[root@localhost vsftpd]# vim /etc/samba/smb.conf
[anon_share]
path = /home/samba
public = yes
writable = yes

[root@localhost vsftpd]# mkdir /home/samba -p
[root@localhost vsftpd]# systemctl restart smb.service

# 修改SELINUX，保证客户端可成功访问家目录的文件
[root@localhost home]# setsebool samba_enable_home_dirs  1
```

### 客户端访问

```bash
[root@samba ~]# smbclient //192.168.231.130/anon_share		# 路径的指定由配置中的全局名字决定
Enter SAMBA\root's password:
Anonymous login successful
Try "help" to get a list of possible commands.
smb: \>
```

# DNS服务器搭建

## 服务配置

```
[root@localhost vsftpd]# yum install -y bind
```

### 查看相关文件

```
[root@localhost vsftpd]# rpm -ql bind
/etc/logrotate.d/named
/etc/named
/etc/named.conf				# 配置文件
/var/log/named.log			# 日志文件
/var/named					# 数据文件的主目录
/var/named/data
/var/named/dynamic
/var/named/named.ca			# 根域服务器
/var/named/named.empty
/var/named/named.localhost	# 正向解析区域文件的模板
/var/named/named.loopback	# 反向解析区域文件的模板
/var/named/slaves			# 从dns服务器下载文件的默认路径
```

### 修改主配置文件

```bash
[root@localhost named]# vim /etc/named.conf
options {
        listen-on port 53 { 127.0.0.1;any; };				# 监听方式 any表示全网监听（需修改）
        listen-on-v6 port 53 { ::1; };						# IPv6的监听方式
        directory       "/var/named";						# DNS的数据文件存放位置
        dump-file       "/var/named/data/cache_dump.db";	# 缓存文件
        statistics-file "/var/named/data/named_stats.txt";	# 统计
        memstatistics-file "/var/named/data/named_mem_stats.txt";	# 内存统计
        secroots-file   "/var/named/data/named.secroots";
        recursing-file  "/var/named/data/named.recursing";
        allow-query     { localhost;any; };					# any 允许全网查询（需修改）

        /*
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable
           recursion.
         - If your recursive DNS server has a public IP address, you MUST enable access
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface
        */
        recursion yes;										# 是否递归

        dnssec-enable no;									# dns安全扩展机制（签名认证）
        dnssec-validation no;								

        managed-keys-directory "/var/named/dynamic";

        pid-file "/run/named/named.pid";
        session-keyfile "/run/named/session.key";

        /* https://fedoraproject.org/wiki/Changes/CryptoPolicy */
        include "/etc/crypto-policies/back-ends/bind.config";
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
        type hint;
        file "named.ca";
};
		
include "/etc/named.rfc1912.zones";							# 包含配置文件
include "/etc/named.root.key";
```

### 修改子配置文件

#### 管理区域文件

```bash
[root@localhost named]# vim /etc/named.rfc1912.zones
zone "misshou.io" IN {				# 定义区域
        type master;				# 定义为主服务器
        file "misshou.io.zone";		# 定义该区域的配置文件
        allow-update { none; };		# 不允许更新
};
```

#### 创建区域配置文件

```bash
[root@localhost named]# cp -p /var/named/named.localhost /var/named/misshou.io.zone		# 必须加上-p选项，文件的所有者和所属组不许更改
[root@localhost named]# ll /var/named/misshou.io.zone
-rw-r-----. 1 root named 152 6月  21 2007 /var/named/misshou.io.zone

[root@localhost named]# vim /var/named/misshou.io.zone
$TTL 1D
@       IN SOA  misshou.io. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns1.misshou.io.
dns1    A       192.168.231.130
www     A       192.168.231.254

```

#### 区域配置文件了解

```bash
$TTL 	缓存的生命周期
1D		1 Day 一天
@ = zonename = misshou.io	当前域名
IN		互联网
SOA		开始授权
NS		dns服务端
A		正向解析
AAAA	ipv6 解析
CNAME	别名
MX		邮件交互记录，数字代表优先级，优先级约低越优先

[root@localhost named]# vim /var/named/misshou.io.zone
$TTL 1D
@       IN SOA  misshou.io. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns1.misshou.io.			# 定义当前DNS服务器的名字
dns1    A       192.168.231.130				# 定义当前DNS服务器的IP地址
www     A       192.168.231.254				# A 记录解析
```

### 检查配置文件

```powershell
[root@localhost named]# named-checkconf /etc/named.conf
[root@localhost named]# named-checkconf /etc/named.rfc1912.zones
```

### 检查区域文件

```bash
[root@localhost named]# cd /var/named/
[root@localhost named]# named-checkzone misshou.io.zone misshou.io.zone			# 区域文件写两遍
zone misshou.io.zone/IN: loaded serial 0
OK
```

### 防火墙放行

```bash
root@localhost ~]# setenforce 0
[root@localhost named]# firewall-cmd --permanent --add-service=dns
success
[root@localhost named]# firewall-cmd --reload
success
[root@localhost named]# systemctl restart named.service
```

## 客户端测试

```bash
[root@samba ~]# nslookup
> www.misshou.io
Server:         192.168.231.130
Address:        192.168.231.130#53

Name:   www.misshou.io
Address: 192.168.231.254
```

## 反向解析

### 修改子配置文件

```
# 主配置文件 /etc/named.conf 按上面实验修改，添加两个 any 就好
# 修改区域管理文件
[root@localhost named]# vim /etc/named.rfc1912.zones
zone "231.168.192.in-addr.arpa" IN {
        type master;
        file "192.168.231.zone";
        allow-update { none; };
};
```

### 修改区域配置文件

```bash
[root@localhost named]# cp -p /var/named/named.loopback /var/named/192.168.231.zone
[root@localhost named]# vim /var/named/192.168.231.zone
$TTL 1D
@       IN SOA  misshou.io. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns1.misshou.io.		# 如果在正向区域文件里存在 dns1.misshou.io，则可以不用写A记录
        A       192.168.231.130
254     PTR     www.misshou.io.			# 参数一：主机地址	参数二：PTR	参数三：PTR映射的完整域名
```

### 客户端测试

```bash
[root@samba ~]# nslookup
> 192.168.231.254
254.231.168.192.in-addr.arpa    name = www.misshou.io.
```

## 总结

DNS涉及的配置文件比较多，这里做一下总结：

1. `/etc/named.conf`：DNS服务的主配置文件（全局配置文件），定义了DNS服务器如何与客户端进行通信

2. `/etc/named.rfc1912.zones`：DNS服务器的区域配置文件（子配置文件），定义了DNS服务器的区域

   ```
   zone "231.168.192.in-addr.arpa" IN {
           type master;
           file "192.168.231.zone";
           allow-update { none; };
   };
   ```

3. `/var/named/192.168.231.zone`：定义了区域文件的详细信息。具体记录在这里写**（文件名必须保证与区域配置文件相同）**

# Web服务器配置

## 服务搭建

### 软件安装

```bash
[root@localhost named]# yum install -y httpd
```

### 了解相关文件

```bash
[root@localhost named]# rpm -ql httpd
/etc/httpd/conf		# 主配置文件目录
/etc/httpd/conf.d/welcome.conf		# 欢迎页
/etc/httpd/logs		# apache 日志文件
```

### 了解配置文件

```bash
ServerRoot "/etc/httpd"			# 服务主目录

Listen 80						# 监听端口

Include conf.modules.d/*.conf	# 包含conf.d下的*.conf文件

User apache						# 以 Apache 用户运行
Group apache					# 以 Apache 用户组运行

ServerAdmin root@localhost


<Directory />					# 系统的根目录授权
    AllowOverride none			# 不支持.htaceess 访问列表。.hataccess 文件提供了针对每个目录改变配置的方法
    Require all denied			
</Directory>


DocumentRoot "/var/www/html"	# 指定Web根目录

<Directory "/var/www">
    AllowOverride None
    Require all granted
</Directory>

<Directory "/var/www/html">		# 授权
    Options Indexes FollowSymLinks	#支持索引 支持软链接
    AllowOverride None		# 不支持 .htaccess 访问列表
    Require all granted		# 允许所有人访问
</Directory>

<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

<Files ".ht*">
    Require all denied
</Files>

ErrorLog "logs/error_log"

LogLevel warn

<IfModule log_config_module>
    LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" co                                                                                                                               mbined
    LogFormat "%h %l %u %t \"%r\" %>s %b" common

    <IfModule logio_module>
      LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %                                                                                                                               I %O" combinedio
    </IfModule>
    CustomLog "logs/access_log" combined
</IfModule>

<IfModule alias_module>
    ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"

</IfModule>

<Directory "/var/www/cgi-bin">
    AllowOverride None
    Options None
    Require all granted
</Directory>

<IfModule mime_module>
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz
    AddType text/html .shtml
    AddOutputFilter INCLUDES .shtml
</IfModule>

AddDefaultCharset UTF-8

<IfModule mime_magic_module>
    MIMEMagicFile conf/magic
</IfModule>


EnableSendfile on

IncludeOptional conf.d/*.conf
```

### 防火墙放行

```bash
[root@localhost named]# setenforce  0
[root@localhost named]# firewall-cmd --permanent --add-service=http
success
[root@localhost named]# firewall-cmd --reload
success
```

## 基于IP的虚拟主机

### 创建网页内容

```bash
[root@localhost conf]# mkdir /var/www/ip1
[root@localhost conf]# mkdir /var/www/ip2
[root@localhost conf]# echo "This is ip1's web" > /var/www/ip1/index.html
[root@localhost conf]# echo "This is ip2's web" > /var/www/ip2/index.html
```

### 编辑`/etc/httpd/conf.d/vhost.conf`配置文件

指定虚拟主机并指定每一个虚拟主机的网站根目录

```bash
<Virtualhost 192.168.231.130>
    DocumentRoot /var/www/ip1
</Virtualhost>


<Virtualhost 192.168.231.140>
    DocumentRoot /var/www/ip2
</Virtualhost>
```

### 编辑`/etc/httpd/conf/httpd.conf`配置文件

由于虚拟主机的网页根目录是在`/var/www/ip{1,2}`，所以可以直接在`/var/www`授权即可

```bash
<Directory "/var/www">
    AllowOverride None		# 不启用 .htaccess 文件
    # Allow open access:
    Require all granted		# 允许所有用户访问受保护内容，无需身份验证
</Directory>
```

## 基于端口的虚拟主机

### 创建文件内容

```bash
[root@localhost conf]# mkdir /var/www/9000
[root@localhost conf]# mkdir /var/www/50001
[root@localhost conf]# echo "This is port:8088's web" > /var/www/8088/index.html
[root@localhost conf]# echo "This is port:8089's web" > /var/www/8089/index.html

```

### 修改`/etc/httpd/conf/httpd.conf`配置文件

+ 监听端口

+ 对相应的文件夹开启权限

  由于两个HTML文件都在`/var/www`下，所以对`/var/www`授权即可

```bash
[root@localhost conf]# vim /etc/httpd/conf/httpd.conf
Listen 80
Listen 9000
Listen 50001

<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>
```

### 编辑`/etc/httpd/conf.d/vhost.conf`配置文件

```bash
[root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf
<Virtualhost 192.168.231.130:9000>
    DocumentRoot /var/www/8088
</Virtualhost>


<Virtualhost 192.168.231.130:50001>
    DocumentRoot /var/www/8089
</Virtualhost>
```

### 防火墙放行

注意：放行端口，HTTP基于TCP协议

```bash
[root@localhost ~]# firewall-cmd --permanent --add-service=http
success
[root@localhost ~]# firewall-cmd --permanent --add-port=9000/tcp
success
[root@localhost ~]# firewall-cmd --permanent --add-port=50001/tcp
success
[root@localhost ~]# firewall-cmd --reload
success
```

## 基于域名的虚拟主机

### 编辑网页内容

```bash
[root@localhost ~]# mkdir /var/www/www1
[root@localhost ~]# mkdir /var/www/www2
[root@localhost ~]# echo "This is domain1's web" > /var/www/www1/index.html
[root@localhost ~]# echo "This is domain2's web" > /var/www/www2/index.html
```

### 修改`/etc/httpd/conf/httpd.conf`配置文件

由于`www1`和`www2`都是`/var/www`的子目录，所以直接对`/var/www`进行授权即可

```bash
[root@localhost ~]# vim /etc/httpd/conf/httpd.conf
<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>
```

### 修改`/etc/httpd/conf.d/vhost.conf`配置文件

```bash
[root@localhost ~]# vim /etc/httpd/conf.d/vhost.conf
<Virtualhost 192.168.231.130>
    DocumentRoot /var/www/www1
    ServerName www1.long60.cn
</Virtualhost>

<Virtualhost 192.168.231.130>
    DocumentRoot /var/www/www2
    ServerName www2.long60.cn
</Virtualhost>
```

### 修改`/etc/hosts`文件

> 在正常的业务环境中，是应该搭配DNS服务器做域名解析一起使用的

```bash
[root@localhost ~]# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
www1.long60.cn          IN              A               192.168.231.130
www2.long60.cn          IN              A               192.168.231.130
```

### 客户端测试

在测试之前需要先编辑hosts文件

```bash
[root@samba ~]# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.231.130 www1.long60.cn
192.168.231.130 www2.long60.cn
```

# iptables防火墙

## iptables防火墙介绍

+ Linux.系统内核集成了网络访问控制的功能，通过netfiltel模块来实现，是内核的一部分（内核空间)
+ 用户层（用户空间）可以通过iptables程序对netfilteri进行控制管理，进而实现网络的访问控制
+ TCP_Wrappers也是一个网络访问控制的一个工具，作用在应用层(7层防火墙)》

总结：

+ netfilter模块	内核空间，是内核一部分
+ iptables组件用户空间，提供管理防火墙的手段，它主要作用在传输层(4层防火墙)

## iptables结构

> iptables 是表的集合 - 表是链的集合 - 链是规则的集合
>
> Iptables 有4张表，分别是：filter、nat、mangle、raw

### filter 表

`filter表`总共有三条链：负责对数据包的过滤

+ INPUT
+ FORWARD
+ OUTPUT

```bash
[root@localhost ~]# iptables -t filter -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             192.168.122.0/24     ctstate RELATED,ESTABLISHED
ACCEPT     all  --  192.168.122.0/24     anywhere
ACCEPT     all  --  anywhere             anywhere
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootpc
```

### NAT表

`NAT表`共有四条链：负责NAT地址转换

+ PREROUTING（路由前）
+ INPUT
+ OUTPUT
+ POSTROUTING（路由后）

```bash
[root@localhost ~]# iptables -t nat -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
RETURN     all  --  192.168.122.0/24     base-address.mcast.net/24
RETURN     all  --  192.168.122.0/24     255.255.255.255
MASQUERADE  tcp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535
MASQUERADE  udp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535
MASQUERADE  all  --  192.168.122.0/24    !192.168.122.0/24

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

### Mangle表

`Mangle表`共有五条链 ：

+ PREROUTING（路由前）
+ INPUT
+ FORWARD
+ OUTPUT
+ POSTROUTING（路由后）

```
[root@localhost ~]# iptables -t mangle -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
CHECKSUM   udp  --  anywhere             anywhere             udp dpt:bootpc CHECKSUM fill

```

### Raw表

`Raw表`共有2条链：

+ PREROUTING（路由前）
+ OUTPUT

```bash
[root@localhost ~]# iptables -t raw -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source  
```

## Iptables 防火墙工作源流（数据包流向）

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230522220447608.png" alt="image-20230522220447608" style="zoom: 80%;" />

### 数据包的过滤

对于数据包的过滤，会去走`filter`表，`filter`表会有三条链：`PREROUTING、FORWARD、POSTROUTING`，数据包的过滤操作会在`FORWORAD`链进行

### NAT表的走向

数据首先从`PREROUTING`进入，再进入`INPUT`，再有系统（localhost）进行地址翻转，之后再从`OUTPUT`转发，最后由`POSTROUTING`输出

## Iptables基本语法

+ `iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作]`

  ​							小写			大写		大写		小写				 大写

说明：

+ 表名和链名：用于指定iptables命令所操作的表和链
+ 命令选项：用于指定管理iptables规则的方式（比如：增加、插入、删除、查看等）
+ 规则号码：用于指定规则的编号
+ 条件匹配：用于指定对符合什么样条件的数据包进行处理（比如：什么协议、出入网卡等）
+ 目标动作：用于指定数据包的处理方式（比如：允许通过、拒绝、丢弃等）

### iptables配置文件

```bash
[root@localhost ~]# cat /etc/sysconfig/iptables-config
```

### iptables 常用的命令选项

````
常见的命令选项：
-L [链名]										查看
-A [链名] 									追加，放置最后一条
-I [链名] [插入位置num]						  插入，默认插入第一条
-D [链名]	[删除位置num]						  删除指定规则
-F [链名]										清空Flush
-p [链名]	[动作]								设置默认策略policy
-R [链名] [插入位置num]						  在指定位置覆盖规则

处理动作：
-j ACCEPT					允许
-j DROP						拒绝，没有提示信息
-j REJECT					拒绝，有提示信息
-j log						写日志	/var/log/message 然后将输出包传递给下一条规则

nat表：
-j SNAT						源地址传唤 POSTROUTING
-j DNAT						目标地址转换 PREROUTING
````

## 实例一：全部允许或拒绝

```bash
iptables -t filter -A INPUT -j DROP			# 添加规则。丢弃所有进来的数据包
iptables -t filter -A INPUT -j ACCEPT		# 添加规则，转发所有进来的数据包	
iptables -t filter -I INPUT 2 -j ACCEPT		# 在指定编号位置插入 ACCEPT 规则
iptables -t filter -D INPUT 2 -j ACCEPT		# 删除指定编号的规则
iptables -t filter -F						# 删除所有规则
iptables -t filter -P INPUT ACCEPT			# 修改指定链的规则
iptables -t filter -R INPUT 2 -j DROP		# 覆盖指定编号的规则
iptables -t filter -L --line-numbers		# 带编号显示规则
```

## 实例二：根据源目地址匹配

```bash
-s 192.168.134.0/24		# 源地址
-d 192.168.134.0/24		# 目标地址
-p tcp|udp|icmp			# 协议
-i eth0					# 从eth0接口进入的数据包
-o eth0					# 从eth0接口出去的数据包
-p tcp --dport 80		# 丢弃基于目标80端口的TCP报文
-p udp --sport 53		# 丢弃基于源53端口的UDP报文
```

```bash
iptables -t filter -A INPUT -s 192.168.231.129 -j DROP			# 拒绝源地址为：192.168.231.129 通过
iptables -t filter -A INPUT -s 192.168.231.0/24 -j DROP			# 拒绝网段为：192.168.231.0/24 通过
iptables -t filter -A OUTPUT -d 192.168.231.1 -j ACCEPT			# 允许目标地址：192.168.231.1 通过
```

## 示例三：根据源目端口

```bash
-p tcp|udp|icmp			# 协议
-p tcp --dport 80		# 丢弃基于目标80端口的TCP报文
-p udp --sport 53		# 丢弃基于源53端口的UDP报文
```

```bash
iptables -t filter -A INPUT -s 192.168.231.129 -p tcp -j DROP		# 拒绝源地址为：192.168.231.129 的主机访问TCP协议的一切服务
iptables -t filter -A INPUT -p tcp --dport 80 -s 192.168.231.129 -j DROP		# 拒绝源地址为：192.168.231.129 的主机访问HTTP服务、

# 只允许我ping别人，不允许别人ping我
iptables -t filter -A INPUT -p icmp --icmp-type 8 -s 192.168.231.130 -j ACCEPT		# 允许源地址为：192.168.231.130 协议为：icmp 并且 icmp 的类型是 8 的报文通过（ICMP type 8 = ICMP request）
iptables -t filter -A INPUT -p icmp --icmp-type 0 -d 192.168.231.130 -j ACCEPT		# 允许目标地址为：192.168.231.130 协议为：icmp 并且 IC名片 的类型是 0 的报文通过（ICMP type 0 = ICMP Response）
iptables -t filter -A INPUT -p icmp -j DROP											# 拒绝所有ICMP报文通过
```

## 综合练习

1. 禁用另一台服务器访问80端口

2. 允许其他人访问80端口
2. 只允许你ping通别人，不允许别人ping你

4. 拒绝所有人访问sshd服务

```bash
# 第一题
iptables -t filter -A INPUT -p tcp --drpot 80 -s 192.168.231.129 -j DROP
# 第二题不需要做任何操作，默认全通过
# 第三题
iptables -t filter -A INPUT -p icmp --icmp-type 8 -s 192.168.231.130 -j ACCEPT
iptables -t filter -A INPUT -p icmp --icmp-type 0 -d 192.168.231.130 -j ACCEPT
iptables -t filter -A INPUT -p icmp -j DROP
# 第四题
iptables -t filter -A INPUT -p tcp --dport 22 -j DROP

[root@localhost ~]# iptables -t filter -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  192.168.231.129      anywhere             tcp dpt:http
ACCEPT     icmp --  localhost.localdomain  anywhere             icmp echo-request
ACCEPT     icmp --  anywhere             localhost.localdomain  icmp echo-reply
DROP       icmp --  anywhere             anywhere            
DROP       tcp  --  anywhere             anywhere             tcp dpt:ssh

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination  
```

## iptables 内置模块（扩展）

### multiport 模块

```bash
-m 参数 + <模块名>
1. multiport	多端口	目的：指定多个不连续端口，减少IP tables的条目，达到优化效果（iptables的条目越小，速度自然也越快）
用法：
iptables -m multiport --help
-m multiport
	--dports port[,port:port,port...]
	--sports port[,port:port,port...]
	
iptables -t filter -A INPUT -p tcp --dport 20 -j ACCEPT
iptables -t filter -A INPUT -p tcp --dport 21 -j ACCEPT
等于
iptables -t filter -A INPUT -m multiport -p tcp --dports 20,21 -j ACCEPT
或
iptables -t filter -A INPUT -m multiport -p tcp --dports 20:21 -j ACCEPT
```

### iprange 模块

```bash
iprange ip范围
用法：
iptable -m iprange --help
-m iprange
	--src-range ip[-ip]
	--dst-range ip[-ip]

# 允许 192.168.231.10 - 192.168.231.100 地址段访问服务器的TCP访问
iptables -t filter -A INPUT -m iprange -p tcp --src-range 192.168.231.10-192.168.231.100 -j ACCEPT
```

# Iptables 防火墙 - NAT表

## NAT 简介

NAT，地址翻转协议。由于如今互联网的IPv4地址严重不足，无法满足上网需求，所以研制出了NAT协议。企业通过购买1-2个公网IP，内网使用私有IP做网络划分，最后在出口路由器做NAT地址翻转，已达到内网N个用户只使用1-2个IP地址上网的目的（节省IP地址）

NAT 分为两种类型：

+ 源NAT：通过翻转数据包中的源地址，以达到成功通信的目的。通常用于：内网 --> 外网，访问互联网
+ 目NAT：通过翻转数据包中的目的IP地址，以达到成功通信的目的。通常用于：外网 --> 内网，用户可以从外网访问内网的服务器。企业也可以保证内网服务器的IP划分不被泄露

## SNAT 实战

### 实验环境：

NAT Server：192.168.231.130 | 192.168.80.254

NAT Client：192.168.80.129

Target Server：192.168.231.1

要求：NAT Client 通过 NAT Server 的地址翻转，成功 ping 通 target Server

### 开启路由转发功能

1 代表开启，如果为 0 则执行第二条命令

```bash
[root@localhost ~]# cat /proc/sys/net/ipv4/ip_forward
1
```

```bash
[root@localhost ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
```

### 做SNAT地址翻转

```bash
[root@localhost ~]# iptables -t nat -A POSTROUTING -s 192.168.80.129 -j SNAT --to 192.168.231.130
```

## DNAT 实战

### 实验环境

NAT Server：192.168.231.130 | 192.168.80.254

NAT Client：192.168.231.1

Target Server：192.168.80.129

### 开启路由转发功能

1 代表开启，如果为 0 则执行第二条命令

```bash
[root@localhost ~]# cat /proc/sys/net/ipv4/ip_forward
1
```

```bash
[root@localhost ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
```

### 做DNAT地址翻转

```bash
[root@localhost ~]# iptables -t nat -A PREROUTING -d 192.168.231.130 -j DNAT --to 192.168.80.129
```

## 总结

+ 对于SNAT，需要在POSTROUTING链上做翻转，原因是：需要保证目标地址可达之后源IP地址才应该允许被翻转
+ 对于DNAT，需要在PREROUTING链上做翻转，原因是：需要在路由前保证翻转后d

+ 不管是SNAT或者是DNAT，都需要在已有的IP地址上做翻转，绝对不能使用没有的IP地址！

# Linux CA证书服务原理与搭建

## HTTPS 的通信原理-简化

1. Client 获得 Server 的证书
2. Client 验证 Server 的证书的有效性（通过 CA 的公钥）
3. 证书有效，Client 生成一串随机字符串
4. Client 使用 Server 的公钥对这串字符串进行加密并发给 Server
5. Server 使用私钥对信息进行解密，得到这串随机字符串
6. 后续通信，Client 和 Server 使用这串随机字符串对做对称加密进行通信以保证数据的安全

## opensll

### openssl命令对称加密

工具：openssl enc

加密：

+ 使用 openssl enc 工具
+ `-e`：加密
+ `-des3`：使用`des3`算法
+ `-a`：对密文使用`BASE64`编码输出，保证密文不会出现乱码
+ `-salt`：对密文做加盐处理，保证哈希算法不被爆破
+ `-in`：指定使用哪个文件进行加密
+ `-out`：输出到哪个具体文件

```bash
openssl enc -e -des3 -a -salt -in passwd_simple -out passwd_sce
```

解密：

+ 使用 openssl enc 工具
+ `-d`：解密
+ `-des3`：使用`des3`算法
+ `-a`：对密文使用`BASE64`编码输出，保证密文不会出现乱码
+ `-salt`：对密文做加盐处理，保证哈希算法不被爆破
+ `-in`：指定使用哪个文件进行加密
+ `-out`：输出到哪个具体文件

```bash
openssl enc -d -des3 -a -salt -in passwd_sce -out soso
```

### openssl命令做哈希算法

工具：opensll dsgt

命令格式：openssl <哈希算法> 哈希文件

```bash
[root@localhost data]# openssl md5 passwd_simple
MD5(passwd_simple)= f447b20a7fcbf53a5d5be013ea0b15af
```

### openssl 生成用户密码

```bash
[root@localhost data]# openssl passwd --help
Usage: passwd [options]
Valid options are:
 -help               Display this summary
 -in infile          Read passwords from file
 -noverify           Never verify when reading password from terminal
 -quiet              No warnings
 -table              Format output as table
 -reverse            Switch table columns
 -salt val           Use provided salt
 -stdin              Read passwords from stdin
 -6                  SHA512-based password algorithm
 -5                  SHA256-based password algorithm
 -apr1               MD5-based password algorithm, Apache variant
 -1                  MD5-based password algorithm
 -aixmd5             AIX MD5-based password algorithm
 -crypt              Standard Unix password algorithm (default)
 -rand val           Load the file(s) into the random number generator
 -writerand outfile  Write random data to the specified file
```

示例：

`-6`：使用`SHA512`算法

`-salt`：指定盐值

```bash
[root@localhost data]# openssl passwd -6 -salt TmwDSId5COmUu.7T
Password:
$6$TmwDSId5COmUu.7T$CKychemhqx4EViz8/9EbOGfG.Z0M8BRO2JR/K.UJh3S088SCbQP.G/KdX3JLj5l.H2APGLo/zKhLx77Z5nxUC/
```

### opensll生成随机数

随机数生成器：仅随机数字，利用键盘和鼠标，块设备中断生成随机数

`/dev/random`：进从熵池返回随机数；随机数用尽，阻塞

`/dev/urandom`：从熵池返回随机数；随机数用尽，会利用软件生成伪随机数，非阻塞

```bash
[root@localhost data]# openssl rand --help
Usage: rand [flags] num
Valid options are:
 -help               Display this summary
 -out outfile        Output file
 -rand val           Load the file(s) into the random number generator
 -writerand outfile  Write random data to the specified file
 -base64             Base64 encode output
 -hex                Hex encode output
 -engine val         Use engine, possibly a hardware device
 
 # 生成9个字节的随机数，并且使用BASE64编码输出
 [root@localhost data]# openssl rand -base64 9
fOVYMkLx0zay
```

### openssl PKI密钥实现

生成私钥：

```bash
[root@localhost data]# openssl genrsa -out /app.key		# 使用rsa算法生成私钥
```

在私钥中提取公钥

`opensll rsa`：指定为rsa算法

`-in`：导入私钥

`-out`：导入公钥

`-pubout:`提取公钥

```bash
[root@localhost data]# openssl rsa -in /app.key -pubout -out /public.key
```

## 建立私有CA实现证书申请颁发

证书申请及签署步骤：

1. 生成证书申请请求
2. RA核验
3. CA签署
4. 获取证书

### 配置文件：

`/etc/pki/tls/openssl`.conf

### 了解配置文件：

**`$dir` = [CA_default] 下的 dir项 **

`dir = /etc/pki/CA`

```bash
####################################################################
[ ca ]
default_ca      = CA_default            # The default ca section		

####################################################################
[ CA_default ]

dir             = /etc/pki/CA           # Where everything is kept			# CA的工作路径，存放CA的所有配置文件
certs           = $dir/certs            # Where the issued certs are kept	# 所有已颁发证书的存放位置
crl_dir         = $dir/crl              # Where the issued crl are kept
database        = $dir/index.txt        # database index file.				# 数据库索引文件
#unique_subject = no                    # Set to 'no' to allow creation of
                                        # several certs with same subject.
new_certs_dir   = $dir/newcerts         # default place for new certs.		# 新颁发的证书的存放位置

certificate     = $dir/cacert.pem       # The CA certificate				# 根CA颁发的证书
serial          = $dir/serial           # The current serial number
crlnumber       = $dir/crlnumber        # the current crl number			# 被吊销的证书编号的存放位置
                                        # must be commented out to leave a V1 CRL
crl             = $dir/crl.pem          # The current CRL					# 存放所有被吊销的证书列表
private_key     = $dir/private/ cakey.pem# The private key					# 存放私钥
RANDFILE        = $dir/private/.rand    # private random number file		# 存放随机值

x509_extensions = usr_cert              # The extensions to add to the cert

# Comment out the following two lines for the "traditional"
# (and highly broken) format.
name_opt        = ca_default            # Subject Name options
cert_opt        = ca_default            # Certificate field options

# Extension copying option: use with caution.
# copy_extensions = copy

# Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs
# so this is commented out by default to leave a V1 CRL.
# crlnumber must also be commented out to leave a V1 CRL.
# crl_extensions        = crl_ext

default_days    = 365                   # how long to certify for			# 颁发证书的默认有效期
default_crl_days= 30                    # how long before next CRL			
default_md      = sha256                # use SHA-256 by default
preserve        = no                    # keep passed DN ordering

# A few difference way of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy          = policy_match												# 指定使用什么策略

# For the CA policy															
# match 表示必须匹配
# optional 可以不匹配
[ policy_match ]															# 客户端所填写的资料与策略进行对比
countryName             = match												
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied											# 域名，必填
emailAddress            = optional

# For the 'anything' policy
# At this point in time, you must list all acceptable 'object'
# types.
[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
```

### 创建私有CA

#### 1、创建所需要的目录

```bash
[root@localhost pki]# mkdir -pv /etc/pki/CA/{certs,crl,newcerts,private}
mkdir: 已创建目录 '/etc/pki/CA'
mkdir: 已创建目录 '/etc/pki/CA/certs'
mkdir: 已创建目录 '/etc/pki/CA/crl'
mkdir: 已创建目录 '/etc/pki/CA/newcerts'
mkdir: 已创建目录 '/etc/pki/CA/private'
```

#### 2、创建CA所需要的文件

```
# 生成证书索引数据库文件
touch /etc/pki/CA/index.txt
touch /etc/pki/CA/index.txt.attr

# 指定第一个颁发证书的序列号
echo 01 > /etc/pki/CA/serial
```

#### 3、生成CA私钥

在配置文件中，`$dir/private/cakey.pem` 指定了私钥文件的存放路径为：private/cakey.pem

`umask 066`：指定CA的私钥文件的文件权限为600

`-out`：输出私钥的文件路径

`2048`：指定私钥长度

```bash
[root@localhost CA]# openssl genrsa -out private/cakey.pem 2048
Generating RSA private key, 2048 bit long modulus (2 primes)
....+++++
............................................................................................+++++
e is 65537 (0x010001)
```

#### 4、为CA创建自签名证书

选项说明：

```
-new：生成新证书签署请求
-x509：专用于CA生成自签证书
-key：生成请求时用到的私钥文件
-days n：证书的有效期限
-put /PATH/TO/SOMECERTFILE：证书的保存路径
```



```bash
[root@localhost CA]# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 365 -out /etc/pki/CA/cacert.pem
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:guangdong
Locality Name (eg, city) [Default City]:shenzhen
Organization Name (eg, company) [Default Company Ltd]:sziit
Organizational Unit Name (eg, section) []:sziit
Common Name (eg, your name or your server's hostname) []:ca.sziit.org
Email Address []:123456789@qq.com

[root@localhost CA]# tree /etc/pki/CA
/etc/pki/CA
├── cacert.pem
├── certs
├── crl
├── newcerts
└── private
    └── cakey.pem

4 directories, 2 files

# 查看证书
[root@localhost CA]# openssl x509 -in /etc/pki/CA/cacert.pem -noout -text
```

### 客户端申请并颁发证书

#### 1、客户端生成私钥文件

```bash
[root@samba app1]# (umask 066; openssl genrsa -out app1.key 2048)
Generating RSA private key, 2048 bit long modulus (2 primes)
...+++++
...............................+++++
e is 65537 (0x010001)
```

#### 2、客户端生成证书申请

选项说明：

```bash
req：生成一个证书请求
-new：生成一个新的证书请求
-key：指定私钥
-out：证书请求文件的输出路径
```

```bash
[root@samba app1]# openssl req -new -key app1.key -out app1.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:guangdong
Locality Name (eg, city) [Default City]:shenzhen
Organization Name (eg, company) [Default Company Ltd]:sziit
Organizational Unit Name (eg, section) []:sziit
Common Name (eg, your name or your server's hostname) []:ca.sziit.org
Email Address []:123456789@qq.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:	
An optional company name []:
```

#### 3、CA颁发证书文件

```powershell
[root@localhost app1]# openssl ca -in /data/app1/app1.csr -out /etc/pki/CA/certs/app1.crt -days 1000
Using configuration from /etc/pki/tls/openssl.cnf
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number: 1 (0x1)
        Validity
            Not Before: May 24 04:43:00 2023 GMT
            Not After : Feb 17 04:43:00 2026 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = guangdong
            organizationName          = sziit
            organizationalUnitName    = sziit
            commonName                = ca.sziit.org
            emailAddress              = 123456789@qq.com
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            Netscape Comment:
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier:
                95:96:66:EC:14:56:9A:F8:D1:43:FC:96:F2:D7:B8:ED:69:27:FF:03
            X509v3 Authority Key Identifier:
                keyid:A6:43:FE:E8:45:4C:38:00:14:FE:F2:83:64:2B:E7:5E:97:90:2F:9F

Certificate is to be certified until Feb 17 04:43:00 2026 GMT (1000 days)
Sign the certificate? [y/n]:y
```

#### 4、查看证书

查看证书的有效信息：

```bash
[root@localhost app1]# openssl x509 -in /etc/pki/CA/certs/app1.crt -noout -issuer
issuer=C = CN, ST = guangdong, L = shenzhen, O = sziit, OU = sziit, CN = ca.sziit.org, emailAddress = 123456789@qq.com

[root@localhost client]# tree
.
├── app.crt
├── app.csr
└── app.key

0 directories, 3 files

```

验证证书有效性：

```bash
[root@localhost app1]# openssl ca -status 01
Using configuration from /etc/pki/tls/openssl.cnf
01=Valid (V)
```

#### 5、导出证书传给用户

```bash
[root@localhost app1]# cp /etc/pki/CA/certs/app1.crt /data/app1/
```

## 吊销证书

#### 查看证书编号

```bash
[root@localhost client]# cat /etc/pki/CA/index.txt
V       260309140058Z           01      unknown /C=CN/ST=guangdong/O=sziit/OU=sziit/CN=www.sziit.edu
```

#### 吊销证书

根据编号吊销

```bash
[root@localhost client]# openssl ca -revoke /etc/pki/CA/newcerts/01.pem
Using configuration from /etc/pki/tls/openssl.cnf
Revoking Certificate 01.
Data Base Updated
```

### 总结：

+ 服务器：
  + 初始化CA配置
  + 生成私钥
  + 用私钥生成自签名证书

+ 客户端：
  + 生成私钥
  + 用私钥生成证书申请
  + 使用证书申请向服务器生成证书

# cfssl使用

## cfssl 安装

```bash
VERSION=$(curl --silent "https://api.github.com/repos/cloudflare/cfssl/releases/latest" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
VNUMBER=${VERSION#"v"}
wget https://github.com/cloudflare/cfssl/releases/download/${VERSION}/cfssl_${VNUMBER}_linux_amd64 -O cfssl
chmod +x cfssl
sudo mv cfssl /usr/local/bin
```

## cfssljson 安装

```bash
 # 下载源代码
 wget https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssljson_1.6.1_linux_amd64
 # 添加执行权限
chmod +x cfssljson_1.6.1_linux_amd64
# 修改名字
mv cfssljson_1.6.1_linux_amd64 cfssljson
# 添加到环境变量
 mv cfssljson_1.6.1_linux_amd64 /usr/local/bin/
```

## 查看CA配置的默认选项

```bash
[root@localhost cfssl]# cat config.json
{
    "signing": {
        "default": {
            "expiry": "168h"
        },
        "profiles": {
            "www": {
                "expiry": "8760h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth"
                ]
            },
            "client": {
                "expiry": "8760h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "client auth"
                ]
            }
        }
    }
}
```

## 查看CA证书请求文件

```bash
[root@localhost cfssl]# cfssl print-defaults csr
{
    "CN": "example.net",
    "hosts": [
        "example.net",
        "www.example.net"
    ],
    "key": {
        "algo": "ecdsa",
        "size": 256
    },
    "names": [
        {
            "C": "US",
            "ST": "CA",
            "L": "San Francisco"
        }
    ]
}
```

## 修改证书请求文件

```bash
[root@localhost cfssl]# cp csr.json ca-csr.json
[root@localhost cfssl]# vim ca-csr.json
{
    "CN": "server",
    "key": {
        "algo": "rsa",		# 指定加密算法
        "size": 2048		# 指定密钥长度
    },
    "names": [
        {
            "C": "CN",			# 指定国家
            "ST": "GunagDong",	# 指定省份
            "L": "ShenZhen"		# 指定城市
        }
    ]
}
```

## 生成CA的证书和私钥（自签名证书）

```bash
[root@localhost cfssl]# cfssl gencert -initca ca-csr.json | cfssljson -bare ca
2023/05/24 02:52:05 [INFO] generating a new CA key and certificate from CSR
2023/05/24 02:52:05 [INFO] generate received request
2023/05/24 02:52:05 [INFO] received CSR
2023/05/24 02:52:05 [INFO] generating key: rsa-2048
2023/05/24 02:52:05 [INFO] encoded CSR
2023/05/24 02:52:05 [INFO] signed certificate with serial number 435324584926603866224607034223788757067404112011
[root@localhost cfssl]# ls
ca.csr  ca-csr.json  ca-key.pem  ca.pem  config.json  csr.json

知识点：ca-kay.pem（私钥） ca.pem（公钥）
```

## 用户生成证书请求文件

```bash
[root@localhost cfssl]# cp ca-csr.json server-csr.json
[root@localhost cfssl]# vim server-csr.json
{
    "CN": "www",
    "hosts":[
        "127.0.0.1",
        "192.168.231.130",
        "*.example.com",
        "localhost"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "GunagDong",
            "L": "ShenZhen",
            "O": "sziit",
            "OU": "sziit"
        }
    ]
}
```

## 通过`server-csr.json`生成一个新的证书请求和新的密钥

```bash
[root@localhost ca_client]# cfssl genkey server-csr.json | cfssljson -bare server
2023/05/24 03:04:57 [INFO] generate received request
2023/05/24 03:04:57 [INFO] received CSR
2023/05/24 03:04:57 [INFO] generating key: rsa-2048
2023/05/24 03:04:57 [INFO] encoded CSR
[root@localhost ca_client]# ls
server.csr  server-csr.json  server-key.pem
```

## CA向服务器颁发证书

通过服务器的证书请求文件`server.csr`来申请

```
[root@localhost cfssl]# cfssl sign -ca /cfssl/ca.pem -ca-key ca-key.pem /ca_client/server.csr | cfssljson -bare ca-signed-server
2023/05/24 03:14:11 [INFO] signed certificate with serial number 718581241199119637765630909677547559055267326454
```

## 总结

```
CA（证书颁发机构）是负责颁发和管理数字证书的实体。数字证书是一种用于验证实体身份和建立安全通信的电子文档。

CSR（证书签名请求）：是一种包含公钥和其他标识信息的消息，用于申请数字证书。CSR 通常由申请数字证书的实体生成，并提交给 CA 进行签名。

PEM（隐私增强邮件）：是一种用于存储加密密钥、证书和其他加密材料的文件格式。PEM 文件通常以 .pem 扩展名结尾，并使用 Base64 编码将二进制数据转换为 ASCII 文本。

除此之外，还有许多与 CA 和数字证书相关的术语，例如：

CRT（证书）：是一种包含公钥和实体标识信息的文件，用于验证实体身份和建立安全通信。

CRL（证书撤销列表）：是一种包含已撤销数字证书列表的文件，用于验证数字证书是否有效。

OCSP（在线证书状态协议）：是一种用于检查数字证书状态的协议，可以快速确定数字证书是否已被撤销。
```

# SELinux

## SELinux概述

SElinux 主要作用就是最小限度地减小系统中服务进程可访问的资源（最小权限原则）

## SELinux 工作原理和工作模式

### DAC（自主访问控制）& MAC（强制访问控制）

DAC：自主访问控制，权限管理机制的主题是用户；使用权限来判断资源是否可被对应的用户访问（读、写、执行）

MAC：再使用了SELinux的操作系统中，决定一个资源是否被访问处理上述因素外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这种权限管理机制的主体是进程，也称为前置访问控制（MAC）

二者区别：

1. DAC的主体是真实有效的用户和组ID，MAC主体是安全上下文，两者的UID是各自独立的
2. DAC的访问控制模式是rwxrwxrwx，MAC的访问控制模式是user:role:type

### SELinux  基本架构

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524180326658.png" alt="image-20230524180326658" style="zoom: 67%;" />

当一个进程在运行并需要访问所需的资源时，会进行如下操作：

1. 查找资源是否存在
2. 检查DAC是否允许访问
3. 检查 LSM hook（SELinux）是否允许访问

### SELinux 三种工作模式

1. enforceing：强制模式。违反SELinux规则的行为将被阻止并记录到日志中
2. permissive：宽容模式：违反S。ELinux规则的行为将会被允许。并记录到日志中
3. disabled：关闭SELinux

```bash
[root@localhost selinux]# vim /etc/selinux/config
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of these three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted
```

### SELinux 状态管理：修改工作模式

设置SELinux模式及开关使用命令有3个：

+ getenforce	# 获取SELinux的当前状态

  ```bash
  [root@localhost selinux]# getenforce
  Enforcing
  ```

+ sestatus # 查看SELinux完整状态

  ```bash
  [root@localhost selinux]# sestatus
  SELinux status:                 enabled
  SELinuxfs mount:                /sys/fs/selinux
  SELinux root directory:         /etc/selinux
  Loaded policy name:             targeted
  Current mode:                   enforcing
  Mode from config file:          enforcing
  Policy MLS status:              enabled
  Policy deny_unknown status:     allowed
  Memory protection checking:     actual (secure)
  Max kernel policy version:      31
  ```

+ setenforce[Enforcing|Permissive 0|1]

  ```bash
  [root@localhost selinux]# setenforce  1
  ```

  

+ 通过修改`/etc/selinux/config`做到永久设置

  ```
  [root@localhost selinux]# vim /etc/selinux/config
  # This file controls the state of SELinux on the system.
  # SELINUX= can take one of these three values:
  #     enforcing - SELinux security policy is enforced.
  #     permissive - SELinux prints warnings instead of enforcing.
  #     disabled - No SELinux policy is loaded.
  SELINUX=enforcing
  # SELINUXTYPE= can take one of these three values:
  #     targeted - Targeted processes are protected,
  #     minimum - Modification of targeted policy. Only selected processes are protected.
  #     mls - Multi Level Security protection.
  SELINUXTYPE=targeted
  ```

  

## SELinux 的安全上下文介绍

SELinux中“一切都得有一个标签”

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524202705538.png" alt="image-20230524202705538" style="zoom: 50%;" />

## SELinux 用户管理

### SELinux用户管理概述

> 本地用户会映射SELinux用户

<img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524211613883.png" alt="image-20230524211613883" style="zoom: 67%;" />

+ 查看Linux中的用户

  ```bash
  [root@localhost selinux]# cat /etc/passwd
  root:x:0:0:root:/root:/bin/bash
  bin:x:1:1:bin:/bin:/sbin/nologin
  daemon:x:2:2:daemon:/sbin:/sbin/nologin
  adm:x:3:4:adm:/var/adm:/sbin/nologin
  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
  sync:x:5:0:sync:/sbin:/bin/sync
  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
  halt:x:7:0:halt:/sbin:/sbin/halt
  mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
  operator:x:11:0:operator:/root:/sbin/nologin
  games:x:12:100:games:/usr/games:/sbin/nologin
  ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
  nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin
  dbus:x:81:81:System message bus:/:/sbin/nologin
  systemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin
  systemd-resolve:x:193:193:systemd Resolver:/:/sbin/nologin
  tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin
  polkitd:x:998:996:User for polkitd:/:/sbin/nologin
  geoclue:x:997:995:User for geoclue:/var/lib/geoclue:/sbin/nologin
  rtkit:x:172:172:RealtimeKit:/proc:/sbin/nologin
  pulse:x:171:171:PulseAudio System Daemon:/var/run/pulse:/sbin/nologin
  qemu:x:107:107:qemu user:/:/sbin/nologin
  usbmuxd:x:113:113:usbmuxd user:/:/sbin/nologin
  unbound:x:996:991:Unbound DNS resolver:/etc/unbound:/sbin/nologin
  rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
  gluster:x:995:990:GlusterFS daemons:/run/gluster:/sbin/nologin
  chrony:x:994:989::/var/lib/chrony:/sbin/nologin
  libstoragemgmt:x:993:987:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin
  pipewire:x:992:986:PipeWire System Daemon:/var/run/pipewire:/sbin/nologin
  setroubleshoot:x:991:985::/var/lib/setroubleshoot:/sbin/nologin
  saslauth:x:990:76:Saslauthd user:/run/saslauthd:/sbin/nologin
  dnsmasq:x:984:984:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin
  radvd:x:75:75:radvd user:/:/sbin/nologin
  clevis:x:983:982:Clevis Decryption Framework unprivileged user:/var/cache/clevis:/sbin/nologin
  cockpit-ws:x:982:980:User for cockpit-ws:/:/sbin/nologin
  sssd:x:981:979:User for sssd:/:/sbin/nologin
  colord:x:980:978:User for colord:/var/lib/colord:/sbin/nologin
  gdm:x:42:42::/var/lib/gdm:/sbin/nologin
  rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
  gnome-initial-setup:x:979:977::/run/gnome-initial-setup/:/sbin/nologin
  sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
  insights:x:978:976:Red Hat Insights:/var/lib/insights:/sbin/nologin
  avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
  tcpdump:x:72:72::/:/sbin/nologin
  admin:x:1000:1000:admin:/home/admin:/bin/bash
  apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin
  share:x:1001:1001::/home/share:/bin/bash
  ```

+ 查看SELinux的账户

  ```bash
  [root@localhost selinux]# semanage user -l
  
                  标记中        MLS/       MLS/
  SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色
  
  guest_u         user       s0         s0                             guest_r
  root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
  staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
  sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
  system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
  unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
  user_u          user       s0         s0                             user_r
  xguest_u        user       s0         s0                             xguest_r
  ```

+ 查看两者的映射关系；只会看到已登录的用户

  ```bash
  [root@localhost selinux]# semanage login -l
  
  登录名                  SELinux 用户           MLS/MCS 范围           服务
  
  __default__          unconfined_u         s0-s0:c0.c1023       *
  root                 unconfined_u         s0-s0:c0.c1023       *
  ```

  

### SELinux用户管理

![image-20230524212609097](%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8+%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6.assets/image-20230524212609097.png)

#### 添加映射关系

`-a`：添加映射关系

`-s`：指定映射的SELinux user用户

```bash
# 将share用户的SELinux用户映射为staff_u
[root@localhost ~]# semanage login -a -s staff_u share
```

#### 修改映射关系

`-m`：修改映射关系

`-s`：指定映射的SELinux user用户

```bash
# 将share的SELinux用户的映射关系修改为：sysadm_u
[root@localhost ~]# semanage login -m -s sysadm_u share
```

#### 删除映射关系

`-d`：删除映射关系

```bash
[root@localhost ~]# semanage login -d share
```

#### 添加自定义SELinux用户

`-a`：添加新用户

`-R`：指定角色身份

```bash
[root@localhost ~]# semanage user -a -R staff_r new_user
[root@localhost ~]# semanage user -l

                标记中        MLS/       MLS/
SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色

guest_u         user       s0         s0                             guest_r
new_user        user       s0         s0                             staff_r		# 新添加的用户
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
```

#### 修改自定义SELinux用户

```bash
[root@localhost ~]# semanage user -m -R "guest_r" new_user
[root@localhost ~]# semanage user -l

                标记中        MLS/       MLS/
SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色

guest_u         user       s0         s0                             guest_r
new_user        user       s0         s0                             guest_r		# 被修改用户
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
```

#### 删除自定义SELinux用户

```bash
[root@localhost ~]# semanage user -d  new_user
[root@localhost ~]# semanage user -l

                标记中        MLS/       MLS/
SELinux 用户      前缀         MCS 级别     MCS 范围                         SELinux 角色

guest_u         user       s0         s0                             guest_r
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r
```

## SELinux的布尔值操作

### `getsebool`查看相应服务的布尔值

```bash
[root@localhost ~]# getsebool samba_share_nfs
samba_share_nfs --> off
```

### `setsebool`设置相应服务的布尔值

```bash
[root@localhost ~]# setsebool samba_share_nfs on
```

### semange修改布尔值

```bash
[root@localhost ~]# semanage boolean -m user_exec_content -1
[root@localhost ~]# getsebool user_exec_content
user_exec_content --> on
```

## SELinux的文件上下文

```bash
[root@localhost data]# ls -Z
unconfined_u:object_r:default_t:s0 app1
SELinux 用户 SELinux 角色  上下文	
```

每一个文件都会有其相对应的上下文，每个进程主体通过判断其上下文来识别出是否是其管理的文件，并判断是否给予运行

+ 创建新文件：会继承父目录的上下文
+ 复制文件：会继承父目录的上下文
+ 移动文件：会保留原有的上下文

### SELinux 文件上下文

#### chcon用法解释

```
chcon [选项]... 环境 文件... 
chcon [选项]... [-u 用户] [-r 角色] [-l 范围] [-t 类型] 文件... 
chcon [选项]... --reference=参考文件 文件...

-h, --no-dereference：影响符号连接而非引用的文件。
 --reference=参考文件：使用指定参考文件的安全环境，而非指定值。 
-R, --recursive：递归处理所有的文件及子目录。 
-v, --verbose：为处理的所有文件显示诊断信息。 
-u, --user=用户：设置指定用户的目标安全环境。
-r, --role=角色：设置指定角色的目标安全环境。
-t, --type=类型：设置指定类型的目标安全环境。 
-l, --range=范围：设置指定范围的目标安全环境。
```



```bash
unconfined_u:object_r:default_t:s0 app1  unconfined_u:object_r:default_t:s0 app2
[root@localhost data]# chcon -v -t default_t /data/app1
正在更改'/data/app1' 的安全环境
```

通过参考第一个文件来修改上下文

```bash
[root@localhost data]# chcon --reference /data/app1 /data/app2
```

恢复上下文

```bash
[root@localhost data]# restorecon -F /data/app1/
```

## SELinux进程上下文

### 查看HTTP进程上下文

```bash
[root@localhost data]# ps -eZ|grep httpd
system_u:system_r:httpd_t:s0     10774 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10775 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10776 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10777 ?        00:00:00 httpd
system_u:system_r:httpd_t:s0     10778 ?        00:00:00 httpd
```

### 查看HTTP文件上下文

```bash
[root@localhost data]# ls -Z /var/www/
unconfined_u:object_r:httpd_sys_content_t:s0 8088         system_u:object_r:httpd_sys_content_t:s0 html
unconfined_u:object_r:httpd_sys_content_t:s0 8089     unconfined_u:object_r:httpd_sys_content_t:s0 www1
system_u:object_r:httpd_sys_script_exec_t:s0 cgi-bin  unconfined_u:object_r:httpd_sys_content_t:s0 www2
```

### SELinux 端口上下文

#### 1、修改HTTP服务监听端口

```bash
[root@localhost ~]# vim /etc/httpd/conf/httpd.conf
Listen 12345
```

#### 2、重启服务-重启失败

```bash
[root@localhost ~]# systemctl restart httpd.service
Job for httpd.service failed because the control process exited with error code.
See "systemctl status httpd.service" and "journalctl -xe" for details.
```

#### 3、查看SELinux HTTP 相关端口

可以看到由于`http_port_t `并没有运行对端口12345进行监听，导致服务启动失败

```bash
[root@localhost ~]# semanage port -l |grep http
http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010
http_cache_port_t              udp      3130
http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t            tcp      5988
pegasus_https_port_t           tcp      5989
```

#### 4、添加端口

`-a`：添加端口

`-t`：指定类型

`-p`：指定端口

```bash
[root@localhost ~]# semanage port -a -t http_port_t -p tcp 12345
[root@localhost ~]# semanage port -l |grep http
http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010
http_cache_port_t              udp      3130
http_port_t                    tcp      12345, 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t            tcp      5988
pegasus_https_port_t           tcp      5989

# 重启成功
[root@localhost ~]# systemctl restart httpd.service
```

#### 删除规则

```bash
[root@localhost ~]# semanage port -d -t http_port_t -p tcp 12345
```

# 文本处理三剑客

## 通配符

```
* - 代表所有
? - 通配符，代表任意1个字符
; - 连续不同命令的分隔符
# - 配置文件注释
| - 管道符
~ - 当前用户的家目录
- - 上次的目录或者路径
$ - 变量前需要加的符号
	[root@localhost log]# echo $USER
	root

/ - 路径分割符号
> - 重定向
>> - 追加
< - 输入重定向
<< - 追加输入重定向
` - 单引号，不具备变量置换的功能，不解析函数，所见即所得
	[root@localhost log]# echo 'data'
	data
“ - 双引号，具有变量置换功能，解析函数
	[root@localhost log]# echo "`ls`"
    10:00:00
    error.log
    error-ssl.log
反引号 - 解析命令
    [root@localhost log]# echo `ls`
    10:00:00 error.log error-ssl.log
{} - 内容序列
	[root@localhost log]# echo data{1,2,3}
	data1 data2 data3
! - 取反
&& - and
|| - or
.. - 上一级目录
. - 当前目录
```

## 正则表达式

```
^word	匹配以word开头的内容
[root@localhost log]# grep "^root" /etc/passwd
root:x:0:0:root:/root:/bin/bash

word$	匹配以word结尾的内容
[root@localhost log]# grep "bash$" /etc/passwd
root:x:0:0:root:/root:/bin/bash
admin:x:1000:1000:admin:/home/admin:/bin/bash

^$		表示空
.		代表且只能代表一个字符
\		转义符号。例\.代表.本身
*		匹配0个或多个
.*		匹配所有字符

[abc]	匹配字符abc任意一个[a-z|0-9]
[^abc]	排除匹配字符abc任意一个

a\{n,m\}	匹配a字符n-m次
[root@localhost log]# grep "0\{3\}" /etc/passwd
admin:x:1000:1000:admin:/home/admin:/bin/bash

a\{n}		匹配a字符n次
[root@localhost log]# grep "0\{1\}" /etc/passwd
root:x:0:0:root:/root:/bin/bash
sync:x:5:0:sync:/sbin:/bin/sync

a\{n,}		匹配a字符至少n次
[root@localhost log]# grep "0\{1,\}" /etc/passwd
root:x:0:0:root:/root:/bin/bash
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown

a\{,m}		匹配a字符最多m次
[root@localhost log]# grep "a\{,1\}" /etc/passwd
root:x:0:0:root:/root:/bin/bash

+ -			1个或多个
? - 		0个或1个
| - 		同时过滤多个字符串
() - 		分组过滤，满足一个即可
[root@localhost log]# grep -E "(root|admin)" /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
admin:x:1000:1000:admin:/home/admin:/bin/bash

```



## grep 文本过滤

### 格式

```bash
grep [options] pattern [file...]
```

### 常用选项

- `-i`：忽略大小写进行匹配。
- `-v`：反向查找，只打印不匹配的行。
- `-n`：显示匹配行的行号。
- `-r`：递归查找子目录中的文件。
- `-l`：只打印匹配的文件名。
- `-c`：只打印匹配的行数。

### 基本演示

**1. -v 反向选择**

```bash
# 不显示带有root字符串的信息
[root@localhost log]# grep -v root /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

**2. -i 忽略大小写**

```bash
[root@localhost log]# grep -i ROOT /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
```

**3. -n 显示文件行号**

```bash
[root@localhost log]# grep -n root /etc/passwd
1:root:x:0:0:root:/root:/bin/bash
10:operator:x:11:0:operator:/root:/sbin/nologin
```

**4. -c 计算数量**

```bash
[root@localhost log]# grep -c root /etc/passwd
2
```

**5. -o 只显示匹配到的字符串**

```bash
[root@localhost log]# grep -o root /etc/passwd
root
root
root
root
```

**6. -B 显示匹配信息与匹配信息的前n行**

```bash
[root@localhost log]# grep -B1 root /etc/passwd
root:x:0:0:root:/root:/bin/bash
--
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin

```

**7. -A 显示匹配信息与匹配信息的后n行**

```bash
[root@localhost log]# grep -A1 root /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
--
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
```

**8. -C 显示匹配信息与信息的上下n行**

```bash
[root@localhost log]# grep -C1 root /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
--
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin

```

**9. -e 匹配多个选项**

```bash
[root@localhost log]# grep -e root -e lp /etc/passwd
root:x:0:0:root:/root:/bin/bash
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin

```

**10. -w 匹配单个单词**

```bash
[root@localhost log]# netstat -anut |grep -w 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN

```

### 实战：找出root最后一次登录的IP地址

```bash
[root@localhost ~]# last |grep "root" | grep "[0-9].[0-9].[0-9]"
root     pts/1        192.168.231.1    Fri Jun 16 06:07    gone - no logout
root     pts/0        192.168.231.1    Tue Jun 13 12:07 - 12:27  (00:19)
root     pts/0        192.168.231.1    Tue Jun 13 09:54 - 11:21  (01:27)
root     pts/1        192.168.231.132  Mon Jun 12 08:32 - 08:32  (00:00)
root     pts/0        192.168.231.1    Mon Jun 12 08:30 - 09:50  (01:19)
root     pts/1        192.168.231.1    Sun Jun 11 09:19 - 09:51  (00:32)
```

## sed 流编辑器

“sed” 是一个 Linux 命令行工具，用于对文本文件进行基于流的编辑。在 “sed” 中，模式空间（pattern space）是一个缓冲区，用于存储当前正在处理的行。

当 “sed” 读取一个新行时，它会将该行复制到模式空间中。然后，“sed” 会根据指定的命令对模式空间中的文本进行编辑。最后，当 “sed” 处理完一行时，它会打印模式空间中的内容（除非指定了 “-n” 选项），然后清空模式空间，以便处理下一行。

### 语法

```
sed [-hnV][-e<script>][-f<script文件>][文本文件]
```

**参数说明**：

- -e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
- -f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。
- -h或--help 显示帮助。
- -n或--quiet或--silent 仅显示script处理后的结果。
- -V或--version 显示版本信息。
- -i 确定操作，默认不改变文件

**动作说明**：

- a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
- c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
- d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；
- i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
- p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
- s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s/old/new/g 就是啦！

### 演示

**打印第n行**

```bash
[root@localhost test]# sed -n '1p' passwd
root:x:0:0:root:/root:/bin/bash
```

**打印偶数行**

```bash
# sed -n '从第x行开始~步长yp'
[root@localhost test]# seq 1 10 |sed -n '2~2p'
2
4
6
8
10

```

**删除奇数行**

```bash
[root@localhost test]# seq 1 10 | sed  '1,2d'
3
4
5
6
7
8
9
10
```

**追加字符串 a 在索引的后面**

```bash
[root@localhost test]# seq 1 10 | sed '2ahello'
1
2
hello
3
4
5
6
7
8
9
10
```

**插入字符串 i 在索引的前面**

```bash
[root@localhost test]# seq 1 10 | sed '2ihello'
1
hello
2
3
4
5
6
7
8
9
10
```

**替换指定行 c**

```bash
[root@localhost test]# seq 1 10 | sed '2chello'
1
hello
3
4
5
6
7
8
9
10
```

**-i.bak 修改文件并备份**

```bash
# 删除第二行并创建备份文件
[root@localhost test]# cat -n passwd |sed -i.bak '2d'
[root@localhost test]# ls
passwd  passwd.bak
```

**sed批量修改字符**

```bash
# 将所有的root替换为roat，g 重复替换，i不区分大小写
[root@localhost test]# sed 's/root/roat/gi' passwd |head
roat:x:0:0:roat:/roat:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

# 将第1-10行的所有roat替换为root，g 重复替换，i不区分大小写
[root@localhost test]# sed '1,10s/root/root/gi' passwd |head
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
```

**sed正则准确匹配root**

```bash
# -r 使用正则；\<root\> 规定bian
[root@localhost test]# sed -r 's/\<root\>/rooter/gi' passwd |head
rooter:x:0:0:rooter:/rooter:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

```

## awk 模式扫描和处理语言

### 语法

```
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

**选项参数说明：**

- -F fs or --field-separator fs
  指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
- -v var=value or --asign var=value
  赋值一个用户定义变量。
- -f scripfile or --file scriptfile
  从脚本文件中读取awk命令。
- -mf nnn and -mr nnn
  对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
- -W compact or --compat, -W traditional or --traditional
  在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。
- -W copyleft or --copyleft, -W copyright or --copyright
  打印简短的版权信息。
- -W help or --help, -W usage or --usage
  打印全部awk选项和每个选项的简短说明。
- -W lint or --lint
  打印不能向传统unix平台移植的结构的警告。
- -W lint-old or --lint-old
  打印关于不能向传统unix平台移植的结构的警告。
- -W posix
  打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。
- -W re-interval or --re-inerval
  允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。
- -W source program-text or --source program-text
  使用program-text作为源代码，可与-f命令混用。
- -W version or --version
  打印bug报告信息的版本。

### 分隔符、域和记录

+ 由分隔符分隔的字段（列column,域field)标记$1，$2.$n称为域标识，$0为所有域，注意：和shell中变量$符含义不同
+ 文件的每一行称为记录record
+ 如果省略action,则默认执行print$0的操作

### 动作print

格式：

```
print item1, item2
```

说明：

+ 逗号分隔符
+ 输出item可以字符串，也可是数值；当前记录的字段、变量或awk的表达式
+ 如省略item,相当于print$O

演示：

打印出日志文件中访问次数最多的IP地址

```bash
# $1指定打印第一列的内容，uniq 删除重复出现的IP地址并使用 -c 做次数统计，sort 做排序，-n 从小到大排序，-r倒序
[root@localhost log]# awk '{print $1}' access.log | uniq -c |sort -nr |head
  14200 201.54.214.79
   3016 201.54.214.79
   2924 201.54.214.79
   2662 20.195.192.160
   2582 201.54.214.79
   2171 201.54.208.61
   2110 201.54.214.79
   2002 20.195.192.160
   1727 20.195.192.160
   1686 201.54.214.79

# 取出访问量前3的IP地址
[root@localhost log]# awk '{print $1}' access.log |uniq -c |sort -nr |head -3
  14200 201.54.214.79
   3016 201.54.214.79
   2924 201.54.214.79

# 取出iconfig中的所有IP地址
[root@localhost log]# ifconfig |awk '/inet [0-9].[0-9].[0-9]/ {print $2}'
192.168.231.133
127.0.0.1
192.168.122.1

```

